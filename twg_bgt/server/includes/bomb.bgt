censor_bomb@[] censor_bombs(0);
class censor_bomb
{
player@owner;
int z;
mapdata@map;
int x, y;
int seconds=1000;
int beeptime=500;
timer beeptimer, bombtimer;
timer scantimer;
bool d=false;
player@ p;
censor_bomb(int tx,int ty,int tz, mapdata@m, player@p)
{
x=tx;
y=ty;
z=tz;
@map=m;
@owner=p;
}
bool censorcheck()
{
int ind=get_player_index_from(owner.name);
if(ind>-1&&@owner==null) @owner=players[ind];
else if(ind<0&&@owner!=null) @owner=null;
bool ret=false;
for(uint i2=0; i2<players.length(); i2++)
{
if(are_teamed(owner.name,players[i2].name) or in_vehicle(players[i2])>-1 or in_motor(players[i2])>-1 or players[i2].is_dead or is_safe(players[i2].x,players[i2].y,players[i2].z,maps[get_map_index(players[i2].map)]) or players[i2].safe or players[i2].pvp==0 or players[i2].away or players[i2].afk or players[i2].newb==1 or players[i2].looking!="") continue;
if (owner.pvp==1 and players[i2].map==map.name and players[i2].name!=owner.name and get_3d_distance(x,y,z,players[i2].x,players[i2].y,players[i2].z)<=15)
{
ret=true;
}
}
for(uint i2=0; i2<vs.length(); i2++)
{
if (vs[i2].map==map.name and vs[i2].owner!=owner.name and get_3d_distance(x,y,z,vs[i2].x,vs[i2].y,vs[i2].z)<=15)
{
ret=true;
}
}
for(uint i2=0; i2<mos.length(); i2++)
{
if (mos[i2].map==map.name and mos[i2].owner!=owner.name and get_3d_distance(x,y,z,mos[i2].x,mos[i2].y,mos[i2].z)<=15)
{
ret=true;
}
}
for(uint i2=0; i2<vvehicles.length(); i2++)
{
if (vvehicles[i2].map==map.name and vvehicles[i2].owner!=owner.name and get_3d_distance(x,y,z,vvehicles[i2].x,vvehicles[i2].y,vvehicles[i2].z)<=15)
{
ret=true;
}
}
for(uint i2=0; i2<mmotors.length(); i2++)
{
if (mmotors[i2].map==map.name and mmotors[i2].owner!=owner.name and get_3d_distance(x,y,z,mmotors[i2].x,mmotors[i2].y,mmotors[i2].z)<=15)
{
ret=true;
}
}
return ret;
}
void loop(int i)
{
if(@map==null or @owner==null)
{
censor_bombs.remove_at(i);
return;
}
if(scantimer.elapsed>=1000 )
{
scantimer.restart();
send_packet(6,"play censor_bombscan.ogg "+x+" "+y+" "+z,x,y,z,maps[get_map_index(map.name)]);
bool t=d;
d=censorcheck();
if(t==false and d==true) {beeptimer.restart();bombtimer.restart();}
}
if(d==true)
{
seconds=3000-bombtimer.elapsed;
if (beeptimer.elapsed>=beeptime)
{
if(seconds>300) d=censorcheck();
beeptimer.restart();
send_packet(6,"play censor_bombbeep.ogg "+x+" "+y+" "+z,x,y,z,maps[get_map_index(map.name)]);
}
if (seconds<=0)
{
send_packet(6,"play censor_bomb.ogg "+x+" "+y+" "+z,x,y,z,maps[get_map_index(map.name)]);
send_packet(6,"play censor_bombhit.ogg "+x+" "+y+" "+z,x,y,z,maps[get_map_index(map.name)]);
send_dpacket(6,"distsound censor_bombdist "+x+" "+y+" "+z+" "+map.name,maps[get_map_index(map.name)]);
for (uint i2=0; i2<players.length(); i2++)
{
if(are_teamed(owner.name,players[i2].name) or in_vehicle(players[i2])>-1 or in_motor(players[i2])>-1 or players[i2].is_dead or is_safe(players[i2].x,players[i2].y,players[i2].z,maps[get_map_index(players[i2].map)]) or players[i2].safe or players[i2].pvp==0 or players[i2].away or players[i2].afk or players[i2].newb==1 or players[i2].looking!="") continue;
if (owner.pvp==1 and players[i2].map==map.name and get_3d_distance(x,y,z,players[i2].x,players[i2].y,players[i2].z)<=20)
{
players[i2].hit(2000,8000);
players[i2].should_subtract=false;
players[i2].hitby=owner.name+"'s censor bomb";
send_packet(6,"play censor_bombhit.ogg "+players[i2].x+" "+players[i2].y+" "+players[i2].z, players[i2].x,players[i2].y,players[i2].z,maps[get_map_index(players[i2].map)]);
}
}
for (uint i2=0; i2<ais.length(); i2++)
{
if (ais[i2].map.name==map.name and get_3d_distance(x,y,z,ais[i2].x,ais[i2].y,ais[i2].z)<=20)
{
ais[i2].health-=random(2500,6500);
ais[i2].hitby=owner.name+"'s censor bomb";
send_packet(6,"play h"+random(1,5)+".ogg "+ais[i2].x+" "+ais[i2].y+" "+ais[i2].z,ais[i2].x,ais[i2].y,ais[i2].z,maps[get_map_index(ais[i2].map.name)]);
}
}
for (uint i2=0; i2<houses.length(); i2++)
{
if (owner.pvp==1 and houses[i2].map==map.name and get_3d_distance(x,y,z,houses[i2].x,houses[i2].y,houses[i2].z)<=20)
{
send_packet(6,"play base_impact_ext.ogg "+houses[i2].x+" "+houses[i2].y+" "+houses[i2].z,houses[i2].x,houses[i2].y,houses[i2].z,maps[get_map_index(houses[i2].map)]);
houses[i2].health-=random(2500,6500);
houses[i2].hitby=owner.name+"'s censor bomb";
}
}
for (uint i2=0; i2<lockers.length(); i2++)
{
if (owner.pvp==1 and lockers[i2].map==map.name and get_3d_distance(x,y,z,lockers[i2].x,lockers[i2].y,lockers[i2].z)<=20)
{
send_packet(6,"play locker_hit"+random(1, 6)+".ogg "+lockers[i2].x+" "+lockers[i2].y+" "+lockers[i2].z,lockers[i2].x,lockers[i2].y,lockers[i2].z,maps[get_map_index(lockers[i2].map)]);
lockers[i2].health-=random(2500,6500);
lockers[i2].hitby=owner.name+"'s censor bomb";
}
}
for (uint i2=0; i2<fridges.length(); i2++)
{
if (owner.pvp==1 and fridges[i2].map==map.name and get_3d_distance(x,y,z,fridges[i2].x,fridges[i2].y,fridges[i2].z)<=20)
{
send_packet(6,"play base_fridge_impact"+random(1, 3)+"",fridges[i2].x,fridges[i2].y,fridges[i2].z,maps[get_map_index(fridges[i2].map)]);
fridges[i2].health-=random(2500,6500);
fridges[i2].hitby=owner.name+"'s censor bomb";
}
}
for (uint i2=0; i2<robots.length(); i2++)
{
if (owner.pvp==1 and robots[i2].map.name==map.name and get_3d_distance(x,y,z,robots[i2].x,robots[i2].y,robots[i2].z)<=20)
{
send_packet(6,"play locker_hit"+random(1, 6)+".ogg "+robots[i2].x+" "+robots[i2].y+" "+robots[i2].z,robots[i2].x,robots[i2].y,robots[i2].z,maps[get_map_index(robots[i2].map.name)]);
robots[i2].health-=random(2500,6500);
robots[i2].hitby=owner.name+"'s censor bomb";
}
}
for (uint i2=0; i2<microwaves.length(); i2++)
{
if (owner.pvp==1 and microwaves[i2].map==map.name and get_3d_distance(x,y,z,microwaves[i2].x,microwaves[i2].y,microwaves[i2].z)<=20)
{
send_packet(6,"play locker_hit"+random(1, 6)+".ogg "+microwaves[i2].x+" "+microwaves[i2].y+" "+microwaves[i2].z,microwaves[i2].x,microwaves[i2].y,microwaves[i2].z,maps[get_map_index(microwaves[i2].map)]);
microwaves[i2].health-=random(2500,6500);
microwaves[i2].hitby=owner.name+"'s censor bomb";
}
}
for (uint i2=0; i2<air_conditioners.length(); i2++)
{
if (owner.pvp==1 and air_conditioners[i2].map==map.name and get_3d_distance(x,y,z,air_conditioners[i2].x,air_conditioners[i2].y,air_conditioners[i2].z)<=20)
{
send_packet(6,"play locker_hit"+random(1, 6)+".ogg "+air_conditioners[i2].x+" "+air_conditioners[i2].y+" "+air_conditioners[i2].z,air_conditioners[i2].x,air_conditioners[i2].y,air_conditioners[i2].z,maps[get_map_index(air_conditioners[i2].map)]);
air_conditioners[i2].health-=random(2500,6500);
air_conditioners[i2].hitby=owner.name+"'s censor bomb";
}
}
for (uint i2=0; i2<steams.length(); i2++)
{
if (owner.pvp==1 and steams[i2].map==map.name and get_3d_distance(x,y,z,steams[i2].x,steams[i2].y,steams[i2].z)<=20)
{
send_packet(6,"play locker_hit"+random(1, 6)+".ogg "+steams[i2].x+" "+steams[i2].y+" "+steams[i2].z,steams[i2].x,steams[i2].y,steams[i2].z,maps[get_map_index(steams[i2].map)]);
steams[i2].health-=random(2500,6500);
steams[i2].hitby=owner.name+"'s censor bomb";
}
}
for (uint i2=0; i2<fans.length(); i2++)
{
if (owner.pvp==1 and fans[i2].map==map.name and get_3d_distance(x,y,z,fans[i2].x,fans[i2].y,fans[i2].z)<=20)
{
send_packet(6,"play locker_hit"+random(1, 6)+".ogg "+fans[i2].x+" "+fans[i2].y+" "+fans[i2].z,fans[i2].x,fans[i2].y,fans[i2].z,maps[get_map_index(fans[i2].map)]);
fans[i2].health-=random(2500,6500);
fans[i2].hitby=owner.name+"'s censor bomb";
}
}
for (uint i2=0; i2<playerstores.length(); i2++)
{
if (owner.pvp==1 and playerstores[i2].map==map.name and get_3d_distance(x,y,z,playerstores[i2].x,playerstores[i2].y,playerstores[i2].z)<=20)
{
send_packet(6,"play base_impact_ext.ogg "+playerstores[i2].x+" "+playerstores[i2].y+" "+playerstores[i2].z,playerstores[i2].x,playerstores[i2].y,playerstores[i2].z,maps[get_map_index(playerstores[i2].map)]);
playerstores[i2].health-=random(2500,6500);
playerstores[i2].hitby=owner.name+"'s censor bomb";
}
}
for (uint i2=0; i2<beehives.length(); i2++)
{
if (owner.pvp==1 and beehives[i2].map==map.name and get_3d_distance(x,y,z,beehives[i2].x,beehives[i2].y,beehives[i2].z)<=20)
{
send_packet(6,"play base_impact_ext.ogg "+beehives[i2].x+" "+beehives[i2].y+" "+beehives[i2].z,beehives[i2].x,beehives[i2].y,beehives[i2].z,maps[get_map_index(beehives[i2].map)]);
beehives[i2].health-=random(2500,6500);
beehives[i2].hitby=owner.name+"'s censor bomb";
}
}
for (uint i2=0; i2<objs.length(); i2++)
{
if (owner.pvp==1 and objs[i2].map.name==map.name and get_3d_distance(x,y,z,objs[i2].x,objs[i2].y,objs[i2].z)<=20)
{
send_packet(6,"play obj_break"+random(1,3),objs[i2].x,objs[i2].y,objs[i2].z,maps[get_map_index(objs[i2].map.name)]);
remove_obj(i2);
}
}
for(uint v=0; v<vs.length(); v++)
{
if(owner.pvp==1 and vs[v].map==map.name and get_3d_distance(x,y,z,vs[v].x,vs[v].y,vs[v].z)<=20)
vs[v].hit(random(2000,8000),owner.name+"'s censor bomb");
}
for(uint m=0; m<mos.length(); m++)
{
if(owner.pvp==1 and mos[m].map==map.name and get_3d_distance(x,y,z,mos[m].x,mos[m].y,mos[m].z)<=20)
mos[m].hit(random(2000,8000),owner.name+"'s censor bomb");
}
for(uint v=0; v<vvehicles.length(); v++)
{
if(owner.pvp==1 and vvehicles[v].map==map.name and get_3d_distance(x,y,z,vvehicles[v].x,vvehicles[v].y,vvehicles[v].z)<=20)
vvehicles[v].hit(random(2000,8000),owner.name+"'s censor_bomb");
}
for(uint m=0; m<mmotors.length(); m++)
{
if(owner.pvp==1 and mmotors[m].map==map.name and get_3d_distance(x,y,z,mmotors[m].x,mmotors[m].y,mmotors[m].z)<=20)
mmotors[m].hit(random(2000,8000),owner.name+"'s censor_bomb");
}
censor_bombs.remove_at(i);
return;
}
}
}
}
void spawn_censor_bomb(int x,int y, int z, mapdata@m, player@p)
{
censor_bomb bomb(x,y,z,m,p);
if(@bomb.map==null or @bomb.owner==null) return;
else censor_bombs.insert_last(bomb);
}
void destroy_all_censor_bombs()
{
censor_bombs.resize(0);
}
string[] names;
double xp=0;
double teampoints=0;
double teamkills=0;
string s="";
string s2;
string[] outs;
nuclear_bomb@[] nuclear_bombs(0);
class nuclear_bomb
{
int x, y, z;
mapdata@map;
player@owner;
timer bombaatomicatimer, tbipar1, tbipar2;
int bombaatomicatime=60000;
nuclear_bomb(int cx, int cy, int cz, mapdata@m, player@p)
{
x=cx;
y=cy;
z=cz;
@map=m;
@owner=p;
send_packet(6,"play nuclearbombplace.ogg "+x+" "+y+" "+z,x,y,z,maps[get_map_index(map.name)]);
}
void loop(int i)
{
if(@map==null or @owner==null)
{
int index=get_player_index(nuclear_bombs[i].owner.peer_id);
if(index > -1)
{
nuclear_bombs[i].owner.nuclearbombspawned=0;
}
else
{
f.open("chars/"+nuclear_bombs[i].owner.name+"/nbstats.usr","wb");
f.write(0);
f.close();
}
nuclear_bombs.remove_at(i);
return;
}
if(tbipar1.elapsed>=10000&&bombaatomicatimer.elapsed<50000)
{
tbipar1.restart();
tbipar2.restart();
send_packet(6,"play nuclearbombbeep.ogg "+x+" "+y+" "+z,x,y,z,maps[get_map_index(map.name)]);
}
if(tbipar2.elapsed>=1000&&bombaatomicatimer.elapsed>=50000)
{
send_packet(6,"play nuclearbombbeep.ogg "+x+" "+y+" "+z,x,y,z,maps[get_map_index(map.name)]);
tbipar2.restart();
}
if(bombaatomicatimer.elapsed>=bombaatomicatime)
{
send_packet(6,"play nuclearbombexplode.ogg "+x+" "+y+" "+z,x,y,z,maps[get_map_index(map.name)]);
send_dpacket(6,"distsound nuclearbombexplode "+x+" "+y+" "+z+" "+map.name,maps[get_map_index(map.name)]);
for(uint p=0; p<players.length(); p++)
{
if(are_teamed(owner.name,players[p].name) or in_vehicle(players[p])>-1 or in_motor(players[p])>-1 or players[p].is_dead or is_safe(players[p].x,players[p].y,players[p].z,maps[get_map_index(players[p].map)]) or players[p].safe or players[p].pvp==0 or players[p].away or players[p].afk or players[p].newb==1 or players[p].looking!="") continue;
if(owner.pvp==1 and players[p].map==map.name)
{
players[p].health-=random(5000, 10000);
players[p].hitby="nuclear_bomb_of_"+owner.name;
}
}
for(uint i2=0;i2<ais.length();i2++)
{
if(ais[i2].nuclearbomb==false or ais[i2].protected) continue;
names.insert_last(""+ais[i2].name+" on "+get_zone_at(ais[i2].x,ais[i2].y,ais[i2].z,maps[get_map_index(ais[i2].map.name)])+"");
xp+=ais[i2].xp*owner.reinforcement;
teampoints+=random(20,100);
teamkills++;
if (ais[i2].voice!="" and ais[i2].rapidvoice==true) destroy_moving_sound(ais[i2].voice);
@ais[i2]=null;
ais.remove_at(i2);
i2--;
return;
}
if(names.length>1)
{
for(uint i=0; i<names.length(); i++)
{
if(i==(names.length-1)) s+="and "+names[i]+".";
else s+=names[i]+", ";
}
}
else
for(uint i=0; i<names.length(); i++)
{
s=names[i]+" ";
}
s2=" "+names.length()+" "+(names.length()>1?"creatures were":"creature was")+" killed by "+owner.name+"'s nuclear bomb: ";
if(names.length()>1) send_reliable(0,"kills "+s2+s, 0);
if(xp>0) givexp(players[get_player_index_from(owner.name)],xp);
if(teampoints>0)
{
int t=is_in_team(owner.name);
if(t>-1)
{
teams[t].teamkills+=teamkills;
teams[t].points+=teampoints;
teams[t].transmit("This team just got "+teampoints+" points!");
}
}
names.resize(0);
xp=0;
teampoints=0;
teamkills=0;
s="";
s2="";
outs.resize(0);
for(uint i2=0;i2<vs.length();i2++)
{
if(owner.pvp==1 and vs[i2].map==map.name)
{
names.insert_last(""+vs[i2].type+" on "+get_zone_at(vs[i2].x,vs[i2].y,vs[i2].z,maps[get_map_index(vs[i2].map)])+"");
xp+=random(100,300)*owner.reinforcement;
teampoints+=random(100,300);
@vs[i2]=null;
vs.remove_at(i2);
i2--;
return;
}
}
if(names.length>1)
{
for(uint i=0; i<names.length(); i++)
{
if(i==(names.length-1)) s+="and "+names[i]+".";
else s+=names[i]+", ";
}
}
else
for(uint i=0; i<names.length(); i++)
{
s=names[i]+" ";
}
s2=" "+names.length()+" "+(names.length()>1?"cars were":"car was")+" destroyed by "+owner.name+"'s nuclear bomb: ";
if(names.length()>1) send_reliable(0,"kills "+s2+s, 0);
if(xp>0) givexp(players[get_player_index_from(owner.name)],xp);
if(teampoints>0)
{
int t=is_in_team(owner.name);
if(t>-1)
{
teams[t].points+=teampoints;
teams[t].transmit("This team just got "+teampoints+" points!");
}
}
names.resize(0);
xp=0;
teampoints=0;
s="";
s2="";
outs.resize(0);
for(uint i2=0;i2<mos.length();i2++)
{
if(owner.pvp==1 and mos[i2].map==map.name)
{
names.insert_last(""+mos[i2].type+" on "+get_zone_at(mos[i2].x,mos[i2].y,mos[i2].z,maps[get_map_index(mos[i2].map)])+"");
xp+=random(100,300)*owner.reinforcement;
teampoints+=random(100,300);
@mos[i2]=null;
mos.remove_at(i2);
i2--;
return;
}
}
if(names.length>1)
{
for(uint i=0; i<names.length(); i++)
{
if(i==(names.length-1)) s+="and "+names[i]+".";
else s+=names[i]+", ";
}
}
else
for(uint i=0; i<names.length(); i++)
{
s=names[i]+" ";
}
s2=" "+names.length()+" "+(names.length()>1?"motorcycles were":"motorcycle was")+" destroyed by "+owner.name+"'s nuclear bomb: ";
if(names.length()>1) send_reliable(0,"kills "+s2+s, 0);
if(xp>0) givexp(players[get_player_index_from(owner.name)],xp);
if(teampoints>0)
{
int t=is_in_team(owner.name);
if(t>-1)
{
teams[t].points+=teampoints;
teams[t].transmit("This team just got "+teampoints+" points!");
}
}
names.resize(0);
xp=0;
teampoints=0;
s="";
s2="";
outs.resize(0);
for(uint i2=0;i2<vvehicles.length();i2++)
{
if(owner.pvp==1 and vvehicles[i2].map==map.name)
{
names.insert_last(""+vvehicles[i2].type+" on "+get_zone_at(vvehicles[i2].x,vvehicles[i2].y,vvehicles[i2].z,maps[get_map_index(vvehicles[i2].map)])+"");
xp+=random(100,300)*owner.reinforcement;
teampoints+=random(100,300);
file_delete("vehicles/"+vvehicles[i2].id+".vehicle");
@vvehicles[i2]=null;
vvehicles.remove_at(i2);
i2--;
return;
}
}
if(names.length>1)
{
for(uint i=0; i<names.length(); i++)
{
if(i==(names.length-1)) s+="and "+names[i]+".";
else s+=names[i]+", ";
}
}
else
for(uint i=0; i<names.length(); i++)
{
s=names[i]+" ";
}
s2=" "+names.length()+" "+(names.length()>1?"cars were":"car was")+" destroyed by "+owner.name+"'s nuclear bomb: ";
if(names.length()>1) send_reliable(0,"kills "+s2+s, 0);
if(xp>0) givexp(players[get_player_index_from(owner.name)],xp);
if(teampoints>0)
{
int t=is_in_team(owner.name);
if(t>-1)
{
teams[t].points+=teampoints;
teams[t].transmit("This team just got "+teampoints+" points!");
}
}
names.resize(0);
xp=0;
teampoints=0;
s="";
s2="";
outs.resize(0);
for(uint i2=0;i2<mmotors.length();i2++)
{
if(owner.pvp==1 and mmotors[i2].map==map.name)
{
names.insert_last(""+mmotors[i2].type+" on "+get_zone_at(mmotors[i2].x,mmotors[i2].y,mmotors[i2].z,maps[get_map_index(mmotors[i2].map)])+"");
xp+=random(100,300)*owner.reinforcement;
teampoints+=random(100,300);
file_delete("vehicles/"+mmotors[i2].id+".motor");
@mmotors[i2]=null;
mmotors.remove_at(i2);
i2--;
return;
}
}
if(names.length>1)
{
for(uint i=0; i<names.length(); i++)
{
if(i==(names.length-1)) s+="and "+names[i]+".";
else s+=names[i]+", ";
}
}
else
for(uint i=0; i<names.length(); i++)
{
s=names[i]+" ";
}
s2=" "+names.length()+" "+(names.length()>1?"motorcycles were":"motorcycle was")+" destroyed by "+owner.name+"'s nuclear bomb: ";
if(names.length()>1) send_reliable(0,"kills "+s2+s, 0);
if(xp>0) givexp(players[get_player_index_from(owner.name)],xp);
if(teampoints>0)
{
int t=is_in_team(owner.name);
if(t>-1)
{
teams[t].points+=teampoints;
teams[t].transmit("This team just got "+teampoints+" points!");
}
}
names.resize(0);
xp=0;
teampoints=0;
s="";
s2="";
outs.resize(0);
for(uint i2=0;i2<houses.length();i2++)
{
if(owner.pvp==1 and houses[i2].map==map.name)
{
houses[i2].health-=random(10000,100000);
houses[i2].hitby=owner.name+"'s nuclear bomb";
}
}
for(uint i2=0;i2<beehives.length();i2++)
{
if(owner.pvp==1 and beehives[i2].map==map.name)
{
beehives[i2].health-=random(10000,100000);
beehives[i2].hitby=owner.name+"'s nuclear bomb";
}
}
for(uint i2=0;i2<playerstores.length();i2++)
{
if(owner.pvp==1 and playerstores[i2].map==map.name)
{
playerstores[i2].health-=random(10000,100000);
playerstores[i2].hitby=owner.name+"'s nuclear bomb";
}
}
for(uint i2=0;i2<lockers.length();i2++)
{
if(owner.pvp==1 and lockers[i2].map==map.name)
{
lockers[i2].health-=random(10000,100000);
lockers[i2].hitby=owner.name+"'s nuclear bomb";
}
}
for(uint i2=0;i2<fridges.length();i2++)
{
if(owner.pvp==1 and fridges[i2].map==map.name)
{
fridges[i2].health-=random(10000,100000);
fridges[i2].hitby=owner.name+"'s nuclear bomb";
}
}
for(uint i2=0;i2<microwaves.length();i2++)
{
if(owner.pvp==1 and microwaves[i2].map==map.name)
{
microwaves[i2].health-=random(10000,100000);
microwaves[i2].hitby=owner.name+"'s nuclear bomb";
}
}
for (uint i2=0; i2<air_conditioners.length(); i2++)
{
if (owner.pvp==1 and air_conditioners[i2].map==map.name and get_3d_distance(x,y,z,air_conditioners[i2].x,air_conditioners[i2].y,air_conditioners[i2].z)<=20)
{
air_conditioners[i2].health-=random(10000,100000);
air_conditioners[i2].hitby=owner.name+"'s nuclear bomb";
}
}
for (uint i2=0; i2<steams.length(); i2++)
{
if (owner.pvp==1 and steams[i2].map==map.name and get_3d_distance(x,y,z,steams[i2].x,steams[i2].y,steams[i2].z)<=20)
{
steams[i2].health-=random(10000,100000);
steams[i2].hitby=owner.name+"'s nuclear bomb";
}
}
for (uint i2=0; i2<fans.length(); i2++)
{
if (owner.pvp==1 and fans[i2].map==map.name and get_3d_distance(x,y,z,fans[i2].x,fans[i2].y,fans[i2].z)<=20)
{
fans[i2].health-=random(10000,100000);
fans[i2].hitby=owner.name+"'s nuclear bomb";
}
}
for(uint i2=0;i2<turrets.length();i2++)
{
if(owner.pvp==1 and turrets[i2].map.name==map.name)
{
names.insert_last(""+turrets[i2].owner.name+"'s turret "+turrets[i2].id+" on "+get_zone_at(turrets[i2].x,turrets[i2].y,turrets[i2].z,maps[get_map_index(turrets[i2].map.name)])+"");
xp+=random(100,300)*owner.reinforcement;
teampoints+=random(100,300);
@turrets[i2]=null;
turrets.remove_at(i2);
i2--;
return;
}
}if(names.length>1)
{
for(uint i=0; i<names.length(); i++)
{
if(i==(names.length-1)) s+="and "+names[i]+".";
else s+=names[i]+", ";
}
}
else
for(uint i=0; i<names.length(); i++)
{
s=names[i]+" ";
}
s2=" "+names.length()+" "+(names.length()>1?"turrets were":"turret was")+" destroyed by "+owner.name+"'s nuclear bomb: ";
if(names.length()>1) send_reliable(0,"kills "+s2+s, 0);
if(xp>0) givexp(players[get_player_index_from(owner.name)],xp);
if(teampoints>0)
{
int t=is_in_team(owner.name);
if(t>-1)
{
teams[t].points+=teampoints;
teams[t].transmit("This team just got "+teampoints+" points!");
}
}
names.resize(0);
xp=0;
teampoints=0;
s="";
s2="";
outs.resize(0);
int index=get_player_index(nuclear_bombs[i].owner.peer_id);
if(index > -1)
{
nuclear_bombs[i].owner.nuclearbombspawned=0;
}
else
{
f.open("chars/"+nuclear_bombs[i].owner.name+"/nbstats.usr","wb");
f.write(0);
f.close();
}
nuclear_bombs.remove_at(i);
return;
}
}
}
void spawn_nuclear_bomb(int x, int y, int z, mapdata@m, player@p)
{
nuclear_bomb bomb(x, y, z, m, p);
if(@bomb.map==null or @bomb.owner==null) return;
else nuclear_bombs.insert_last(bomb);
}
small_nuclear_bomb@[] small_nuclear_bombs(0);
class small_nuclear_bomb
{
int x, y, z;
mapdata@map;
player@owner;
timer bombaatomicatimer, tbipar1, tbipar2;
int bombaatomicatime=60000;
small_nuclear_bomb(int cx, int cy, int cz, mapdata@m, player@p)
{
x=cx;
y=cy;
z=cz;
@map=m;
@owner=p;
send_packet(6,"play nuclearbombplace.ogg "+x+" "+y+" "+z,x,y,z,maps[get_map_index(map.name)]);
}
void loop(int i)
{
if(@map==null or @owner==null)
{
int index=get_player_index(small_nuclear_bombs[i].owner.peer_id);
if(index > -1)
{
small_nuclear_bombs[i].owner.nuclearbombspawned=0;
}
else
{
f.open("chars/"+small_nuclear_bombs[i].owner.name+"/nbstats.usr","wb");
f.write(0);
f.close();
}
small_nuclear_bombs.remove_at(i);
return;
}
if(tbipar1.elapsed>=10000&&bombaatomicatimer.elapsed<50000)
{
tbipar1.restart();
tbipar2.restart();
send_packet(6,"play nuclearbombbeep.ogg "+x+" "+y+" "+z,x,y,z,maps[get_map_index(map.name)]);
}
if(tbipar2.elapsed>=1000&&bombaatomicatimer.elapsed>=50000)
{
send_packet(6,"play nuclearbombbeep.ogg "+x+" "+y+" "+z,x,y,z,maps[get_map_index(map.name)]);
tbipar2.restart();
}
if(bombaatomicatimer.elapsed>=bombaatomicatime)
{
send_packet(6,"play nuclearbombexplode.ogg "+x+" "+y+" "+z,x,y,z,maps[get_map_index(map.name)]);
send_dpacket(6,"distsound nuclearbombexplode "+x+" "+y+" "+z+" "+map.name,maps[get_map_index(map.name)]);
for(uint p=0; p<players.length(); p++)
{
if(are_teamed(owner.name,players[p].name) or in_vehicle(players[p])>-1 or in_motor(players[p])>-1 or players[p].is_dead or is_safe(players[p].x,players[p].y,players[p].z,maps[get_map_index(players[p].map)]) or players[p].safe or players[p].pvp==0 or players[p].away or players[p].afk or players[p].newb==1 or players[p].looking!="") continue;
if(owner.pvp==1 and players[p].map==map.name)
{
players[p].health-=random(5000, 10000);
players[p].hitby="small_nuclear_bomb_of_"+owner.name;
}
}
for(uint i2=0;i2<ais.length();i2++)
{
if(ais[i2].nuclearbomb==false or ais[i2].protected) continue;
if(ais[i2].map.name==map.name)
{
names.insert_last(""+ais[i2].name+" on "+get_zone_at(ais[i2].x,ais[i2].y,ais[i2].z,maps[get_map_index(ais[i2].map.name)])+"");
xp+=ais[i2].xp*owner.reinforcement;
teampoints+=random(20,100);
teamkills++;
if (ais[i2].voice!="" and ais[i2].rapidvoice==true) destroy_moving_sound(ais[i2].voice);
@ais[i2]=null;
ais.remove_at(i2);
i2--;
return;
}
}
if(names.length>1)
{
for(uint i=0; i<names.length(); i++)
{
if(i==(names.length-1)) s+="and "+names[i]+".";
else s+=names[i]+", ";
}
}
else
for(uint i=0; i<names.length(); i++)
{
s=names[i]+" ";
}
s2=" "+names.length()+" "+(names.length()>1?"creatures were":"creature was")+" killed by "+owner.name+"'s small nuclear bomb: ";
if(names.length()>1) send_reliable(0,"kills "+s2+s, 0);
if(xp>0) givexp(players[get_player_index_from(owner.name)],xp);
if(teampoints>0)
{
int t=is_in_team(owner.name);
if(t>-1)
{
teams[t].teamkills+=teamkills;
teams[t].points+=teampoints;
teams[t].transmit("This team just got "+teampoints+" points!");
}
}
names.resize(0);
xp=0;
teampoints=0;
teamkills=0;
s="";
s2="";
outs.resize(0);
for(uint i2=0;i2<vs.length();i2++)
{
if(owner.pvp==1 and vs[i2].map==map.name)
{
names.insert_last(""+vs[i2].type+" on "+get_zone_at(vs[i2].x,vs[i2].y,vs[i2].z,maps[get_map_index(vs[i2].map)])+"");
xp+=random(100,300)*owner.reinforcement;
teampoints+=random(100,300);
@vs[i2]=null;
vs.remove_at(i2);
i2--;
return;
}
}
if(names.length>1)
{
for(uint i=0; i<names.length(); i++)
{
if(i==(names.length-1)) s+="and "+names[i]+".";
else s+=names[i]+", ";
}
}
else
for(uint i=0; i<names.length(); i++)
{
s=names[i]+" ";
}
s2=" "+names.length()+" "+(names.length()>1?"cars were":"car was")+" destroyed by "+owner.name+"'s small nuclear bomb: ";
if(names.length()>1) send_reliable(0,"kills "+s2+s, 0);
if(xp>0) givexp(players[get_player_index_from(owner.name)],xp);
if(teampoints>0)
{
int t=is_in_team(owner.name);
if(t>-1)
{
teams[t].points+=teampoints;
teams[t].transmit("This team just got "+teampoints+" points!");
}
}
names.resize(0);
xp=0;
teampoints=0;
s="";
s2="";
outs.resize(0);
for(uint i2=0;i2<mos.length();i2++)
{
if(owner.pvp==1 and mos[i2].map==map.name)
{
names.insert_last(""+mos[i2].type+" on "+get_zone_at(mos[i2].x,mos[i2].y,mos[i2].z,maps[get_map_index(mos[i2].map)])+"");
xp+=random(100,300)*owner.reinforcement;
teampoints+=random(100,300);
@mos[i2]=null;
mos.remove_at(i2);
i2--;
return;
}
}
if(names.length>1)
{
for(uint i=0; i<names.length(); i++)
{
if(i==(names.length-1)) s+="and "+names[i]+".";
else s+=names[i]+", ";
}
}
else
for(uint i=0; i<names.length(); i++)
{
s=names[i]+" ";
}
s2=" "+names.length()+" "+(names.length()>1?"motorcycles were":"motorcycle was")+" destroyed by "+owner.name+"'s small nuclear bomb: ";
if(names.length()>1) send_reliable(0,"kills "+s2+s, 0);
if(xp>0) givexp(players[get_player_index_from(owner.name)],xp);
if(teampoints>0)
{
int t=is_in_team(owner.name);
if(t>-1)
{
teams[t].points+=teampoints;
teams[t].transmit("This team just got "+teampoints+" points!");
}
}
names.resize(0);
xp=0;
teampoints=0;
s="";
s2="";
outs.resize(0);
for(uint i2=0;i2<vvehicles.length();i2++)
{
if(owner.pvp==1 and vvehicles[i2].map==map.name)
{
names.insert_last(""+vvehicles[i2].type+" on "+get_zone_at(vvehicles[i2].x,vvehicles[i2].y,vvehicles[i2].z,maps[get_map_index(vvehicles[i2].map)])+"");
xp+=random(100,300)*owner.reinforcement;
teampoints+=random(100,300);
file_delete("vehicles/"+vvehicles[i2].id+".vehicle");
@vvehicles[i2]=null;
vvehicles.remove_at(i2);
i2--;
return;
}
}
if(names.length>1)
{
for(uint i=0; i<names.length(); i++)
{
if(i==(names.length-1)) s+="and "+names[i]+".";
else s+=names[i]+", ";
}
}
else
for(uint i=0; i<names.length(); i++)
{
s=names[i]+" ";
}
s2=" "+names.length()+" "+(names.length()>1?"cars were":"car was")+" destroyed by "+owner.name+"'s small nuclear bomb: ";
if(names.length()>1) send_reliable(0,"kills "+s2+s, 0);
if(xp>0) givexp(players[get_player_index_from(owner.name)],xp);
if(teampoints>0)
{
int t=is_in_team(owner.name);
if(t>-1)
{
teams[t].points+=teampoints;
teams[t].transmit("This team just got "+teampoints+" points!");
}
}
names.resize(0);
xp=0;
teampoints=0;
s="";
s2="";
outs.resize(0);
for(uint i2=0;i2<mmotors.length();i2++)
{
if(owner.pvp==1 and mmotors[i2].map==map.name)
{
names.insert_last(""+mmotors[i2].type+" on "+get_zone_at(mmotors[i2].x,mmotors[i2].y,mmotors[i2].z,maps[get_map_index(mmotors[i2].map)])+"");
xp+=random(100,300)*owner.reinforcement;
teampoints+=random(100,300);
file_delete("vehicles/"+mmotors[i2].id+".motor");
@mmotors[i2]=null;
mmotors.remove_at(i2);
i2--;
return;
}
}
if(names.length>1)
{
for(uint i=0; i<names.length(); i++)
{
if(i==(names.length-1)) s+="and "+names[i]+".";
else s+=names[i]+", ";
}
}
else
for(uint i=0; i<names.length(); i++)
{
s=names[i]+" ";
}
s2=" "+names.length()+" "+(names.length()>1?"motorcycles were":"motorcycle was")+" destroyed by "+owner.name+"'s small nuclear bomb: ";
if(names.length()>1) send_reliable(0,"kills "+s2+s, 0);
if(xp>0) givexp(players[get_player_index_from(owner.name)],xp);
if(teampoints>0)
{
int t=is_in_team(owner.name);
if(t>-1)
{
teams[t].points+=teampoints;
teams[t].transmit("This team just got "+teampoints+" points!");
}
}
names.resize(0);
xp=0;
teampoints=0;
s="";
s2="";
outs.resize(0);
for(uint i2=0;i2<houses.length();i2++)
{
if(owner.pvp==1 and houses[i2].map==map.name)
{
houses[i2].health-=random(10000,100000);
houses[i2].hitby=owner.name+"'s small nuclear bomb";
}
}
for(uint i2=0;i2<beehives.length();i2++)
{
if(owner.pvp==1 and beehives[i2].map==map.name)
{
beehives[i2].health-=random(10000,100000);
beehives[i2].hitby=owner.name+"'s small nuclear bomb";
}
}
for(uint i2=0;i2<playerstores.length();i2++)
{
if(owner.pvp==1 and playerstores[i2].map==map.name)
{
playerstores[i2].health-=random(10000,100000);
playerstores[i2].hitby=owner.name+"'s small nuclear bomb";
}
}
for(uint i2=0;i2<lockers.length();i2++)
{
if(owner.pvp==1 and lockers[i2].map==map.name)
{
lockers[i2].health-=random(10000,100000);
lockers[i2].hitby=owner.name+"'s small nuclear bomb";
}
}
for(uint i2=0;i2<fridges.length();i2++)
{
if(owner.pvp==1 and fridges[i2].map==map.name)
{
fridges[i2].health-=random(10000,100000);
fridges[i2].hitby=owner.name+"'s small nuclear bomb";
}
}
for(uint i2=0;i2<microwaves.length();i2++)
{
if(owner.pvp==1 and microwaves[i2].map==map.name)
{
microwaves[i2].health-=random(10000,100000);
microwaves[i2].hitby=owner.name+"'s small nuclear bomb";
}
}
for (uint i2=0; i2<air_conditioners.length(); i2++)
{
if (owner.pvp==1 and air_conditioners[i2].map==map.name and get_3d_distance(x,y,z,air_conditioners[i2].x,air_conditioners[i2].y,air_conditioners[i2].z)<=20)
{
air_conditioners[i2].health-=random(10000,100000);
air_conditioners[i2].hitby=owner.name+"'s small nuclear bomb";
}
}
for (uint i2=0; i2<steams.length(); i2++)
{
if (owner.pvp==1 and steams[i2].map==map.name and get_3d_distance(x,y,z,steams[i2].x,steams[i2].y,steams[i2].z)<=20)
{
steams[i2].health-=random(10000,100000);
steams[i2].hitby=owner.name+"'s small nuclear bomb";
}
}
for (uint i2=0; i2<fans.length(); i2++)
{
if (owner.pvp==1 and fans[i2].map==map.name and get_3d_distance(x,y,z,fans[i2].x,fans[i2].y,fans[i2].z)<=20)
{
fans[i2].health-=random(10000,100000);
fans[i2].hitby=owner.name+"'s small nuclear bomb";
}
}
for(uint i2=0;i2<turrets.length();i2++)
{
if(owner.pvp==1 and turrets[i2].map.name==map.name)
{
names.insert_last(""+turrets[i2].owner.name+"'s turret "+turrets[i2].id+" on "+get_zone_at(turrets[i2].x,turrets[i2].y,turrets[i2].z,maps[get_map_index(turrets[i2].map.name)])+"");
xp+=random(100,300)*owner.reinforcement;
teampoints+=random(100,300);
@turrets[i2]=null;
turrets.remove_at(i2);
i2--;
return;
}
}if(names.length>1)
{
for(uint i=0; i<names.length(); i++)
{
if(i==(names.length-1)) s+="and "+names[i]+".";
else s+=names[i]+", ";
}
}
else
for(uint i=0; i<names.length(); i++)
{
s=names[i]+" ";
}
s2=" "+names.length()+" "+(names.length()>1?"turrets were":"turret was")+" destroyed by "+owner.name+"'s small nuclear bomb: ";
if(names.length()>1) send_reliable(0,"kills "+s2+s, 0);
if(xp>0) givexp(players[get_player_index_from(owner.name)],xp);
if(teampoints>0)
{
int t=is_in_team(owner.name);
if(t>-1)
{
teams[t].points+=teampoints;
teams[t].transmit("This team just got "+teampoints+" points!");
}
}
names.resize(0);
xp=0;
teampoints=0;
s="";
s2="";
outs.resize(0);
int index=get_player_index(small_nuclear_bombs[i].owner.peer_id);
if(index > -1)
{
small_nuclear_bombs[i].owner.nuclearbombspawned=0;
}
else
{
f.open("chars/"+small_nuclear_bombs[i].owner.name+"/nbstats.usr","wb");
f.write(0);
f.close();
}
small_nuclear_bombs.remove_at(i);
return;
}
}
}
void spawn_small_nuclear_bomb(int x, int y, int z, mapdata@m, player@p)
{
small_nuclear_bomb bomb(x, y, z, m, p);
if(@bomb.map==null or @bomb.owner==null) return;
else small_nuclear_bombs.insert_last(bomb);
}
large_nuclear_bomb@[] large_nuclear_bombs(0);
class large_nuclear_bomb
{
int x, y, z;
mapdata@map;
player@owner;
timer bombaatomicatimer, tbipar1, tbipar2;
int bombaatomicatime=60000;
large_nuclear_bomb(int cx, int cy, int cz, mapdata@m, player@p)
{
x=cx;
y=cy;
z=cz;
@map=m;
@owner=p;
send_packet(6,"play nuclearbombplace.ogg "+x+" "+y+" "+z,x,y,z,maps[get_map_index(map.name)]);
}
void loop(int i)
{
if(@map==null or @owner==null)
{
int index=get_player_index(large_nuclear_bombs[i].owner.peer_id);
if(index > -1)
{
large_nuclear_bombs[i].owner.nuclearbombspawned=0;
}
else
{
f.open("chars/"+large_nuclear_bombs[i].owner.name+"/nbstats.usr","wb");
f.write(0);
f.close();
}
large_nuclear_bombs.remove_at(i);
return;
}
if(tbipar1.elapsed>=10000&&bombaatomicatimer.elapsed<50000)
{
tbipar1.restart();
tbipar2.restart();
send_packet(6,"play nuclearbombbeep.ogg "+x+" "+y+" "+z,x,y,z,maps[get_map_index(map.name)]);
}
if(tbipar2.elapsed>=1000&&bombaatomicatimer.elapsed>=50000)
{
send_packet(6,"play nuclearbombbeep.ogg "+x+" "+y+" "+z,x,y,z,maps[get_map_index(map.name)]);
tbipar2.restart();
}
if(bombaatomicatimer.elapsed>=bombaatomicatime)
{
send_packet(6,"play nuclearbombexplode.ogg "+x+" "+y+" "+z,x,y,z,maps[get_map_index(map.name)]);
send_dpacket(6,"distsound nuclearbombexplode "+x+" "+y+" "+z+" "+map.name,maps[get_map_index(map.name)]);
for(uint p=0; p<players.length(); p++)
{
if(are_teamed(owner.name,players[p].name) or in_vehicle(players[p])>-1 or in_motor(players[p])>-1 or players[p].is_dead or is_safe(players[p].x,players[p].y,players[p].z,maps[get_map_index(players[p].map)]) or players[p].safe or players[p].pvp==0 or players[p].away or players[p].afk or players[p].newb==1 or players[p].looking!="") continue;
if(owner.pvp==1 and players[p].map==map.name)
{
players[p].health-=random(5000, 10000);
players[p].hitby="large_nuclear_bomb_of_"+owner.name;
}
}
for(uint i2=0;i2<ais.length();i2++)
{
if(ais[i2].protected) continue;
names.insert_last(""+ais[i2].name+" on "+get_zone_at(ais[i2].x,ais[i2].y,ais[i2].z,maps[get_map_index(ais[i2].map.name)])+"");
xp+=ais[i2].xp*owner.reinforcement;
teampoints+=random(20,100);
teamkills++;
if (ais[i2].voice!="" and ais[i2].rapidvoice==true) destroy_moving_sound(ais[i2].voice);
@ais[i2]=null;
ais.remove_at(i2);
i2--;
return;
}
if(names.length>1)
{
for(uint i=0; i<names.length(); i++)
{
if(i==(names.length-1)) s+="and "+names[i]+".";
else s+=names[i]+", ";
}
}
else
for(uint i=0; i<names.length(); i++)
{
s=names[i]+" ";
}
s2=" "+names.length()+" "+(names.length()>1?"creatures were":"creature was")+" killed by "+owner.name+"'s large nuclear bomb: ";
if(names.length()>1) send_reliable(0,"kills "+s2+s, 0);
if(xp>0) givexp(players[get_player_index_from(owner.name)],xp);
if(teampoints>0)
{
int t=is_in_team(owner.name);
if(t>-1)
{
teams[t].teamkills+=teamkills;
teams[t].points+=teampoints;
teams[t].transmit("This team just got "+teampoints+" points!");
}
}
names.resize(0);
xp=0;
teampoints=0;
teamkills=0;
s="";
s2="";
outs.resize(0);
for(uint i2=0;i2<vs.length();i2++)
{
if(owner.pvp==1 and vs[i2].map==map.name)
{
names.insert_last(""+vs[i2].type+" on "+get_zone_at(vs[i2].x,vs[i2].y,vs[i2].z,maps[get_map_index(vs[i2].map)])+"");
xp+=random(100,300)*owner.reinforcement;
teampoints+=random(100,300);
@vs[i2]=null;
vs.remove_at(i2);
i2--;
return;
}
}
if(names.length>1)
{
for(uint i=0; i<names.length(); i++)
{
if(i==(names.length-1)) s+="and "+names[i]+".";
else s+=names[i]+", ";
}
}
else
for(uint i=0; i<names.length(); i++)
{
s=names[i]+" ";
}
s2=" "+names.length()+" "+(names.length()>1?"cars were":"car was")+" destroyed by "+owner.name+"'s large nuclear bomb: ";
if(names.length()>1) send_reliable(0,"kills "+s2+s, 0);
if(xp>0) givexp(players[get_player_index_from(owner.name)],xp);
if(teampoints>0)
{
int t=is_in_team(owner.name);
if(t>-1)
{
teams[t].points+=teampoints;
teams[t].transmit("This team just got "+teampoints+" points!");
}
}
names.resize(0);
xp=0;
teampoints=0;
s="";
s2="";
outs.resize(0);
for(uint i2=0;i2<mos.length();i2++)
{
if(owner.pvp==1 and mos[i2].map==map.name)
{
names.insert_last(""+mos[i2].type+" on "+get_zone_at(mos[i2].x,mos[i2].y,mos[i2].z,maps[get_map_index(mos[i2].map)])+"");
xp+=random(100,300)*owner.reinforcement;
teampoints+=random(100,300);
@mos[i2]=null;
mos.remove_at(i2);
i2--;
return;
}
}
if(names.length>1)
{
for(uint i=0; i<names.length(); i++)
{
if(i==(names.length-1)) s+="and "+names[i]+".";
else s+=names[i]+", ";
}
}
else
for(uint i=0; i<names.length(); i++)
{
s=names[i]+" ";
}
s2=" "+names.length()+" "+(names.length()>1?"motorcycles were":"motorcycle was")+" destroyed by "+owner.name+"'s large nuclear bomb: ";
if(names.length()>1) send_reliable(0,"kills "+s2+s, 0);
if(xp>0) givexp(players[get_player_index_from(owner.name)],xp);
if(teampoints>0)
{
int t=is_in_team(owner.name);
if(t>-1)
{
teams[t].points+=teampoints;
teams[t].transmit("This team just got "+teampoints+" points!");
}
}
names.resize(0);
xp=0;
teampoints=0;
s="";
s2="";
outs.resize(0);
for(uint i2=0;i2<vvehicles.length();i2++)
{
if(owner.pvp==1 and vvehicles[i2].map==map.name)
{
names.insert_last(""+vvehicles[i2].type+" on "+get_zone_at(vvehicles[i2].x,vvehicles[i2].y,vvehicles[i2].z,maps[get_map_index(vvehicles[i2].map)])+"");
xp+=random(100,300)*owner.reinforcement;
teampoints+=random(100,300);
file_delete("vehicles/"+vvehicles[i2].id+".vehicle");
@vvehicles[i2]=null;
vvehicles.remove_at(i2);
i2--;
return;
}
}
if(names.length>1)
{
for(uint i=0; i<names.length(); i++)
{
if(i==(names.length-1)) s+="and "+names[i]+".";
else s+=names[i]+", ";
}
}
else
for(uint i=0; i<names.length(); i++)
{
s=names[i]+" ";
}
s2=" "+names.length()+" "+(names.length()>1?"cars were":"car was")+" destroyed by "+owner.name+"'s large nuclear bomb: ";
if(names.length()>1) send_reliable(0,"kills "+s2+s, 0);
if(xp>0) givexp(players[get_player_index_from(owner.name)],xp);
if(teampoints>0)
{
int t=is_in_team(owner.name);
if(t>-1)
{
teams[t].points+=teampoints;
teams[t].transmit("This team just got "+teampoints+" points!");
}
}
names.resize(0);
xp=0;
teampoints=0;
s="";
s2="";
outs.resize(0);
for(uint i2=0;i2<mmotors.length();i2++)
{
if(mmotors[i2].map==map.name)
{
names.insert_last(""+mmotors[i2].type+" on "+get_zone_at(mmotors[i2].x,mmotors[i2].y,mmotors[i2].z,maps[get_map_index(mmotors[i2].map)])+"");
xp+=random(100,300)*owner.reinforcement;
teampoints+=random(100,300);
file_delete("vehicles/"+mmotors[i2].id+".motor");
@mmotors[i2]=null;
mmotors.remove_at(i2);
i2--;
return;
}
}
if(names.length>1)
{
for(uint i=0; i<names.length(); i++)
{
if(i==(names.length-1)) s+="and "+names[i]+".";
else s+=names[i]+", ";
}
}
else
for(uint i=0; i<names.length(); i++)
{
s=names[i]+" ";
}
s2=" "+names.length()+" "+(names.length()>1?"motorcycles were":"motorcycle was")+" destroyed by "+owner.name+"'s large nuclear bomb: ";
if(names.length()>1) send_reliable(0,"kills "+s2+s, 0);
if(xp>0) givexp(players[get_player_index_from(owner.name)],xp);
if(teampoints>0)
{
int t=is_in_team(owner.name);
if(t>-1)
{
teams[t].points+=teampoints;
teams[t].transmit("This team just got "+teampoints+" points!");
}
}
names.resize(0);
xp=0;
teampoints=0;
s="";
s2="";
outs.resize(0);
for(uint i2=0;i2<houses.length();i2++)
{
if(owner.pvp==1 and houses[i2].map==map.name)
{
houses[i2].health-=random(10000,100000);
houses[i2].hitby=owner.name+"'s large nuclear bomb";
}
}
for(uint i2=0;i2<beehives.length();i2++)
{
if(owner.pvp==1 and beehives[i2].map==map.name)
{
beehives[i2].health-=random(10000,100000);
beehives[i2].hitby=owner.name+"'s large nuclear bomb";
}
}
for(uint i2=0;i2<playerstores.length();i2++)
{
if(owner.pvp==1 and playerstores[i2].map==map.name)
{
playerstores[i2].health-=random(10000,100000);
playerstores[i2].hitby=owner.name+"'s large nuclear bomb";
}
}
for(uint i2=0;i2<lockers.length();i2++)
{
if(owner.pvp==1 and lockers[i2].map==map.name)
{
lockers[i2].health-=random(10000,100000);
lockers[i2].hitby=owner.name+"'s large nuclear bomb";
}
}
for(uint i2=0;i2<fridges.length();i2++)
{
if(owner.pvp==1 and fridges[i2].map==map.name)
{
fridges[i2].health-=random(10000,100000);
fridges[i2].hitby=owner.name+"'s large nuclear bomb";
}
}
for(uint i2=0;i2<microwaves.length();i2++)
{
if(owner.pvp==1 and microwaves[i2].map==map.name)
{
microwaves[i2].health-=random(10000,100000);
microwaves[i2].hitby=owner.name+"'s large nuclear bomb";
}
}
for (uint i2=0; i2<air_conditioners.length(); i2++)
{
if (owner.pvp==1 and air_conditioners[i2].map==map.name and get_3d_distance(x,y,z,air_conditioners[i2].x,air_conditioners[i2].y,air_conditioners[i2].z)<=20)
{
air_conditioners[i2].health-=random(10000,100000);
air_conditioners[i2].hitby=owner.name+"'s large nuclear bomb";
}
}
for (uint i2=0; i2<steams.length(); i2++)
{
if (owner.pvp==1 and steams[i2].map==map.name and get_3d_distance(x,y,z,steams[i2].x,steams[i2].y,steams[i2].z)<=20)
{
steams[i2].health-=random(10000,100000);
steams[i2].hitby=owner.name+"'s large nuclear bomb";
}
}
for (uint i2=0; i2<fans.length(); i2++)
{
if (owner.pvp==1 and fans[i2].map==map.name and get_3d_distance(x,y,z,fans[i2].x,fans[i2].y,fans[i2].z)<=20)
{
fans[i2].health-=random(10000,100000);
fans[i2].hitby=owner.name+"'s large nuclear bomb";
}
}
for(uint i2=0;i2<turrets.length();i2++)
{
if(owner.pvp==1 and turrets[i2].map.name==map.name)
{
names.insert_last(""+turrets[i2].owner.name+"'s turret "+turrets[i2].id+" on "+get_zone_at(turrets[i2].x,turrets[i2].y,turrets[i2].z,maps[get_map_index(turrets[i2].map.name)])+"");
xp+=random(100,300)*owner.reinforcement;
teampoints+=random(100,300);
@turrets[i2]=null;
turrets.remove_at(i2);
i2--;
return;
}
}if(names.length>1)
{
for(uint i=0; i<names.length(); i++)
{
if(i==(names.length-1)) s+="and "+names[i]+".";
else s+=names[i]+", ";
}
}
else
for(uint i=0; i<names.length(); i++)
{
s=names[i]+" ";
}
s2=" "+names.length()+" "+(names.length()>1?"turrets were":"turret was")+" destroyed by "+owner.name+"'s large nuclear bomb: ";
if(names.length()>1) send_reliable(0,"kills "+s2+s, 0);
if(xp>0) givexp(players[get_player_index_from(owner.name)],xp);
if(teampoints>0)
{
int t=is_in_team(owner.name);
if(t>-1)
{
teams[t].points+=teampoints;
teams[t].transmit("This team just got "+teampoints+" points!");
}
}
names.resize(0);
xp=0;
teampoints=0;
s="";
s2="";
outs.resize(0);
int index=get_player_index(large_nuclear_bombs[i].owner.peer_id);
if(index > -1)
{
large_nuclear_bombs[i].owner.nuclearbombspawned=0;
}
else
{
f.open("chars/"+large_nuclear_bombs[i].owner.name+"/nbstats.usr","wb");
f.write(0);
f.close();
}
large_nuclear_bombs.remove_at(i);
return;
}
}
}
void spawn_large_nuclear_bomb(int x, int y, int z, mapdata@m, player@p)
{
large_nuclear_bomb bomb(x, y, z, m, p);
if(@bomb.map==null or @bomb.owner==null) return;
else large_nuclear_bombs.insert_last(bomb);
}
time_bomb@[] time_bombs(0);
class time_bomb
{
player@owner;
int z;
mapdata@map;
int x, y;
int seconds=40000;
int beeptime;
timer beeptimer, bombtimer;
time_bomb(int bx,int by,int bz, mapdata@m, player@p)
{
@owner=p;
x=bx;
y=by;
z=bz;
@map=m;
send_packet(6,"play timebombdrop.ogg "+x+" "+y+" "+z,x,y,z,maps[get_map_index(map.name)]);
}
void loop(int i)
{
if(@map==null or @owner==null)
{
time_bombs.remove_at(i);
return;
}
seconds=3000-bombtimer.elapsed;
beeptime=seconds/5+50;
if (beeptimer.elapsed>=beeptime)
{
beeptimer.restart();
send_packet(6,"play timebombbeep.ogg "+x+" "+y+" "+z,x,y,z,maps[get_map_index(map.name)]);
}
if (seconds<=0)
{
send_packet(6,"play timebombexplode.ogg "+x+" "+y+" "+z,x,y,z,maps[get_map_index(map.name)]);
send_dpacket(6,"distsound timebombdist "+x+" "+y+" "+z+" "+map.name,maps[get_map_index(map.name)]);
for (uint i2=0; i2<players.length(); i2++)
{
if(are_teamed(owner.name,players[i2].name) or in_vehicle(players[i2])>-1 or in_motor(players[i2])>-1 or players[i2].is_dead or is_safe(players[i2].x,players[i2].y,players[i2].z,maps[get_map_index(players[i2].map)]) or players[i2].safe or players[i2].pvp==0 or players[i2].away or players[i2].afk or players[i2].newb==1 or players[i2].looking!="") continue;
if (owner.pvp==1 and players[i2].map==map.name and get_3d_distance(x,y,z,players[i2].x,players[i2].y,players[i2].z)<=25)
{
players[i2].health-=random(2500,6500);
players[i2].hitby=owner.name+"'s time bomb";
send_packet(6,"play timebombhit.ogg "+players[i2].x+" "+players[i2].y+" "+players[i2].z,players[i2].x,players[i2].y,players[i2].z,maps[get_map_index(players[i2].map)]);
}
}
for (uint i2=0; i2<ais.length(); i2++)
{
if (ais[i2].map.name==map.name and get_3d_distance(x,y,z,ais[i2].x,ais[i2].y,ais[i2].z)<=25)
{
ais[i2].health-=random(600, 1800);
ais[i2].hitby=owner.name+"'s time bomb";
send_packet(6,"play hit"+random(1, 5),ais[i2].x,ais[i2].y,ais[i2].z,maps[get_map_index(ais[i2].map.name)]);
}
}
for(uint v=0; v<vs.length(); v++)
{
if(owner.pvp==1 and vs[v].map==map.name and get_3d_distance(x,y,z,vs[v].x,vs[v].y,vs[v].z)<=25)
vs[v].hit(random(1000,5000),owner.name+"'s time_bomb");
}
for(uint m=0; m<mos.length(); m++)
{
if(owner.pvp==1 and mos[m].map==map.name and get_3d_distance(x,y,z,mos[m].x,mos[m].y,mos[m].z)<=25)
mos[m].hit(random(1000,5000),owner.name+"'s time_bomb");
}
for(uint v=0; v<vvehicles.length(); v++)
{
if(owner.pvp==1 and vvehicles[v].map==map.name and get_3d_distance(x,y,z,vvehicles[v].x,vvehicles[v].y,vvehicles[v].z)<=25)
vvehicles[v].hit(random(1000,5000),owner.name+"'s time_bomb");
}
for(uint m=0; m<mmotors.length(); m++)
{
if(owner.pvp==1 and mmotors[m].map==map.name and get_3d_distance(x,y,z,mmotors[m].x,mmotors[m].y,mmotors[m].z)<=25)
mmotors[m].hit(random(1000,5000),owner.name+"'s time_bomb");
}
for (uint i2=0; i2<houses.length(); i2++)
{
if (owner.pvp==1 and houses[i2].map==map.name and get_3d_distance(x,y,z,houses[i2].x,houses[i2].y,houses[i2].z)<=25)
{
send_packet(6,"play base_impact_ext.ogg "+houses[i2].x+" "+houses[i2].y+" "+houses[i2].z,houses[i2].x,houses[i2].y,houses[i2].z,maps[get_map_index(houses[i2].map)]);
houses[i2].health-=random(2500,6500);
houses[i2].hitby=owner.name+"'s time bomb";
}
}
for (uint i2=0; i2<lockers.length(); i2++)
{
if (owner.pvp==1 and lockers[i2].map==map.name and get_3d_distance(x,y,z,lockers[i2].x,lockers[i2].y,lockers[i2].z)<=25)
{
send_packet(6,"play locker_hit"+random(1, 6)+".ogg "+lockers[i2].x+" "+lockers[i2].y+" "+lockers[i2].z,lockers[i2].x,lockers[i2].y,lockers[i2].z,maps[get_map_index(lockers[i2].map)]);
lockers[i2].health-=random(2500,6500);
lockers[i2].hitby=owner.name+"'s time bomb";
}
}
for (uint i2=0; i2<fridges.length(); i2++)
{
if (owner.pvp==1 and fridges[i2].map==map.name and get_3d_distance(x,y,z,fridges[i2].x,fridges[i2].y,fridges[i2].z)<=25)
{
send_packet(6,"play base_fridge_impact"+random(1, 3)+"",fridges[i2].x,fridges[i2].y,fridges[i2].z,maps[get_map_index(fridges[i2].map)]);
fridges[i2].health-=random(2500,6500);
fridges[i2].hitby=owner.name+"'s time bomb";
}
}
for (uint i2=0; i2<robots.length(); i2++)
{
if (owner.pvp==1 and robots[i2].map.name==map.name and get_3d_distance(x,y,z,robots[i2].x,robots[i2].y,robots[i2].z)<=25)
{
send_packet(6,"play locker_hit"+random(1, 6)+".ogg "+robots[i2].x+" "+robots[i2].y+" "+robots[i2].z,robots[i2].x,robots[i2].y,robots[i2].z,maps[get_map_index(robots[i2].map.name)]);
robots[i2].health-=random(2500,6500);
robots[i2].hitby=owner.name+"'s time bomb";
}
}
for (uint i2=0; i2<microwaves.length(); i2++)
{
if (owner.pvp==1 and microwaves[i2].map==map.name and get_3d_distance(x,y,z,microwaves[i2].x,microwaves[i2].y,microwaves[i2].z)<=25)
{
send_packet(6,"play locker_hit"+random(1, 6)+".ogg "+microwaves[i2].x+" "+microwaves[i2].y+" "+microwaves[i2].z,microwaves[i2].x,microwaves[i2].y,microwaves[i2].z,maps[get_map_index(microwaves[i2].map)]);
microwaves[i2].health-=random(2500,6500);
microwaves[i2].hitby=owner.name+"'s time bomb";
}
}
for (uint i2=0; i2<air_conditioners.length(); i2++)
{
if (owner.pvp==1 and air_conditioners[i2].map==map.name and get_3d_distance(x,y,z,air_conditioners[i2].x,air_conditioners[i2].y,air_conditioners[i2].z)<=25)
{
send_packet(6,"play locker_hit"+random(1, 6)+".ogg "+air_conditioners[i2].x+" "+air_conditioners[i2].y+" "+air_conditioners[i2].z,air_conditioners[i2].x,air_conditioners[i2].y,air_conditioners[i2].z,maps[get_map_index(air_conditioners[i2].map)]);
air_conditioners[i2].health-=random(2500,6500);
air_conditioners[i2].hitby=owner.name+"'s time bomb";
}
}
for (uint i2=0; i2<steams.length(); i2++)
{
if (owner.pvp==1 and steams[i2].map==map.name and get_3d_distance(x,y,z,steams[i2].x,steams[i2].y,steams[i2].z)<=25)
{
send_packet(6,"play locker_hit"+random(1, 6)+".ogg "+steams[i2].x+" "+steams[i2].y+" "+steams[i2].z,steams[i2].x,steams[i2].y,steams[i2].z,maps[get_map_index(steams[i2].map)]);
steams[i2].health-=random(2500,6500);
steams[i2].hitby=owner.name+"'s time bomb";
}
}
for (uint i2=0; i2<fans.length(); i2++)
{
if (owner.pvp==1 and fans[i2].map==map.name and get_3d_distance(x,y,z,fans[i2].x,fans[i2].y,fans[i2].z)<=25)
{
send_packet(6,"play locker_hit"+random(1, 6)+".ogg "+fans[i2].x+" "+fans[i2].y+" "+fans[i2].z,fans[i2].x,fans[i2].y,fans[i2].z,maps[get_map_index(fans[i2].map)]);
fans[i2].health-=random(2500,6500);
fans[i2].hitby=owner.name+"'s time bomb";
}
}
for (uint i2=0; i2<playerstores.length(); i2++)
{
if (owner.pvp==1 and playerstores[i2].map==map.name and get_3d_distance(x,y,z,playerstores[i2].x,playerstores[i2].y,playerstores[i2].z)<=25)
{
send_packet(6,"play base_impact_ext.ogg "+playerstores[i2].x+" "+playerstores[i2].y+" "+playerstores[i2].z,playerstores[i2].x,playerstores[i2].y,playerstores[i2].z,maps[get_map_index(playerstores[i2].map)]);
playerstores[i2].health-=random(2500,6500);
playerstores[i2].hitby=owner.name+"'s time bomb";
}
}
for (uint i2=0; i2<beehives.length(); i2++)
{
if (owner.pvp==1 and beehives[i2].map==map.name and get_3d_distance(x,y,z,beehives[i2].x,beehives[i2].y,beehives[i2].z)<=25)
{
send_packet(6,"play base_impact_ext.ogg "+beehives[i2].x+" "+beehives[i2].y+" "+beehives[i2].z,beehives[i2].x,beehives[i2].y,beehives[i2].z,maps[get_map_index(beehives[i2].map)]);
beehives[i2].health-=random(2500,6500);
beehives[i2].hitby=owner.name+"'s time bomb";
}
}
time_bombs.remove_at(i);
return;
}
}
}
void spawn_time_bomb(int x,int y, int z, mapdata@m, player@p)
{
time_bomb bomb(x,y,z,m,p);
if(@bomb.map==null or @bomb.owner==null) return;
else time_bombs.insert_last(bomb);
}
void destroy_all_time_bombs()
{
time_bombs.resize(0);
}
