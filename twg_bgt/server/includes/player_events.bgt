void player_event(player@p, string event)
{
string[] parsed=string_split(event, " ", true);
if(parsed[0]=="stats" and parsed.length()>1)
{
int index2=get_player_index_from(parsed[1]);
if(index2<0)
{
send_reliable(p,"Not found",2);
send_reliable(p,"play_s playerstats_error.ogg",6);
return;
}
string statslist;
statslist="The player "+players[index2].name+" which known as "+players[index2].nickname+" has been playing daily life for a total of "+ms_to_readable_time(players[index2].playtimer.elapsed)+". Has sent "+players[index2].chats+" chats. Has "+players[index2].deaths+" deaths and "+players[index2].kills+" kills. Has a killing accuracy of "+round(percent(players[index2].kills,players[index2].kills+players[index2].deaths),0)+" percent";
if(players[index2].gender==0) statslist+=" "+players[index2].name+" is male. ";
else if(players[index2].gender==1) statslist+=" "+players[index2].name+" is female. ";
int t=is_in_team(players[index2].name);
if(t>-1)
{
statslist+=" "+players[index2].name+" is in "+teams[t].teamname+" team. ";
}
if(players[index2].age==0 or players[index2].day==0 or players[index2].month==0 or players[index2].year==0 or players[index2].country=="")
{
if(players[index2].gender==0)players[index2].gender2="hes";
else players[index2].gender2="her";
statslist+=""+players[index2].name+" didn't complete "+players[index2].gender2+" profile yet. ";
}
else
{
if(players[index2].age!=0)
{
statslist+=""+players[index2].name+" is "+players[index2].age+" years old. ";
}
if(players[index2].day!=0 and players[index2].month!=0 and players[index2].year!=0)
{
statslist+=""+players[index2].name+" is borned on "+players[index2].day+" "+players[index2].month+" "+players[index2].year+". ";
}
if(players[index2].country!="")
{
statslist+=""+players[index2].name+" is from "+players[index2].country+". ";
}
}
if(players[index2].partner!="")
{
statslist+=""+players[index2].name+" is married to "+players[index2].partner+". ";
}
if(players[index2].ex_partner!="")
{
statslist+=""+players[index2].name+" is devorced from "+players[index2].ex_partner+". ";
}
if(players[index2].status=="")
{
statslist+="status for "+players[index2].name+": no status message has been set. ";
}
else
{
statslist+="status for "+players[index2].name+": "+players[index2].status+". ";
}
send_reliable(p,"play_s playerstats.ogg",6);
send_reliable(p,statslist,2);
}
else if(parsed[0]=="status" and parsed.length>1)
{
string[] charfolders=find_directories("chars/*");
int found=charfolders.find(parsed[1]);
if(found>-1)
{
f.open("chars/"+charfolders[charfolders.find(parsed[1])]+"/status.usr","rb");
string status=f.read();
f.close();
send_reliable(p,"status for "+charfolders[found]+": "+status+"",2);
}
}
else if(parsed[0]=="setstatus" and parsed.length>1)
{
p.status=string_replace(get_event_message(),parsed[0]+" ","",true);
string[] charfolders=find_directories("chars/*");
int found=charfolders.find(p.name);
if(found>-1)
{
write_to(charfolders[found],"status.usr",p.status);
send_reliable(p,"your status message has been set to "+p.status+"",2);
}
}
/*
else if(parsed[0]=="ttschatbuffer")
{
send_packet(0,"ttschat "+p.name+" has sent a tts chat on "+get_date()+" at "+get_time()+"",p.x,p.y,p.z,maps[get_map_index(p.map)]);
}
*/
else if(parsed[0]=="setvoice" and parsed.length()>1)
{
p.voice=string_to_number(parsed[1]);
send_reliable(p,"setgender "+p.gender,0);
}
/*
else if(parsed[0]=="voicechatbuffer" and parsed.length()>1)
{
if(string_to_number(parsed[1])>1000)send_reliable(0,"voicechat "+p.name+" has sent a "+string_to_number(parsed[1])*1000+" seconds voice chat on "+get_date()+" at "+get_time()+"",0);
else if(string_to_number(parsed[1])==1000)send_reliable(0,"voicechat "+p.name+" has sent a "+string_to_number(parsed[1])*1000+" second voice chat on "+get_date()+" at "+get_time()+"",0);
else if(string_to_number(parsed[1])<1000)send_reliable(0,"voicechat "+p.name+" has sent a "+string_to_number(parsed[1])+" milliseconds voice chat on "+get_date()+" at "+get_time()+"",0);
}
*/
else if(parsed[0]=="look" and parsed.length>1)
{
if(p.looking!="")
{
send_reliable(p,"stop looking at "+p.looking+" first",2);
return;
}
if(p.prison==true)
{
send_reliable(p,"You can't do this in prison",2);
return;
}
int ind=get_player_index_from(parsed[1]);
if(ind>-1)
{
if(p.sleeping==false)
{
if(parsed[1]==p.name)
{
send_reliable(p,"you can't look at yourself",2);
}
else if(players[ind].is_trusted(p)==false and p.is_admin()==false)
{
send_reliable(p,"error: "+players[ind].name+" doesn't trust you",2);
}
else if(players[ind].looking==p.name)
{
send_reliable(p,"Error: You can't look whos already looking at you, tell him to stop looking first",2);
}
else
{
write_to(p.name,"oldx.usr",p.x);
write_to(p.name,"oldy.usr",p.y);
write_to(p.name,"oldz.usr",p.z);
write_to(p.name,"oldmap.usr",p.map);
p.looking=players[ind].name;
players[ind].looker=p.name;
p.looking_on=true;
send_reliable(p,"lookstart",0);
send_packet(6,"play toggleon.ogg "+p.x+" "+p.y+" "+p.z, p.x,p.y,p.z,maps[get_map_index(p.map)]);
send_reliable(p,"now you are looking at "+players[ind].name+"",2);
send_reliable(players[ind],""+p.name+" is now watching you",2);
}
}
else send_reliable(p,"you can't look at someone while sleeping",2);
}
else send_reliable(p,"that player could not be found",2);
}
else if(parsed[0]=="lookstop" and p.looking!="")
{
int ind=get_player_index_from(p.looking);
if(ind>-1)
{
players[ind].looker="";
send_reliable(p,"lookstop",0);
p.looking="";
int newx=string_to_number(get_char_val(p.name,"oldx"));
int newy=string_to_number(get_char_val(p.name,"oldy"));
int newz=string_to_number(get_char_val(p.name,"oldz"));
string newmap=get_char_val(p.name,"oldmap");
if(map_exists(newmap)==false)
newmap="main";
string charfolder="chars/"+p.name;
file_delete(charfolder+"/oldx.usr");
file_delete(charfolder+"/oldy.usr");
file_delete(charfolder+"/oldz.usr");
file_delete(charfolder+"/oldmap.usr");
move_player(p,newmap,newx,newy,newz);
send_packet(6,"play toggleoff.ogg "+p.x+" "+p.y+" "+p.z, p.x,p.y,p.z,maps[get_map_index(p.map)]);
send_reliable(p,"you've stopped looking at "+players[ind].name+"",2);
send_reliable(players[ind],""+p.name+" stopped watching you",2);
}
}
else if(parsed[0]=="usetelehouse" and parsed.length()>1)
{
if(parsed[1]=="back")
{
p.sendpacket("canceled", 0);
return;
}
for(uint i=0; i<houses.length(); i++)
{
if(houses[i].housemap==parsed[1])
{
if(!map_exists(houses[i].housemap))
{
send_reliable(p,"you haven't any house",2);
return;
}
send_packet(6,"play teleporter1.ogg "+p.x+" "+p.y+" "+p.z, p.x,p.y,p.z,maps[get_map_index(p.map)]);
move_player(p,houses[i].housemap,1,1,0);
p.inv_add_item("telehouse",-1);
}
}
}
else if(parsed[0]=="usewand" and parsed.length()>1)
{
if(parsed[1]=="back")
{
p.sendpacket("canceled", 0);
return;
}
else if(parsed[1]=="shield_unwealder")
{
for (uint i=0; i<players.length(); i++)
{
if(players[i].pvp==0||players[i].is_dead==true||in_vehicle(players[i])>-1||players[i].afk==true) continue;
if (players[i].name!=p.name and players[i].map==p.map and players[i].looking!=p.name and p.looking!=players[i].name and get_3d_distance(p.x, p.y, p.z,players[i].x,players[i].y,players[i].z)<=25)
{
send_packet(6,"play starhit.ogg "+players[i].x+" "+players[i].y+" "+players[i].z, players[i].x,players[i].y,players[i].z,maps[get_map_index(players[i].map)]);
send_packet(6,"play shieldunwield.ogg "+players[i].x+" "+players[i].y+" "+players[i].z, players[i].x,players[i].y,players[i].z,maps[get_map_index(players[i].map)]);
players[i].shieldshots=0;
players[i].shielded=0;
players[i].steel_shieldshots=0;
players[i].steel_shielded=0;
p.inv_add_item("mana",-35);
}
}
}
else if(parsed[1]=="life_drain")
{
for (uint i=0; i<players.length(); i++)
{
if(players[i].pvp==0||players[i].is_dead==true||in_vehicle(players[i])>-1||players[i].afk==true) continue;
if (players[i].name!=p.name and players[i].map==p.map and players[i].looking!=p.name and p.looking!=players[i].name and get_3d_distance(p.x, p.y, p.z,players[i].x,players[i].y,players[i].z)<=25)
{
if(players[i].health>5000)
{
send_reliable(p,"error: "+players[i].name+"'s health is less than the half",2);
return;
}
send_packet(6,"play burn_start.ogg "+players[i].x+" "+players[i].y+" "+players[i].z, players[i].x,players[i].y,players[i].z,maps[get_map_index(players[i].map)]);
send_packet(6,"play health_healer.ogg "+players[i].x+" "+players[i].y+" "+players[i].z, players[i].x,players[i].y,players[i].z,maps[get_map_index(players[i].map)]);
players[i].health=5000;
p.inv_add_item("mana",-55);
}
}
}
else if(parsed[1]=="fore_to_death")
{
send_packet(6,"play burn_start.ogg "+p.x+" "+p.y+" "+p.z, p.x,p.y,p.z,maps[get_map_index(p.map)]);
send_packet(6,"play health_healer.ogg "+p.x+" "+p.y+" "+p.z, p.x,p.y,p.z,maps[get_map_index(p.map)]);
p.inv_add_item("mana",-5);
p.health=0;
}

}
else if(parsed[0]=="doorgive" and parsed.length()>1)
{
string p2=string_replace(parsed[2],"-","",true);
p.inv_add_item(parsed[1],string_to_number(p2));
if(parsed[1]=="coins")
{
servermoney-=string_to_number(parsed[2]);
}
}
else if(parsed[0]=="doortake" and parsed.length()>1)
{
string p2=string_replace(parsed[2],"-","",true);
p.inv_add_item(parsed[1],-string_to_number(p2));
if(parsed[1]=="coins")
{
servermoney+=string_to_number(parsed[2]);
}
}
else if(parsed[0]=="travelpointgive" and parsed.length()>1)
{
string p2=string_replace(parsed[2],"-","",true);
p.inv_add_item(parsed[1],string_to_number(p2));
if(parsed[1]=="coins")
{
servermoney-=string_to_number(parsed[2]);
}
}
else if(parsed[0]=="travelpointtake" and parsed.length()>1)
{
string p2=string_replace(parsed[2],"-","",true);
p.inv_add_item(parsed[1],-string_to_number(p2));
if(parsed[1]=="coins")
{
servermoney+=string_to_number(parsed[2]);
}
}
else if(parsed[0]=="int" and parsed.length()>2)
{
iitem(p, parsed[1], parsed[2]);
}
else if(parsed[0]=="safezonemenu" and parsed.length()>1)
{
if(parsed[1]=="back")
{
p.sendpacket("canceled", 0);
return;
}
if(parsed[1]=="publicmaps")
{
if(p.prison==false and p.map=="safezone")
{
file f;
f.open("pbmaps.svr","rb");
string[] lines=string_split(f.read(),"\r\n",false);
f.close();
if(lines.length()<1)
{
send_reliable(p,"error",2);
return;
}
server_menu2 m;
m.intro="public maps menu. Press up and down to move between maps and press enter to go to that map";
m.initial_packet="publicmapgo";
for(uint i=0; i<lines.length(); i++)
{
int mi=get_map_index(lines[i]);
if((mi>-1))
{
string s="";
string s2;
if(maps[mi].owners.length>1)
{
for(uint i=0; i<maps[mi].owners.length(); i++)
{
if(i==(maps[mi].owners.length-1)) s+="and "+maps[mi].owners[i]+".";
else s+=maps[mi].owners[i]+", ";
}
}
else
for(uint i=0; i<maps[mi].owners.length(); i++){
s=maps[mi].owners[i]+".";}
if(maps[mi].owners.length()>1) s2=" "+maps[mi].owners.length()+" owners: ";
else s2=" "+maps[mi].owners.length()+" owner: ";
m.add(maps[mi].name+". "+s2+" "+s+" "+(maps[mi].litem==1?"You will":"You won't")+" loos your items when you die in this map. "+(maps[mi].minlevel>0?"Level range: level "+maps[mi].minlevel+" untill "+maps[mi].maxlevel+".":" ")+" "+(maps[mi].minreinforcement>0?"reinforcement range: reinforcement "+maps[mi].minreinforcement+" untill "+maps[mi].maxreinforcement+".":" ")+" "+(maps[mi].safe_card==1?"You will":"You won't")+" be respawned in safe zone map after losing a safe card in this map. "+(maps[mi].description!=""?""+maps[mi].description+"":"No description available for this map")+"",lines[i]);
}
}
m.send(p.peer_id);
}
}
else if(parsed[1]=="challengemaps")
{
if(p.prison==false and p.map=="safezone")
{
file f;
f.open("chmaps.svr","rb");
string[] lines=string_split(f.read(),"\r\n",false);
f.close();
if(lines.length()<1)
{
send_reliable(p,"error",2);
return;
}
server_menu2 m;
m.intro="challenge maps menu. Press up and down to move between maps and press enter to go to that map";
m.initial_packet="challengemapgo";
for(uint i=0; i<lines.length(); i++)
{
int mi=get_map_index(lines[i]);
if((mi>-1))
{
string s="";
string s2;
if(maps[mi].owners.length>1)
{
for(uint i=0; i<maps[mi].owners.length(); i++)
{
if(i==(maps[mi].owners.length-1)) s+="and "+maps[mi].owners[i]+".";
else s+=maps[mi].owners[i]+", ";
}
}
else
for(uint i=0; i<maps[mi].owners.length(); i++){
s=maps[mi].owners[i]+".";}
if(maps[mi].owners.length()>1) s2=" "+maps[mi].owners.length()+" owners: ";
else s2=" "+maps[mi].owners.length()+" owner: ";
m.add(maps[mi].name+". Reward: "+maps[mi].finishamount+" "+maps[mi].finishitem+". "+s2+" "+s+" "+(maps[mi].litem==1?"You will":"You won't")+" loos your items when you die in this map. "+(maps[mi].minlevel>0?"Level range: level "+maps[mi].minlevel+" untill "+maps[mi].maxlevel+".":" ")+" "+(maps[mi].minreinforcement>0?"reinforcement range: reinforcement "+maps[mi].minreinforcement+" untill "+maps[mi].maxreinforcement+".":" ")+" "+(maps[mi].safe_card==1?"You will":"You won't")+" be respawned in safe zone map after losing a safe card in this map. "+(maps[mi].description!=""?""+maps[mi].description+"":"No description available for this map")+"",lines[i]);
}
}
m.send(p.peer_id);
}
}
else if(parsed[1]=="yourmaps")
{
if(p.prison==false and p.map=="safezone")
{
string[] a=string_split(file_get_contents("chars/"+p.name+"/maps.usr"),"\r\n",false);
if(a.length()<1)
{
send_reliable(p,"error",2);
return;
}
server_menu m;
m.intro="your maps menu. Press up and down to move between maps and press enter to go to that map";
m.initial_packet="mapgo";
for(uint i=0;i<a.length();i++)
{
if(string_contains(a[i],"house_of_",1)==-1 and string_contains(a[i],"beehive_of_",1)==-1 and string_contains(a[i],"store_of_",1)==-1)
{
int mi=get_map_index(a[i]);
if((mi>-1))
{
m.add(maps[mi].name+". "+s2+" "+s+" "+(maps[mi].litem==1?"You will":"You won't")+" loos your items when you die in this map. "+(maps[mi].safe_card==1?"You will":"You won't")+" be respawned in safe zone map after losing a safe card in this map. "+(maps[mi].description!=""?""+maps[mi].description+"":"No description available for this map")+"",a[i]);
}
}
}
m.send(p.peer_id);
}
}
else if(parsed[1]=="newmap")
{
send_reliable(p,"buildnewmap",0);
}
else if(parsed[1]=="arena")
{
server_menu m;
m.intro="arena options menu";
m.initial_packet="arenamenu";
m.add("create a new arena","createnewarena");
m.add("join to an existing arena","joinarena");
m.send(p.peer_id);
}
}
else if(parsed[0]=="arenamenu" and parsed.length()>1)
{
if(parsed[1]=="back")
{
p.sendpacket("canceled", 0);
return;
}
if(parsed[1]=="createnewarena")
{
server_menu m;
m.intro="select your arena type";
m.initial_packet="arenatype";
m.add("combo arena","combo");
m.add("melee arena","melee");
m.add("weaponry arena","weaponry");
m.add("explosive arena","explosive");
m.add("mixed arena","mixed");
m.send(p.peer_id);
}
else if(parsed[1]=="joinarena")
{
server_menu m;
m.intro="choose an arena";
m.initial_packet="choosearena";
for(uint i=0; i<arenas.length(); i++)
{
if(arenas[i].started==0 and arenas[i].length>1)
{
int amath=arenas[i].length-arenas[i].joined;
m.add(""+arenas[i].owner+"'s "+arenas[i].type+" arena with a total of "+arenas[i].length+" participators. "+amath+" participators stil left. Fee: "+arenas[i].neededfee+" "+arenas[i].item+". This arena has a total of "+arenas[i].fee+" "+arenas[i].item+" to give to it's winner",arenas[i].id);
}
if(arenas[i].length==0)
{
m.add(""+arenas[i].owner+"'s continuous "+arenas[i].type+" arena",arenas[i].id);
}
}
m.send(p.peer_id);
}
}
else if(parsed[0]=="arenatype" and parsed.length()>1)
{
if(parsed[1]=="back")
{
p.sendpacket("canceled", 0);
return;
}
send_serverbox(p.peer_id,2,-1,1,-1,"arenalength/"+parsed[1],"how many people can join? enter 0 to be continuous");
}
else if(string_left(parsed[0],12)=="arenalength/" and parsed.length>1)
{
if(parsed[1]=="[cncel]") return;
double arenalength=string_to_number(parsed[1]);
parsed=string_split(parsed[0],"/",false);
if(arenalength<2 and arenalength!=0)
{
send_reliable(p,"participaters must be more than one person",2);
return;
}
if(arenalength>players.length() and arenalength!=0)
{
send_reliable(p,"participaters must be less than thee connected players",2);
return;
}
send_serverbox(p.peer_id,0,-1,-1,-1,"arenaitem/"+arenalength+"/"+parsed[1],"enter item name. Type noitem if this arena is continuous");
}
else if(string_left(parsed[0],10)=="arenaitem/" and parsed.length>1)
{
if(parsed[1]=="[cncel]") return;
string arenaitem=parsed[1];
parsed=string_split(parsed[0],"/",false);
if(arenaitem=="")
{
send_reliable(p,"unknown item name",2);
return;
}
send_serverbox(p.peer_id,2,-1,1,-1,"arenafee/"+parsed[1]+"/"+parsed[2]+"/"+arenaitem,"enter fee. Type 0 if this arena is continuous");
}
else if(string_left(parsed[0],9)=="arenafee/" and parsed.length>1)
{
if(parsed[1]=="[cncel]") return;
double arenafee=string_to_number(parsed[1]);
parsed=string_split(parsed[0],"/",false);
double arenalength=string_to_number(parsed[1]);
if(arenafee<1 and arenalength>1)
{
send_reliable(p,"not less than a coin",2);
return;
}
if(p.inv_item_number(parsed[3])<arenafee)
{
send_reliable(p,"you haven't "+arenafee+" "+parsed[3]+" to continue",2);
return;
}
string mapname;
if(arenalength==0) mapname=""+p.name+"'s_continuous_"+parsed[2]+"_arena";
else if(arenalength>1) mapname=""+p.name+"'s_"+parsed[2]+"_arena";
int maxx=random(20,200);
int maxy=random(20,200);
int length=string_to_number(parsed[1]);
file f;
f.open("maps/"+mapname+".map","wb");
f.write("mapname:"+mapname+"\r\nminx:0\r\nmaxx:"+maxx+"\r\nminy:0\r\nmaxy:"+maxy+"\r\nminz:0\r\nmaxz:10\r\ntile:0:"+maxx+":0:"+maxy+":0:0:"+random(0,-5)+":"+random(80,120)+":grass"+random(2,10)+"\r\nlitem:0\r\nsafe_card:0\r\nstarting_point:0:"+maxx+":0:"+maxy+":0:0\r\ndeathpoint:0:"+maxx+":0:"+maxy+":0:0\r\nsrc:0:"+maxx+":0:"+maxy+":0:10:0:100:birds"+random(2,103)+".ogg\r\nzone:0:"+maxx+":0:"+maxy+":0:10:"+mapname+"\r\nowner:mahdi\r\npvp:0:"+maxx+":0:"+maxy+":0:10:1");
f.close();
init_mapsystem();
string newid=randomstring(6);
if(arenalength==0) create_arena(p.name,mapname,parsed[2],0,1,arenafee,"",newid);
else create_arena(p.name,mapname,parsed[2],arenalength,0,arenafee,parsed[3],newid);
for(uint i=0; i<arenas.length(); i++)
{
if(arenas[i].id==newid)
{
int mi=get_map_index(arenas[i].map);
if((mi>-1))
{
if(arenalength==0)
{
send_reliable(0, "play_s notify_news2.ogg",6);
send_reliable(0,"arena "+p.name+" has created a continuous "+arenas[i].type+" Arena. You can join to it by going to the safe zone map and finding the safe zone menu",0);
send_reliable(p,"you can type /suicide to go back",2);
}
else if(arenalength>0)
{
send_reliable(0, "play_s notify_news2.ogg",6);
send_reliable(0,"arena "+p.name+" has created a "+arenas[i].type+" Arena with a total of "+arenas[i].length+" participators. Fee: "+arenas[i].neededfee+" "+parsed[3]+". You can join to it by going to the safe zone map and finding the safe zone menu",0);
send_reliable(p,"you can type /suicide to go back",2);
}
p.inv_add_item(parsed[3],-arenafee);
arenas[i].fee+=arenafee;
write_to(p.name,"oldx.usr",p.x);
write_to(p.name,"oldy.usr",p.y);
write_to(p.name,"oldz.usr",p.z);
write_to(p.name,"oldmap.usr",p.map);
write_to(p.name,"oldinv.usr",p.get_inv());
p.inv.delete_all();
send_reliable(p,"invdrop",0);
move_player(p,arenas[i].map,random(maps[mi].spminx,maps[mi].spmaxx),random(maps[mi].spminy,maps[mi].spmaxy),random(maps[mi].spminz,maps[mi].spmaxz),true);
f.open("chars/"+p.name+"/inv.usr","rb");
string invtext=f.read();
f.close();
f.open("inv_backups/"+p.name+" "+DATE_WEEKDAY_NAME+", "+DATE_MONTH_NAME+"-"+DATE_DAY+"-"+DATE_YEAR+", "+TIME_HOUR+" "+TIME_MINUTE+" "+TIME_SECOND+".usr","wb");
f.write(invtext);
f.close();
if(arenas[i].length==0)
{
if(maps[mi].pvp==1 and maps[mi].pvpminx<=p.x and maps[mi].pvpmaxx>=p.x and maps[mi].pvpminy<=p.y and maps[mi].pvpmaxy>=p.y and maps[mi].pvpminz<=p.z and maps[mi].pvpmaxz>=p.z)
{
if(p.pvp!=1)
{
p.pvp=1;
p.pvpd=1;
}
}
}
if(arenas[i].length>1 and p.pvp==1)
{
p.pvp=0;
p.pvpd=3;
}
arenas[i].joined++;
if(parsed[2]=="combo")
{
p.inv.delete_all();
}
else if(parsed[2]=="melee")
{
p.inv_add_item("blake_sword",1);
p.inv_add_item("d23machete",1);
p.inv_add_item("dagger",1);
p.inv_add_item("hammer",1);
p.inv_add_item("hook",1);
p.inv_add_item("iron_shovel",1);
p.inv_add_item("axe",1);
p.inv_add_item("axe2",1);
p.inv_add_item("knife",1);
p.inv_add_item("long_knife",1);
p.inv_add_item("machete",1);
p.inv_add_item("small_dagger",1);
p.inv_add_item("spear",1);
p.inv_add_item("sword",1);
p.inv_add_item("long_sword",1);
p.inv_add_item("short_sword",1);
p.inv_add_item("wip",1);
}
else if(parsed[2]=="weaponry")
{
p.inv_add_item("blake_sword",1);
p.inv_add_item("d23machete",1);
p.inv_add_item("dagger",1);
p.inv_add_item("hammer",1);
p.inv_add_item("hook",1);
p.inv_add_item("iron_shovel",1);
p.inv_add_item("axe",1);
p.inv_add_item("axe2",1);
p.inv_add_item("knife",1);
p.inv_add_item("long_knife",1);
p.inv_add_item("machete",1);
p.inv_add_item("small_dagger",1);
p.inv_add_item("spear",1);
p.inv_add_item("sword",1);
p.inv_add_item("long_sword",1);
p.inv_add_item("short_sword",1);
p.inv_add_item("wip",1);
p.inv_add_item("a90sniper_rifle",1);
p.inv_add_item("ak47assault_rifle",1);
p.inv_add_item("ak48",1);
p.inv_add_item("arrow_gun",1);
p.inv_add_item("bow",1);
p.inv_add_item("colt_m9",1);
p.inv_add_item("colt_m19",1);
p.inv_add_item("e9pistol",1);
p.inv_add_item("e20shotgun",1);
p.inv_add_item("e235shotgun",1);
p.inv_add_item("mpt_special_shotgun",1);
p.inv_add_item("mb3shotgun",1);
p.inv_add_item("mb5shotgun",1);
p.inv_add_item("mp5machinegun",1);
p.inv_add_item("famas_g2",1);
p.inv_add_item("k222rifle",1);
p.inv_add_item("long_bow",1);
p.inv_add_item("p3hunting_shotgun",1);
p.inv_add_item("taser",1);
p.inv_add_item("tiny_mg",1);
p.inv_add_item("ar15machinegun",1);
p.inv_add_item("barett_m1500sniper_rifle",1);
p.inv_add_item("blz5machinegun",1);
p.inv_add_item("browning_m2heavy_machinegun",1);
p.inv_add_item("chainsaw",1);
p.inv_add_item("crossbow",1);
p.inv_add_item("fn2000pistol",1);
p.inv_add_item("fnm_pistol",1);
p.inv_add_item("g36pistol",1);
p.inv_add_item("gouse_pistol",1);
p.inv_add_item("hk_machinegun",1);
p.inv_add_item("lr12pistol",1);
p.inv_add_item("m9pistol",1);
p.inv_add_item("m10machinegun",1);
p.inv_add_item("m16machinegun",1);
p.inv_add_item("m125assault_rifle",1);
p.inv_add_item("m152minigun",1);
p.inv_add_item("m155minigun",1);
p.inv_add_item("m560sniper_rifle",1);
p.inv_add_item("mg4machinegun",1);
p.inv_add_item("mj420machinegun",1);
p.inv_add_item("mk_long_machinegun",1);
p.inv_add_item("mk52assault_rifle",1);
p.inv_add_item("mk215machinegun",1);
p.inv_add_item("mkv43machinegun",1);
p.inv_add_item("ml7rifle",1);
p.inv_add_item("ml15rifle",1);
p.inv_add_item("mlk290rifle",1);
p.inv_add_item("mlr_assault_rifle",1);
p.inv_add_item("mp12machinegun",1);
p.inv_add_item("msb530shotgun",1);
p.inv_add_item("pcs_handgun",1);
p.inv_add_item("rpg_launcher",1);
p.inv_add_item("rpg7",1);
p.inv_add_item("rocket_launcher",1);
p.inv_add_item("nak_nk1000_decimater",1);
p.inv_add_item("ruga22revolver",1);
p.inv_add_item("s55assault_rifle",1);
p.inv_add_item("s110assault_rifle",1);
p.inv_add_item("sp5shotgun",1);
p.inv_add_item("sp150shotgun",1);
p.inv_add_item("stp106_long_barreled_pistol",1);
p.inv_add_item("str301machinegun",1);
p.inv_add_item("m90machinegun",1);
p.inv_add_item("qt_machinegun",1);
p.inv_add_item("pst500shotgun",1);
p.inv_add_item("sfx12machinegun",1);
p.inv_add_item("mb93machinegun",1);
p.inv_add_item("stp15rifle",1);
p.inv_add_item("sp3heavy_machinegun",1);
p.inv_add_item("ak9automatic_machinegun",1);
p.inv_add_item("m234minigun",1);
p.inv_add_item("missile_launcher",1);
p.inv_add_item("m28mini_machinegun",1);
p.inv_add_item("b96machinegun",1);
p.inv_add_item("kalashnikov_rifle",1);
p.inv_add_item("ump45machinegun",1);
p.inv_add_item("tac50rifle",1);
p.inv_add_item("uzi_machinegun",1);
p.inv_add_item("blue_assault_rifle",1);
p.inv_add_item("blue_bolt_action_sniper",1);
p.inv_add_item("blue_burst_assault_rifle",1);
p.inv_add_item("blue_heavy_assault_rifle",1);
p.inv_add_item("blue_hunting_rifle",1);
p.inv_add_item("blue_infintry_rifle",1);
p.inv_add_item("blue_tacticle_shotgun",1);
p.inv_add_item("drum_shotgun",1);
p.inv_add_item("gold_burst_assault_rifle",1);
p.inv_add_item("gold_drum_gun",1);
p.inv_add_item("gold_heavy_assault_rifle",1);
p.inv_add_item("gold_scar",1);
p.inv_add_item("gold_tacticle_shotgun",1);
p.inv_add_item("heavy_sniper",1);
p.inv_add_item("5.56mm_ammo",10000);
p.inv_add_item("7.62mm_ammo",10000);
p.inv_add_item("9mm_ammo",10000);
p.inv_add_item("12.7mm_ammo",10000);
p.inv_add_item("arrow",10000);
p.inv_add_item("battery",10000);
p.inv_add_item("missile",10000);
p.inv_add_item("rocket",10000);
p.inv_add_item("rpg",10000);
p.inv_add_item("shotgun_shell",10000);
}
else if(parsed[2]=="explosive")
{
p.inv_add_item("time_bomb",1000);
p.inv_add_item("grenade",1000);
p.inv_add_item("turret",1000);
p.inv_add_item("turret_cartridge",1000);
p.inv_add_item("turret_battery",1000);
p.inv_add_item("mine",1000);
p.inv_add_item("gas_canister",1000);
p.inv_add_item("censor_bomb",1000);
p.inv_add_item("snare",1000);
p.inv_add_item("energogenic_canister",1000);
p.inv_add_item("energy_reducing_canister",1000);
p.inv_add_item("thirsting_canister",1000);
p.inv_add_item("starvogenic_canister",1000);
p.inv_add_item("pathogenic_canister",1000);
p.inv_add_item("experience_canister",1000);
}
else if(parsed[2]=="mixed")
{
p.inv_add_item("blake_sword",1);
p.inv_add_item("d23machete",1);
p.inv_add_item("dagger",1);
p.inv_add_item("hammer",1);
p.inv_add_item("hook",1);
p.inv_add_item("iron_shovel",1);
p.inv_add_item("axe",1);
p.inv_add_item("axe2",1);
p.inv_add_item("knife",1);
p.inv_add_item("long_knife",1);
p.inv_add_item("machete",1);
p.inv_add_item("small_dagger",1);
p.inv_add_item("spear",1);
p.inv_add_item("sword",1);
p.inv_add_item("long_sword",1);
p.inv_add_item("short_sword",1);
p.inv_add_item("wip",1);
p.inv_add_item("a90sniper_rifle",1);
p.inv_add_item("ak47assault_rifle",1);
p.inv_add_item("ak48",1);
p.inv_add_item("arrow_gun",1);
p.inv_add_item("bow",1);
p.inv_add_item("colt_m9",1);
p.inv_add_item("colt_m19",1);
p.inv_add_item("e9pistol",1);
p.inv_add_item("e20shotgun",1);
p.inv_add_item("e235shotgun",1);
p.inv_add_item("mpt_special_shotgun",1);
p.inv_add_item("mb3shotgun",1);
p.inv_add_item("mb5shotgun",1);
p.inv_add_item("mp5machinegun",1);
p.inv_add_item("famas_g2",1);
p.inv_add_item("k222rifle",1);
p.inv_add_item("long_bow",1);
p.inv_add_item("p3hunting_shotgun",1);
p.inv_add_item("taser",1);
p.inv_add_item("tiny_mg",1);
p.inv_add_item("ar15machinegun",1);
p.inv_add_item("barett_m1500sniper_rifle",1);
p.inv_add_item("blz5machinegun",1);
p.inv_add_item("browning_m2heavy_machinegun",1);
p.inv_add_item("chainsaw",1);
p.inv_add_item("crossbow",1);
p.inv_add_item("fn2000pistol",1);
p.inv_add_item("fnm_pistol",1);
p.inv_add_item("g36pistol",1);
p.inv_add_item("gouse_pistol",1);
p.inv_add_item("hk_machinegun",1);
p.inv_add_item("lr12pistol",1);
p.inv_add_item("m9pistol",1);
p.inv_add_item("m10machinegun",1);
p.inv_add_item("m16machinegun",1);
p.inv_add_item("m125assault_rifle",1);
p.inv_add_item("m152minigun",1);
p.inv_add_item("m155minigun",1);
p.inv_add_item("m560sniper_rifle",1);
p.inv_add_item("mg4machinegun",1);
p.inv_add_item("mj420machinegun",1);
p.inv_add_item("mk_long_machinegun",1);
p.inv_add_item("mk52assault_rifle",1);
p.inv_add_item("mk215machinegun",1);
p.inv_add_item("mkv43machinegun",1);
p.inv_add_item("ml7rifle",1);
p.inv_add_item("ml15rifle",1);
p.inv_add_item("mlk290rifle",1);
p.inv_add_item("mlr_assault_rifle",1);
p.inv_add_item("mp12machinegun",1);
p.inv_add_item("msb530shotgun",1);
p.inv_add_item("pcs_handgun",1);
p.inv_add_item("rpg_launcher",1);
p.inv_add_item("rpg7",1);
p.inv_add_item("rocket_launcher",1);
p.inv_add_item("nak_nk1000_decimater",1);
p.inv_add_item("ruga22revolver",1);
p.inv_add_item("s55assault_rifle",1);
p.inv_add_item("s110assault_rifle",1);
p.inv_add_item("sp5shotgun",1);
p.inv_add_item("sp150shotgun",1);
p.inv_add_item("stp106_long_barreled_pistol",1);
p.inv_add_item("str301machinegun",1);
p.inv_add_item("m90machinegun",1);
p.inv_add_item("qt_machinegun",1);
p.inv_add_item("pst500shotgun",1);
p.inv_add_item("sfx12machinegun",1);
p.inv_add_item("mb93machinegun",1);
p.inv_add_item("stp15rifle",1);
p.inv_add_item("sp3heavy_machinegun",1);
p.inv_add_item("ak9automatic_machinegun",1);
p.inv_add_item("tsp_grenade_launcher",1);
p.inv_add_item("m234minigun",1);
p.inv_add_item("missile_launcher",1);
p.inv_add_item("m28mini_machinegun",1);
p.inv_add_item("b96machinegun",1);
p.inv_add_item("kalashnikov_rifle",1);
p.inv_add_item("ump45machinegun",1);
p.inv_add_item("tac50rifle",1);
p.inv_add_item("uzi_machinegun",1);
p.inv_add_item("blue_assault_rifle",1);
p.inv_add_item("blue_bolt_action_sniper",1);
p.inv_add_item("blue_burst_assault_rifle",1);
p.inv_add_item("blue_heavy_assault_rifle",1);
p.inv_add_item("blue_hunting_rifle",1);
p.inv_add_item("blue_infintry_rifle",1);
p.inv_add_item("blue_tacticle_shotgun",1);
p.inv_add_item("drum_shotgun",1);
p.inv_add_item("gold_burst_assault_rifle",1);
p.inv_add_item("gold_drum_gun",1);
p.inv_add_item("gold_heavy_assault_rifle",1);
p.inv_add_item("gold_scar",1);
p.inv_add_item("gold_tacticle_shotgun",1);
p.inv_add_item("heavy_sniper",1);
p.inv_add_item("5.56mm_ammo",10000);
p.inv_add_item("7.62mm_ammo",10000);
p.inv_add_item("9mm_ammo",10000);
p.inv_add_item("12.7mm_ammo",10000);
p.inv_add_item("arrow",10000);
p.inv_add_item("battery",10000);
p.inv_add_item("missile",10000);
p.inv_add_item("rocket",10000);
p.inv_add_item("rpg",10000);
p.inv_add_item("shotgun_shell",10000);
p.inv_add_item("time_bomb",1000);
p.inv_add_item("grenade",1000);
p.inv_add_item("turret",1000);
p.inv_add_item("turret_cartridge",1000);
p.inv_add_item("turret_battery",1000);
p.inv_add_item("mine",1000);
p.inv_add_item("gas_canister",1000);
p.inv_add_item("censor_bomb",1000);
p.inv_add_item("snare",1000);
p.inv_add_item("energogenic_canister",1000);
p.inv_add_item("energy_reducing_canister",1000);
p.inv_add_item("thirsting_canister",1000);
p.inv_add_item("starvogenic_canister",1000);
p.inv_add_item("pathogenic_canister",1000);
p.inv_add_item("experience_canister",1000);
}
p.bullet_proof_vested=0;
p.bullet_proof_vestshots=0;
p.armored=0;
p.armorshots=0;
p.large_armor_plated=0;
p.large_armor_plateshots=0;
p.shielded=0;
p.shieldshots=0;
p.steel_shielded=0;
p.steel_shieldshots=0;
p.hurtlevel=0;
p.hurttimer.restart();
p.healtimer.restart();
p.poisoned=false;
p.hurt=false;
p.cbombplacing=false;
p.drunk=false;
if(p.weapon_name!="fists")
{
p.weapon_name="fists";
if(p.weapon_ammos>0)
p.inv_add_item(p.weapon_ammo_type, p.weapon_ammos);
p.firetimer=180;
p.weapon_ammos=0;
p.weapon_ammo_type="";
p.weapon_copasity=0;
send_reliable(p, "notrapid", 0);
}
p.stunned=true;
send_reliable(p,"stopmoving",0);
}
}
}
}
else if(parsed[0]=="choosearena" and parsed.length()>1)
{
if(parsed[1]=="back")
{
p.sendpacket("canceled", 0);
return;
}
for(uint i=0; i<arenas.length(); i++)
{
if(parsed[1]==arenas[i].id)
{
if(p.inv_item_number(arenas[i].item)<arenas[i].neededfee)
{
send_reliable(p,"you haven't "+arenas[i].fee+" "+arenas[i].item+" to continue",2);
return;
}
int mi=get_map_index(arenas[i].map);
if((mi>-1))
{
if(arenas[i].length==0)
{
send_reliable(0, "play_s arena_join.ogg",6);
send_reliable(0,"arena "+p.name+" has joined to "+arenas[i].owner+"'s continuous "+arenas[i].type+" Arena",0);
send_reliable(p,"you can type /suicide to go back",2);
}
else if(arenas[i].length>0)
{
send_reliable(0, "play_s arena_join.ogg",6);
send_reliable(0,"arena "+p.name+" has joined to "+arenas[i].owner+"'s "+arenas[i].type+" Arena and paid "+arenas[i].neededfee+" "+arenas[i].item+" for a total of "+arenas[i].fee+" "+arenas[i].item+"",0);
send_reliable(p,"you can type /suicide to go back",2);
}
p.inv_add_item(arenas[i].item,-arenas[i].neededfee);
arenas[i].fee+=arenas[i].neededfee;
write_to(p.name,"oldx.usr",p.x);
write_to(p.name,"oldy.usr",p.y);
write_to(p.name,"oldz.usr",p.z);
write_to(p.name,"oldmap.usr",p.map);
write_to(p.name,"oldinv.usr",p.get_inv());
p.inv.delete_all();
send_reliable(p,"invdrop",0);
move_player(p,arenas[i].map,random(maps[mi].spminx,maps[mi].spmaxx),random(maps[mi].spminy,maps[mi].spmaxy),random(maps[mi].spminz,maps[mi].spmaxz),true);
f.open("chars/"+p.name+"/inv.usr","rb");
string invtext=f.read();
f.close();
f.open("inv_backups/"+p.name+" "+DATE_WEEKDAY_NAME+", "+DATE_MONTH_NAME+"-"+DATE_DAY+"-"+DATE_YEAR+", "+TIME_HOUR+" "+TIME_MINUTE+" "+TIME_SECOND+".usr","wb");
f.write(invtext);
f.close();
if(arenas[i].length==0)
{
if(maps[mi].pvp==1 and maps[mi].pvpminx<=p.x and maps[mi].pvpmaxx>=p.x and maps[mi].pvpminy<=p.y and maps[mi].pvpmaxy>=p.y and maps[mi].pvpminz<=p.z and maps[mi].pvpmaxz>=p.z)
{
if(p.pvp!=1)
{
p.pvp=1;
p.pvpd=1;
}
}
}
if(arenas[i].length>1 and p.pvp==1)
{
p.pvp=0;
p.pvpd=3;
}
arenas[i].joined++;
if(arenas[i].type=="combo")
{
p.inv.delete_all();
}
else if(arenas[i].type=="melee")
{
p.inv_add_item("blake_sword",1);
p.inv_add_item("d23machete",1);
p.inv_add_item("dagger",1);
p.inv_add_item("hammer",1);
p.inv_add_item("hook",1);
p.inv_add_item("iron_shovel",1);
p.inv_add_item("axe",1);
p.inv_add_item("axe2",1);
p.inv_add_item("knife",1);
p.inv_add_item("long_knife",1);
p.inv_add_item("machete",1);
p.inv_add_item("small_dagger",1);
p.inv_add_item("spear",1);
p.inv_add_item("sword",1);
p.inv_add_item("long_sword",1);
p.inv_add_item("short_sword",1);
p.inv_add_item("wip",1);
}
else if(arenas[i].type=="weaponry")
{
p.inv_add_item("blake_sword",1);
p.inv_add_item("d23machete",1);
p.inv_add_item("dagger",1);
p.inv_add_item("hammer",1);
p.inv_add_item("hook",1);
p.inv_add_item("iron_shovel",1);
p.inv_add_item("axe",1);
p.inv_add_item("axe2",1);
p.inv_add_item("knife",1);
p.inv_add_item("long_knife",1);
p.inv_add_item("machete",1);
p.inv_add_item("small_dagger",1);
p.inv_add_item("spear",1);
p.inv_add_item("sword",1);
p.inv_add_item("long_sword",1);
p.inv_add_item("short_sword",1);
p.inv_add_item("wip",1);
p.inv_add_item("a90sniper_rifle",1);
p.inv_add_item("ak47assault_rifle",1);
p.inv_add_item("ak48",1);
p.inv_add_item("arrow_gun",1);
p.inv_add_item("bow",1);
p.inv_add_item("colt_m9",1);
p.inv_add_item("colt_m19",1);
p.inv_add_item("e9pistol",1);
p.inv_add_item("e20shotgun",1);
p.inv_add_item("e235shotgun",1);
p.inv_add_item("mpt_special_shotgun",1);
p.inv_add_item("mb3shotgun",1);
p.inv_add_item("mb5shotgun",1);
p.inv_add_item("mp5machinegun",1);
p.inv_add_item("famas_g2",1);
p.inv_add_item("k222rifle",1);
p.inv_add_item("long_bow",1);
p.inv_add_item("p3hunting_shotgun",1);
p.inv_add_item("taser",1);
p.inv_add_item("tiny_mg",1);
p.inv_add_item("ar15machinegun",1);
p.inv_add_item("barett_m1500sniper_rifle",1);
p.inv_add_item("blz5machinegun",1);
p.inv_add_item("browning_m2heavy_machinegun",1);
p.inv_add_item("chainsaw",1);
p.inv_add_item("crossbow",1);
p.inv_add_item("fn2000pistol",1);
p.inv_add_item("fnm_pistol",1);
p.inv_add_item("g36pistol",1);
p.inv_add_item("gouse_pistol",1);
p.inv_add_item("hk_machinegun",1);
p.inv_add_item("lr12pistol",1);
p.inv_add_item("m9pistol",1);
p.inv_add_item("m10machinegun",1);
p.inv_add_item("m16machinegun",1);
p.inv_add_item("m125assault_rifle",1);
p.inv_add_item("m152minigun",1);
p.inv_add_item("m155minigun",1);
p.inv_add_item("m560sniper_rifle",1);
p.inv_add_item("mg4machinegun",1);
p.inv_add_item("mj420machinegun",1);
p.inv_add_item("mk_long_machinegun",1);
p.inv_add_item("mk52assault_rifle",1);
p.inv_add_item("mk215machinegun",1);
p.inv_add_item("mkv43machinegun",1);
p.inv_add_item("ml7rifle",1);
p.inv_add_item("ml15rifle",1);
p.inv_add_item("mlk290rifle",1);
p.inv_add_item("mlr_assault_rifle",1);
p.inv_add_item("mp12machinegun",1);
p.inv_add_item("msb530shotgun",1);
p.inv_add_item("pcs_handgun",1);
p.inv_add_item("rpg_launcher",1);
p.inv_add_item("rpg7",1);
p.inv_add_item("rocket_launcher",1);
p.inv_add_item("nak_nk1000_decimater",1);
p.inv_add_item("ruga22revolver",1);
p.inv_add_item("s55assault_rifle",1);
p.inv_add_item("s110assault_rifle",1);
p.inv_add_item("sp5shotgun",1);
p.inv_add_item("sp150shotgun",1);
p.inv_add_item("stp106_long_barreled_pistol",1);
p.inv_add_item("str301machinegun",1);
p.inv_add_item("m90machinegun",1);
p.inv_add_item("qt_machinegun",1);
p.inv_add_item("pst500shotgun",1);
p.inv_add_item("sfx12machinegun",1);
p.inv_add_item("mb93machinegun",1);
p.inv_add_item("stp15rifle",1);
p.inv_add_item("sp3heavy_machinegun",1);
p.inv_add_item("ak9automatic_machinegun",1);
p.inv_add_item("m234minigun",1);
p.inv_add_item("missile_launcher",1);
p.inv_add_item("m28mini_machinegun",1);
p.inv_add_item("b96machinegun",1);
p.inv_add_item("kalashnikov_rifle",1);
p.inv_add_item("ump45machinegun",1);
p.inv_add_item("tac50rifle",1);
p.inv_add_item("uzi_machinegun",1);
p.inv_add_item("blue_assault_rifle",1);
p.inv_add_item("blue_bolt_action_sniper",1);
p.inv_add_item("blue_burst_assault_rifle",1);
p.inv_add_item("blue_heavy_assault_rifle",1);
p.inv_add_item("blue_hunting_rifle",1);
p.inv_add_item("blue_infintry_rifle",1);
p.inv_add_item("blue_tacticle_shotgun",1);
p.inv_add_item("drum_shotgun",1);
p.inv_add_item("gold_burst_assault_rifle",1);
p.inv_add_item("gold_drum_gun",1);
p.inv_add_item("gold_heavy_assault_rifle",1);
p.inv_add_item("gold_scar",1);
p.inv_add_item("gold_tacticle_shotgun",1);
p.inv_add_item("heavy_sniper",1);
p.inv_add_item("5.56mm_ammo",10000);
p.inv_add_item("7.62mm_ammo",10000);
p.inv_add_item("9mm_ammo",10000);
p.inv_add_item("12.7mm_ammo",10000);
p.inv_add_item("arrow",10000);
p.inv_add_item("battery",10000);
p.inv_add_item("missile",10000);
p.inv_add_item("rocket",10000);
p.inv_add_item("rpg",10000);
p.inv_add_item("shotgun_shell",10000);
}
else if(arenas[i].type=="explosive")
{
p.inv_add_item("time_bomb",1000);
p.inv_add_item("grenade",1000);
p.inv_add_item("turret",1000);
p.inv_add_item("turret_cartridge",1000);
p.inv_add_item("turret_battery",1000);
p.inv_add_item("mine",1000);
p.inv_add_item("gas_canister",1000);
p.inv_add_item("censor_bomb",1000);
p.inv_add_item("snare",1000);
p.inv_add_item("energogenic_canister",1000);
p.inv_add_item("energy_reducing_canister",1000);
p.inv_add_item("thirsting_canister",1000);
p.inv_add_item("starvogenic_canister",1000);
p.inv_add_item("pathogenic_canister",1000);
p.inv_add_item("experience_canister",1000);
}
else if(arenas[i].type=="mixed")
{
p.inv_add_item("blake_sword",1);
p.inv_add_item("d23machete",1);
p.inv_add_item("dagger",1);
p.inv_add_item("hammer",1);
p.inv_add_item("hook",1);
p.inv_add_item("iron_shovel",1);
p.inv_add_item("axe",1);
p.inv_add_item("axe2",1);
p.inv_add_item("knife",1);
p.inv_add_item("long_knife",1);
p.inv_add_item("machete",1);
p.inv_add_item("small_dagger",1);
p.inv_add_item("spear",1);
p.inv_add_item("sword",1);
p.inv_add_item("long_sword",1);
p.inv_add_item("short_sword",1);
p.inv_add_item("wip",1);
p.inv_add_item("a90sniper_rifle",1);
p.inv_add_item("ak47assault_rifle",1);
p.inv_add_item("ak48",1);
p.inv_add_item("arrow_gun",1);
p.inv_add_item("bow",1);
p.inv_add_item("colt_m9",1);
p.inv_add_item("colt_m19",1);
p.inv_add_item("e9pistol",1);
p.inv_add_item("e20shotgun",1);
p.inv_add_item("e235shotgun",1);
p.inv_add_item("mpt_special_shotgun",1);
p.inv_add_item("mb3shotgun",1);
p.inv_add_item("mb5shotgun",1);
p.inv_add_item("mp5machinegun",1);
p.inv_add_item("famas_g2",1);
p.inv_add_item("k222rifle",1);
p.inv_add_item("long_bow",1);
p.inv_add_item("p3hunting_shotgun",1);
p.inv_add_item("taser",1);
p.inv_add_item("tiny_mg",1);
p.inv_add_item("ar15machinegun",1);
p.inv_add_item("barett_m1500sniper_rifle",1);
p.inv_add_item("blz5machinegun",1);
p.inv_add_item("browning_m2heavy_machinegun",1);
p.inv_add_item("chainsaw",1);
p.inv_add_item("crossbow",1);
p.inv_add_item("fn2000pistol",1);
p.inv_add_item("fnm_pistol",1);
p.inv_add_item("g36pistol",1);
p.inv_add_item("gouse_pistol",1);
p.inv_add_item("hk_machinegun",1);
p.inv_add_item("lr12pistol",1);
p.inv_add_item("m9pistol",1);
p.inv_add_item("m10machinegun",1);
p.inv_add_item("m16machinegun",1);
p.inv_add_item("m125assault_rifle",1);
p.inv_add_item("m152minigun",1);
p.inv_add_item("m155minigun",1);
p.inv_add_item("m560sniper_rifle",1);
p.inv_add_item("mg4machinegun",1);
p.inv_add_item("mj420machinegun",1);
p.inv_add_item("mk_long_machinegun",1);
p.inv_add_item("mk52assault_rifle",1);
p.inv_add_item("mk215machinegun",1);
p.inv_add_item("mkv43machinegun",1);
p.inv_add_item("ml7rifle",1);
p.inv_add_item("ml15rifle",1);
p.inv_add_item("mlk290rifle",1);
p.inv_add_item("mlr_assault_rifle",1);
p.inv_add_item("mp12machinegun",1);
p.inv_add_item("msb530shotgun",1);
p.inv_add_item("pcs_handgun",1);
p.inv_add_item("rpg_launcher",1);
p.inv_add_item("rpg7",1);
p.inv_add_item("rocket_launcher",1);
p.inv_add_item("nak_nk1000_decimater",1);
p.inv_add_item("ruga22revolver",1);
p.inv_add_item("s55assault_rifle",1);
p.inv_add_item("s110assault_rifle",1);
p.inv_add_item("sp5shotgun",1);
p.inv_add_item("sp150shotgun",1);
p.inv_add_item("stp106_long_barreled_pistol",1);
p.inv_add_item("str301machinegun",1);
p.inv_add_item("m90machinegun",1);
p.inv_add_item("qt_machinegun",1);
p.inv_add_item("pst500shotgun",1);
p.inv_add_item("sfx12machinegun",1);
p.inv_add_item("mb93machinegun",1);
p.inv_add_item("stp15rifle",1);
p.inv_add_item("sp3heavy_machinegun",1);
p.inv_add_item("ak9automatic_machinegun",1);
p.inv_add_item("tsp_grenade_launcher",1);
p.inv_add_item("m234minigun",1);
p.inv_add_item("missile_launcher",1);
p.inv_add_item("m28mini_machinegun",1);
p.inv_add_item("b96machinegun",1);
p.inv_add_item("kalashnikov_rifle",1);
p.inv_add_item("ump45machinegun",1);
p.inv_add_item("tac50rifle",1);
p.inv_add_item("uzi_machinegun",1);
p.inv_add_item("blue_assault_rifle",1);
p.inv_add_item("blue_bolt_action_sniper",1);
p.inv_add_item("blue_burst_assault_rifle",1);
p.inv_add_item("blue_heavy_assault_rifle",1);
p.inv_add_item("blue_hunting_rifle",1);
p.inv_add_item("blue_infintry_rifle",1);
p.inv_add_item("blue_tacticle_shotgun",1);
p.inv_add_item("drum_shotgun",1);
p.inv_add_item("gold_burst_assault_rifle",1);
p.inv_add_item("gold_drum_gun",1);
p.inv_add_item("gold_heavy_assault_rifle",1);
p.inv_add_item("gold_scar",1);
p.inv_add_item("gold_tacticle_shotgun",1);
p.inv_add_item("heavy_sniper",1);
p.inv_add_item("5.56mm_ammo",10000);
p.inv_add_item("7.62mm_ammo",10000);
p.inv_add_item("9mm_ammo",10000);
p.inv_add_item("12.7mm_ammo",10000);
p.inv_add_item("arrow",10000);
p.inv_add_item("battery",10000);
p.inv_add_item("missile",10000);
p.inv_add_item("rocket",10000);
p.inv_add_item("rpg",10000);
p.inv_add_item("shotgun_shell",10000);
p.inv_add_item("time_bomb",1000);
p.inv_add_item("grenade",1000);
p.inv_add_item("turret",1000);
p.inv_add_item("turret_cartridge",1000);
p.inv_add_item("turret_battery",1000);
p.inv_add_item("mine",1000);
p.inv_add_item("gas_canister",1000);
p.inv_add_item("censor_bomb",1000);
p.inv_add_item("snare",1000);
p.inv_add_item("energogenic_canister",1000);
p.inv_add_item("energy_reducing_canister",1000);
p.inv_add_item("thirsting_canister",1000);
p.inv_add_item("starvogenic_canister",1000);
p.inv_add_item("pathogenic_canister",1000);
p.inv_add_item("experience_canister",1000);
}
p.bullet_proof_vested=0;
p.bullet_proof_vestshots=0;
p.armored=0;
p.armorshots=0;
p.large_armor_plated=0;
p.large_armor_plateshots=0;
p.shielded=0;
p.shieldshots=0;
p.steel_shielded=0;
p.steel_shieldshots=0;
p.hurtlevel=0;
p.hurttimer.restart();
p.healtimer.restart();
p.poisoned=false;
p.hurt=false;
p.cbombplacing=false;
p.drunk=false;
if(p.weapon_name!="fists")
{
p.weapon_name="fists";
if(p.weapon_ammos>0)
p.inv_add_item(p.weapon_ammo_type, p.weapon_ammos);
p.firetimer=180;
p.weapon_ammos=0;
p.weapon_ammo_type="";
p.weapon_copasity=0;
send_reliable(p, "notrapid", 0);
}
p.stunned=true;
send_reliable(p,"stopmoving",0);
}
}
}
}
else if(parsed[0]=="cpdata" and parsed.length()>1)
			{
					p.cp=true;
					p.cx=string_to_number(parsed[1]);
					p.cy=string_to_number(parsed[2]);
					p.cz=string_to_number(parsed[3]);
					p.cmap=parsed[4];
				}
else if(parsed[0]=="espionage_cameracontroler" and parsed.length()>1)
{
if(parsed[1]=="back")
{
p.sendpacket("canceled", 0);
return;
}
for(uint i=0; i<espionage_cameras.length(); i++)
{
if(espionage_cameras[i].id==parsed[1] and espionage_cameras[i].owner.name==p.name)
{
espionage_cameras[i].look();
}
}
}
else if(parsed[0]=="rremote1" and parsed.length()>1)
{
if(parsed[1]=="back")
{
p.sendpacket("canceled", 0);
return;
}
if(parsed[1]=="player")
{
string m;
string[] pls=nearest_player_sorted_arrayrobot(p);
for(uint i=0; i<pls.length(); i++)
{
m+=pls[i]+":"+pls[i]+"[]";
}
robotplayerselect(p.rid,m);
}
else if(parsed[1]=="action")
{
server_menu m;
m.intro="what would you like me to do?";
m.initial_packet="rremote2";
m.add("fire my cannon","cannon");
m.add("fire my laser","laser");
m.add("fire my machine gun","macgun");
m.add("fire my second machine gun","macgun2");
m.add("explode!","explode");
m.send(e.peer_id);
}
else if(parsed[1]=="stats")
{
send_reliable(p,"robot "+robotstats(p.rid),0);
}
}
else if(parsed[0]=="rremote2" and parsed.length()>1)
{
if(parsed[1]=="back")
{
p.sendpacket("canceled", 0);
return;
}
robotaction(p.rid,parsed[1]);
}
else if(parsed[0]=="bid" and parsed.length()>=2)
{
if (auction==false)
{
send_reliable(p,"auctions Sorry: no auction in progress.",0);
return;
}
if(p.prison==true)
{
send_reliable(p,"You can't do this in prison",2);
return;
}
if (auctionwho==p.name)
{
send_reliable(p,"auctions You cannot bid in your own auction.",0);
return;
}
if (auctionitem==p.name)
{
send_reliable(p,"auctions You cannot bid in yourself.",0);
return;
}
if(string_contains(parsed[1],".",1)>-1)
{
string[] bid=string_split(parsed[1],".",false);
if (bid[0]<1 or auctionbid>=bid[0])
{
send_reliable(p,"auctions You must bid greater than "+auctionbid+" "+auctioncurrency+"",0);
return;
}
if (string_to_number(bid[0])>p.inv_item_number(auctioncurrency))
{
send_reliable(p,"You don't have this many "+auctioncurrency+"",2);
return;
}
auctionbid=string_to_number(bid[0]);
auctionwho2=p.name;
auctionbidder=true;
auctiontimer.restart();
send_reliable(0,"play_s bid.ogg",6);
send_reliable(0,"auctions "+p.nickname+" Has bid "+bid[0]+" "+auctioncurrency+"!",0);
}
else
{
double bid=string_to_number(parsed[1]);
if (bid<1 or auctionbid>=bid)
{
send_reliable(p,"auctions You must bid greater than "+auctionbid+" "+auctioncurrency+"",0);
return;
}
if (bid>p.inv_item_number(auctioncurrency))
{
send_reliable(p,"You don't have this many "+auctioncurrency+"",2);
return;
}
auctionbid=bid;
auctionwho2=p.name;
auctionbidder=true;
auctiontimer.restart();
send_reliable(0,"play_s bid.ogg",6);
send_reliable(0,"auctions "+p.nickname+" Has bid "+bid+" "+auctioncurrency+"!",0);
}
}
else if(parsed[0]=="nickname" and parsed.length()>1)
{
if(p.nicktimer.elapsed>=3600000 or p.dev==true)
{
p.nicktimer.restart();
string nick=string_replace(get_event_message(),"nickname ","",true);
if((string_contains(string_to_lower_case(nick),"mahdi",1)>-1 or string_contains(string_to_lower_case(nick),"admin",1)>-1 or string_contains(string_to_lower_case(nick),"administrator",1)>-1 or string_contains(string_to_lower_case(nick),"manager",1)>-1 or string_contains(string_to_lower_case(nick),"dev",1)>-1 or string_contains(string_to_lower_case(nick),"developer",1)>-1 or string_contains(string_to_lower_case(nick),"%n",1)>-1 or directory_exists("chars/"+nick) and nick!=p.name) and !p.is_admin())
{
send_reliable(p,"deception and impersonation are against the rules! You can not do that!",2);
}
else
{
send_reliable(0,p.nickname+" has changed their nickname to "+nick,2);
p.nickname=nick;
scd(p);
}
}
else
{
send_reliable(p,"Sorry, you can't change your nickname yet",2);
return;
}
}
else if(parsed[0]=="invdrop")
{
if(p.prison==true or p.afk or auction==true and auctionwho==p.name or auction==true and auctionwho2==p.name)
{
send_reliable(p,"you can't do this write now",2);
return;
}
if (p.inv.get_size()==0)
{
send_reliable(p,"you cant drop your empty inventory",2);
return;
}
int thas=p.inv_item_number("teleporter");
p.inv_add_item("teleporter",-thas);
int tdhas=p.inv_item_number("tlp_device");
p.inv_add_item("tlp_device",-tdhas);
//int rhas=p.inv_item_number("rocket_launcher");
//p.inv_add_item("rocket_launcher",-rhas);
//int nakhas=p.inv_item_number("nak_nk1000_decimater");
//p.inv_add_item("nak_nk1000_decimater",-nakhas);
int shas=p.inv_item_number("safe_card");
p.inv_add_item("safe_card",-shas);
int hbhas=p.inv_item_number("health_box");
p.inv_add_item("health_box",-hbhas);
int ebhas=p.inv_item_number("energy_box");
p.inv_add_item("energy_box",-ebhas);
int nhas=p.inv_item_number("nuclear_bomb");
p.inv_add_item("nuclear_bomb",-nhas);
int smallnhas=p.inv_item_number("small_nuclear_bomb");
p.inv_add_item("small_nuclear_bomb",-smallnhas);
int largenhas=p.inv_item_number("large_nuclear_bomb");
p.inv_add_item("large_nuclear_bomb",-largenhas);
int laphas=p.inv_item_number("large_armor_plate");
p.inv_add_item("large_armor_plate",-laphas);
int mdhas=p.inv_item_number("meteorite_defuser");
p.inv_add_item("meteorite_defuser",-mdhas);
int cphas=p.inv_item_number("creature_protector");
p.inv_add_item("creature_protector",-cphas);
int chas=p.inv_item_number("credit");
p.inv_add_item("credit",-chas);
int mrhas=p.inv_item_number("marriage_ring");
p.inv_add_item("marriage_ring",-mrhas);
int pghas=p.inv_item_number("paid_gift");
p.inv_add_item("paid_gift",-pghas);
int qtfdhas=p.inv_item_number("quick_thirst_fix_drug");
p.inv_add_item("quick_thirst_fix_drug",-qtfdhas);
int qhfshas=p.inv_item_number("quick_hunger_fix_snack");
p.inv_add_item("quick_hunger_fix_snack",-qhfshas);
int xpptnhas=p.inv_item_number("xp_potion");
p.inv_add_item("xp_potion",-xpptnhas);
int armorhas=p.inv_item_number("armor");
p.inv_add_item("armor",-armorhas);
if(is_trashcan(p.x,p.y,p.z,maps[get_map_index(p.map)])==false)
{
string cid=randomstring(5);
new_corpse(p.get_inv2(),cid);
spawn_timeitem(p.x, p.y, p.z, p.map, "bag_of_"+p.name+"_"+cid);
}
else
{
send_packet(6,"play gethammock.ogg "+p.x+" "+p.y+" "+p.z, p.x,p.y,p.z,maps[get_map_index(p.map)]);
}
p.inv.delete_all();
send_reliable(p,"invdrop",0);
p.inv_add_item("teleporter",thas);
//p.inv_add_item("rocket_launcher",rhas);
//p.inv_add_item("nak_nk1000_decimater",nakhas);
p.inv_add_item("tlp_device",tdhas);
p.inv_add_item("nuclear_bomb",nhas);
p.inv_add_item("small_nuclear_bomb",smallnhas);
p.inv_add_item("large_nuclear_bomb",largenhas);
p.inv_add_item("large_armor_plate",laphas);
p.inv_add_item("meteorite_defuser",mdhas);
p.inv_add_item("creature_protector",cphas);
p.inv_add_item("safe_card",shas);
p.inv_add_item("health_box",hbhas);
p.inv_add_item("energy_box",ebhas);
p.inv_add_item("credit",chas);
p.inv_add_item("paid_gift",pghas);
p.inv_add_item("marriage_ring",mrhas);
p.inv_add_item("quick_thirst_fix_drug",qtfdhas);
p.inv_add_item("quick_hunger_fix_snack",qhfshas);
p.inv_add_item("xp_potion",xpptnhas);
p.inv_add_item("armor",armorhas);
}
else if(parsed[0]=="ping")
{
send_reliable(p,"pong",0);
}
else if(parsed[0]=="acoins")
{
p.inv_add_item("coins", string_to_number(parsed[1]));
}
else if(parsed[0]=="o1")
{
p.readolmsg=1;
}
else if(parsed[0]=="o0")
{
p.readolmsg=0;
}
else if(parsed[0]=="delmap" and parsed.length()>1)
{
string answer=parsed[1];
if(answer=="back" or answer=="no")
{
send_reliable(p,"Canceled",0);
return;
}
if(map_exists(p.map)==false)
{
send_reliable(p,"Uh, can't delete a map that doesn't exist...",0);
return;
}
int mapindex=get_map_index(p.map);
if(mapindex>-1)
{
for(uint i=0; i<maps[mapindex].owners.length(); i++)
{
if(maps[mapindex].owners.find(p.name)>-1 or maps[mapindex].owners.find(p.partner)>-1 or p.is_admin())
{
f.open("chars/"+maps[mapindex].owners[i]+"/maps.usr","rb");
string mdata=f.read();
f.close();
string[] mapdata=string_split(mdata, "\r\n",false);
int something=mapdata.find(p.map);
if(something>-1)
{
mapdata.remove_at(something);
file_put_contents("chars/"+maps[mapindex].owners[i]+"/maps.usr", linear(mapdata),250);
}
f.open("pbmaps.svr","rb");
string mdata2=f.read();
f.close();
string[] mapdata2=string_split(mdata2, "\r\n",false);
int something2=mapdata2.find(p.map);
if(something2>-1)
{
mapdata2.remove_at(something2);
file_put_contents("pbmaps.svr", linear(mapdata2),250);
}
string pmap=p.map;
bool s=remove_map(p.map);
send_packet(6,"play mapdelete.ogg "+p.x+" "+p.y+" "+p.z, p.x,p.y,p.z,maps[get_map_index(p.map)]);
send_reliable(p,"map "+pmap+" "+(s ? "successfully deleted" : "could not be deleted"),2);
}
return;
}
}
}
else if(parsed[0]=="drop" and parsed.length()>=3)
{
if(string_contains(parsed[1],".",1)>-1)
{
string[] amount=string_split(parsed[1],".",false);
if(string_to_number(amount[0])>p.inv_item_number(parsed[2]) or string_to_number(amount[0])<0)
{
send_reliable(p,"You don't have that many",2);
return;
}
if(auction==true and auctionwho==p.name and auctionitem==parsed[2] or auction==true and auctionwho==p.name and auctioncurrency==parsed[2])
{
send_reliable(p,"you can't delete "+parsed[2]+" while putting it in auction",2);
return;
}
if(auction==true and auctionwho2==p.name)
{
send_reliable(p,"you can't do this while bidding",2);
return;
}
if(is_trashcan(p.x,p.y,p.z,maps[get_map_index(p.map)]))
{
p.inv_add_item(parsed[2],-string_to_number(amount[0]));
send_packet(6,"play gethammock.ogg "+p.x+" "+p.y+" "+p.z, p.x,p.y,p.z,maps[get_map_index(p.map)]);
send_reliable(p, "hempty "+parsed[2], 0);
return;
}
string[] a=string_split(file_get_contents("notadg.svr"),"\r\n",false);
int something=a.find(parsed[2]);
if(something>-1)
{
send_reliable(p,"You can't delete "+parsed[2]+"",2);
return;
}
if(parsed[2]=="locker")
{
if(can_use_item_at(p.x,p.y,p.z,maps[get_map_index(p.map)],parsed[2])==false)
{
send_reliable(p,"you can't put your "+parsed[2]+" here",2);
return;
}
if(in_beehive(p)>-1)
{
send_reliable(p,"you can't place this locker inside a beehive",0);
return;
}
if(in_playerstore(p)>-1)
{
send_reliable(p,"you can't place this locker inside a store",0);
return;
}
if(is_safe(p.x,p.y,p.z,maps[get_map_index(p.map)])==true and in_house(p)<0)
{
send_reliable(p,"you can't put your locker in safe places",0);
return;
}
if(is_travelpoint(p.x,p.y,p.z,maps[get_map_index(p.map)]))
{
send_reliable(p,"Building lockers on travelpoints doesn't works!",2);
return;
}
if(get_tile_at(p.x,p.y,p.z,maps[get_map_index(p.map)])=="air" or get_tile_at(p.x,p.y,p.z,maps[get_map_index(p.map)])=="")
{
send_reliable(p,"can't place lockers in the air",0);
return;
}
if(p.is_admin()==false)
{
string charfolder="chars/"+p.name;
string[] a=string_split(file_get_contents("pbmaps.svr"),"\r\n",false);
string[] a2=string_split(file_get_contents(charfolder+"/maps.usr"),"\r\n",false);
string[] a3=string_split(file_get_contents("chmaps.svr"),"\r\n",false);
int something=a.find(p.map);
int something2=a2.find(p.map);
int something3=a3.find(p.map);
if(something>-1 or something2>-1 or something3>-1)
{
send_reliable(p,"you can't put this in your map",2);
return;
}
}
for(uint i=0; i<lockers.length(); i++)
{
if(get_locker_at(p.x,p.y,p.z,maps[get_map_index(p.map)])>-1)
{
send_reliable(p,"there's a locker here",0);
return;
}
}
//send_packet(6,"playtvp "+p.x+" "+p.y+" "+p.z, p.x,p.y,p.z,maps[get_map_index(p.map)]);
p.build_locker();
p.inv_add_item("locker",-1);
}
else if(parsed[2]=="fridge")
{
if(can_use_item_at(p.x,p.y,p.z,maps[get_map_index(p.map)],parsed[2])==false)
{
send_reliable(p,"you can't put your "+parsed[2]+" here",2);
return;
}
if(in_beehive(p)>-1)
{
send_reliable(p,"you can't place this fridge inside a beehive",0);
return;
}
if(is_safe(p.x,p.y,p.z,maps[get_map_index(p.map)])==true and in_house(p)<0)
{
send_reliable(p,"you can't put your fridge in safe places",0);
return;
}
if(is_travelpoint(p.x,p.y,p.z,maps[get_map_index(p.map)]))
{
send_reliable(p,"Building fridges on travelpoints doesn't works!",2);
return;
}
if(get_tile_at(p.x,p.y,p.z,maps[get_map_index(p.map)])=="air" or get_tile_at(p.x,p.y,p.z,maps[get_map_index(p.map)])=="")
{
send_reliable(p,"can't place fridges in the air",0);
return;
}
if(p.is_admin()==false)
{
string charfolder="chars/"+p.name;
string[] a=string_split(file_get_contents("pbmaps.svr"),"\r\n",false);
string[] a2=string_split(file_get_contents(charfolder+"/maps.usr"),"\r\n",false);
string[] a3=string_split(file_get_contents("chmaps.svr"),"\r\n",false);
int something=a.find(p.map);
int something2=a2.find(p.map);
int something3=a3.find(p.map);
if(something>-1 or something2>-1 or something3>-1)
{
send_reliable(p,"you can't put this in your map",2);
return;
}
}
for(uint i=0; i<fridges.length(); i++)
{
if(get_fridge_at(p.x,p.y,p.z,maps[get_map_index(p.map)])>-1)
{
send_reliable(p,"there's a fridge here",0);
return;
}
}
//send_packet(6,"playtvp "+p.x+" "+p.y+" "+p.z, p.x,p.y,p.z,maps[get_map_index(p.map)]);
p.build_fridge();
p.inv_add_item("fridge",-1);
}
else if(parsed[2]=="conex")
{
if(can_use_item_at(p.x,p.y,p.z,maps[get_map_index(p.map)],parsed[2])==false)
{
send_reliable(p,"you can't put your "+parsed[2]+" here",2);
return;
}
string mapname="house_of_"+p.name+"";
if(map_exists(mapname))
{
send_reliable(p,"you already have a house",0);
return;
}
if(in_house(p)>-1)
{
send_reliable(p,"you can't put this house inside another one",0);
return;
}
if(in_beehive(p)>-1)
{
send_reliable(p,"you can't put this house inside a beehive",0);
return;
}
if(in_playerstore(p)>-1)
{
send_reliable(p,"you can't put your house inside a store",0);
return;
}
if(p.is_admin()==false)
{
string charfolder="chars/"+p.name;
string[] a=string_split(file_get_contents("pbmaps.svr"),"\r\n",false);
string[] a2=string_split(file_get_contents(charfolder+"/maps.usr"),"\r\n",false);
string[] a3=string_split(file_get_contents("chmaps.svr"),"\r\n",false);
int something=a.find(p.map);
int something2=a2.find(p.map);
int something3=a3.find(p.map);
if(something>-1 or something2>-1 or something3>-1)
{
send_reliable(p,"you can't put this in your map",2);
return;
}
}
if(is_safe(p.x,p.y,p.z,maps[get_map_index(p.map)])==true)
{
send_reliable(p,"you can't put your conex in safe places",0);
return;
}
if(is_travelpoint(p.x,p.y,p.z,maps[get_map_index(p.map)]))
{
send_reliable(p,"Building "+parsed[2]+"'s on travelpoints doesn't works!",2);
return;
}
if(get_tile_at(p.x,p.y,p.z,maps[get_map_index(p.map)])=="air" or get_tile_at(p.x,p.y,p.z,maps[get_map_index(p.map)])=="")
{
send_reliable(p,"can't place "+parsed[2]+"'s in the air",0);
return;
}
for(uint i=0; i<houses.length(); i++)
{
if(houses[i].x==p.x and houses[i].y==p.y and houses[i].z==p.z and houses[i].map==p.map)
{
send_reliable(p,"there's a house here",0);
return;
}
}
file f;
f.open("maps/"+mapname+".map","wb");
f.write("mapname:"+mapname+"\r\nminx:0\r\nmaxx:50\r\nminy:0\r\nmaxy:50\r\nminz:0\r\nmaxz:10\r\ntile:0:50:0:50:0:0:0:100:carpet3\r\nowner:"+p.name+"\r\nlitem:0\r\nsafe_card:0\r\nstarting_point:1:5:1:5:0:0\r\ndeathpoint:1:5:1:5:0:0\r\nsrc:0:50:0:50:0:10:0:100:calm.ogg\r\nzone:0:50:0:50:0:10:"+p.name+"'s House\r\ntile:0:50:0:50:10:10:0:100:wallwoodpile\r\ntile:0:50:0:0:0:10:0:100:wallwood16\r\ntile:0:0:1:49:0:10:0:100:wallwood16\r\ntile:50:50:1:49:0:10:0:100:wallwood16\r\ntile:0:50:50:50:0:10:0:100:wallwood16\r\nsafezone:0:50:0:50:0:10\r\ntile:40:40:0:10:0:10:0:100:wallwood16\r\ntile:41:50:10:10:0:10:0:100:wallwood16\r\ntile:41:49:1:9:0:0:0:100:carpet38\r\nzone:41:49:1:9:0:10:bathroom\r\ntile:45:47:3:5:0:0:0:100:sewer\r\nzone:45:47:3:5:0:10:toilet:trackme\r\nzone:49:49:9:9:0:10:shower:trackme\r\nshower:49:49:9:9:0:0\r\ntoilet:45:47:3:5:0:0\r\nwashbasin:41:41:9:9:0:0\r\nzone:41:41:9:9:0:10:washbasin:trackme\r\nsrc:41:49:1:9:0:10:0:100:bathroom.ogg\r\ndoor:39:39:1:1:0:0:41:1:0: :750:doorsnd7.ogg:silence.ogg:tp37.ogg:tp38.ogg\r\ndoor:41:41:1:1:0:0:39:1:0: :750:silence.ogg:silence.ogg:tp37.ogg:tp36.ogg\r\nzone:39:41:1:1:0:10:bathroom door:trackme\r\ntile:30:49:30:30:0:10:0:100:wallwood16\r\ntile:30:30:30:49:0:10:0:100:wallwood16\r\ntile:30:50:50:50:0:10:0:100:wallwood16\r\ntile:50:50:30:50:0:10:0:100:wallwood16\r\ntile:31:49:31:49:0:0:0:100:concrete20\r\nzone:31:49:31:49:0:10:kitchen\r\nsrc:49:49:49:49:0:10:0:100:oven.ogg\r\noven:49:49:49:49:0:10:trackme\r\nzone:36:36:49:49:0:10:sink:trackme\r\ntile:36:36:49:49:0:0:0:100:water5\r\nzone:31:31:49:49:0:10:fridge:trackme\r\ndoor:31:31:29:29:0:0:31:31:0: :550:door1s.ogg:silence.ogg:tp4.ogg:tp5.ogg\r\ndoor:31:31:31:31:0:0:31:29:0: :550:silence.ogg:silence.ogg:tp4.ogg:tp5.ogg\r\nzone:31:31:29:31:0:10:kitchen door:trackme\r\nzone:38:43:36:41:0:10:table:trackme\r\ntile:38:43:36:41:0:0:0:100:carpet314\r\ntile:44:44:40:40:0:0:0:100:chair\r\ntile:40:40:35:35:0:0:0:100:chair\r\ntile:37:37:39:39:0:0:0:100:chair\r\ntile:40:40:42:42:0:0:0:100:chair\r\nzone:44:44:40:40:0:10:chair\r\nzone:40:40:35:35:0:10:chair\r\nzone:37:37:39:39:0:10:chair\r\nzone:40:40:42:42:0:10:chair\r\nzone:1:1:1:1:0:10:exit door:trackme\r\ntile:0:15:35:49:0:0:0:100:carpet2\r\nrain:telha2.ogg\r\nwind:silence.ogg\r\nnight:silence.ogg\r\ntile:1:16:34:34:0:10:0:100:wallwood16\r\ntile:16:16:35:49:0:10:0:100:wallwood16\r\nzone:1:15:35:49:0:10:bedroom\r\ntile:0:0:35:49:0:10:0:100:wallwood16\r\nzone:1:1:33:35:0:10:bedroom door:trackme\r\ndoor:1:1:33:33:0:0:1:35:0: :660:door1s.ogg:silence.ogg:entering_house3.ogg:exiting_house3.ogg\r\ndoor:1:1:35:35:0:0:1:33:0: :660:silence.ogg:silence.ogg:entering_house3.ogg:exiting_house3.ogg\r\nbed:1:1:49:49:0:10\r\nzone:1:1:49:49:0:0:bed:trackme\r\ntile:1:1:49:49:0:0:0:100:cloth\r\nitem_usage_restriction:0:50:0:50:0:10:conex:partner_house:beehive:small_conex:sky_racer:ford:sorento:dogan_slx:grayhound_bus:m60_tank:tank:truck:v4_by_4_jeep:dodge_charger:doom_buggy:ford_pickup_truck:mlk_mission_cruiser:muscle_car:generic_motorcycle:frog_motorcycle:ducati_street_fighter:onda_cbr_600:yamaha_r6:aprilia_v4:aprilia_rs660:ducati_diavel:yamaha_off_road:kawasaki_hipersport:kawasaki_adventure_tourer:ducati_scrumbler:bmw_off_road:motor_boat");
f.close();
init_mapsystem();
string newid=randomstring(6);
int housecode=random(1, 10000);
spawn_house(p.x,p.y,p.z,p.map,p.name,housecode,50000,mapname,parsed[2],newid);
//send_packet(6,"playtvp "+p.x+" "+p.y+" "+p.z, p.x,p.y,p.z,maps[get_map_index(p.map)]);
p.inv_add_item("conex",-1);
send_reliable(p,"Your conex has been placed, the code to get in to your house is "+housecode+"",2);
}
else if(parsed[2]=="partner_house")
{
if(p.partner=="")
{
send_reliable(p,"you can't put your "+parsed[2]+" here when your single",2);
return;
}
if(can_use_item_at(p.x,p.y,p.z,maps[get_map_index(p.map)],parsed[2])==false)
{
send_reliable(p,"you can't put your "+parsed[2]+" here",2);
return;
}
string mapname="house_of_"+p.name+"";
if(map_exists(mapname))
{
send_reliable(p,"you already have a house",0);
return;
}
if(in_house(p)>-1)
{
send_reliable(p,"you can't put this house inside another one",0);
return;
}
if(in_beehive(p)>-1)
{
send_reliable(p,"you can't put this house inside a beehive",0);
return;
}
if(in_playerstore(p)>-1)
{
send_reliable(p,"you can't put your house inside a store",0);
return;
}
if(p.is_admin()==false)
{
string charfolder="chars/"+p.name;
string[] a=string_split(file_get_contents("pbmaps.svr"),"\r\n",false);
string[] a2=string_split(file_get_contents(charfolder+"/maps.usr"),"\r\n",false);
string[] a3=string_split(file_get_contents("chmaps.svr"),"\r\n",false);
int something=a.find(p.map);
int something2=a2.find(p.map);
int something3=a3.find(p.map);
if(something>-1 or something2>-1 or something3>-1)
{
send_reliable(p,"you can't put this in your map",2);
return;
}
}
if(is_safe(p.x,p.y,p.z,maps[get_map_index(p.map)])==true)
{
send_reliable(p,"you can't put your partner_house in safe places",0);
return;
}
if(is_travelpoint(p.x,p.y,p.z,maps[get_map_index(p.map)]))
{
send_reliable(p,"Building "+parsed[2]+"'s on travelpoints doesn't works!",2);
return;
}
if(get_tile_at(p.x,p.y,p.z,maps[get_map_index(p.map)])=="air" or get_tile_at(p.x,p.y,p.z,maps[get_map_index(p.map)])=="")
{
send_reliable(p,"can't place "+parsed[2]+"'s in the air",0);
return;
}
for(uint i=0; i<houses.length(); i++)
{
if(houses[i].x==p.x and houses[i].y==p.y and houses[i].z==p.z and houses[i].map==p.map)
{
send_reliable(p,"there's a house here",0);
return;
}
}
file f;
f.open("maps/"+mapname+".map","wb");
f.write("mapname:"+mapname+"\r\nminx:-1\r\nmaxx:57\r\nminy:-1\r\nmaxy:52\r\nminz:0\r\nmaxz:21\r\ntile:-1:57:-1:52:0:0:0:100:hardwood7\r\nowner:"+p.name+"\r\nlitem:1\r\nsafe_card:0\r\nstarting_point:1:2:1:1:0:0\r\ndeathpoint:1:2:1:1:0:0\r\ntile:-1:0:-1:52:0:20:0:100:wallwood18\r\ntile:56:57:1:50:0:20:0:100:wallwood18\r\ntile:0:57:51:52:0:20:0:100:wallwood18\r\ntile:1:57:-1:0:0:20:0:100:wallwood18\r\ntile:31:31:31:50:0:20:0:100:wallwood18\r\ntile:0:55:30:30:0:20:0:100:wallwood18\r\ntile:41:41:1:20:0:20:0:100:wallwood18\r\ntile:20:55:21:21:0:20:0:100:wallwood18\r\ntile:14:14:14:29:0:20:0:100:wallwood18\r\ntile:1:13:14:14:0:20:0:100:wallwood18\r\ntile:20:20:1:20:0:20:0:100:wallwood18\r\ntile:1:2:0:0:0:6:0:100:wallwooddoor\r\ntile:-1:57:-1:52:21:21:0:100:wallwood18\r\ntile:20:20:10:11:0:6:0:100:wallwood2\r\ndoor:19:19:10:11:0:6:21:11:0: :700:silence.ogg:silence.ogg:door3.ogg:silence.ogg\r\ndoor:21:21:10:11:0:6:19:11:0: :700:silence.ogg:silence.ogg:door3.ogg:silence.ogg\r\ntile:48:49:21:21:0:6:0:100:wallwood2\r\nrain:none.ogg\r\ndoor:48:49:22:22:0:6:49:20:0: :70:silence.ogg:silence.ogg:door3.ogg:silence.ogg\r\ndoor:48:49:20:20:0:6:49:22:0: :700:silence.ogg:silence.ogg:door3.ogg:silence.ogg\r\ntile:43:44:30:30:0:6:0:100:wallwood2\r\ndoor:43:44:29:29:0:6:43:31:0: :700:silence.ogg:silence.ogg:door3.ogg:silence.ogg\r\ndoor:43:44:31:31:0:6:43:29:0: :700:silence.ogg:silence.ogg:door3.ogg:silence.ogg\r\ntile:14:14:25:26:0:6:0:100:wallwood2\r\ndoor:15:15:25:26:0:6:13:25:0: :1050:silence.ogg:silence.ogg:door3.ogg:doorclose67.ogg\r\ndoor:13:13:25:26:0:6:15:25:0: :1050:silence.ogg:silence.ogg:doorclose67.ogg:door3.ogg\r\nzone:-1:57:-1:52:0:21:partner_house\r\nnight:none.ogg\r\nwind:none.ogg\r\ntile:19:22:30:30:0:6:0:100:air\r\ntile:19:22:30:30:0:0:0:100:hardwood7\r\ntile:1:30:31:50:0:0:0:100:carpet2\r\ntile:42:55:1:20:0:0:0:100:carpet8\r\ntile:32:55:31:50:0:0:0:100:carpet8\r\ntile:1:13:15:29:0:0:0:100:tile4\r\ntile:21:40:1:20:0:0:0:100:carpet32\r\ntile:11:18:0:0:3:12:0:100:air\r\ntile:11:18:-1:-1:3:12:0:100:wallglass5\r\ntile:11:18:0:0:3:3:0:100:carpet310\r\ntile:56:56:23:28:3:12:0:100:air\r\ntile:57:57:23:28:3:12:0:100:wallglass5\r\ntile:56:56:23:28:3:3:0:100:carpet310\r\ntile:56:56:7:14:3:12:0:100:air\r\ntile:57:57:7:14:3:12:0:100:wallglass5\r\ntile:56:56:7:14:3:3:0:100:carpet310\r\ntile:55:55:1:4:0:2:0:100:wallsofa\r\ntile:49:54:1:4:0:0:0:100:wallcloth\r\ntile:49:54:1:4:1:1:0:100:cloth\r\ntile:55:55:1:4:3:3:0:100:synthetic\r\ntile:55:55:5:5:1:1:0:100:carpet34\r\ntile:53:56:16:20:0:10:0:100:wallbuilding\r\ntile:54:55:17:19:1:9:0:100:air\r\ntile:54:55:17:19:1:1:0:100:carpet35\r\ntile:53:55:16:20:11:11:0:100:carpet39\r\ndoor:52:52:17:19:0:10:54:18:1: :1050:silence.ogg:silence.ogg:tp39.ogg:silence.ogg\r\ndoor:54:54:17:19:1:9:52:18:0: :1050:silence.ogg:silence.ogg:tp39.ogg:silence.ogg\r\ntile:42:44:10:12:0:2:0:100:wallbuilding7\r\ntile:42:42:10:12:3:9:0:100:wallglass8\r\ntile:43:44:10:12:3:3:0:100:carpet34\r\ntile:42:42:10:12:10:10:0:100:glass3\r\ntile:46:46:11:11:0:2:0:100:wallsofa\r\ntile:46:46:11:11:3:3:0:100:synthetic\r\ntile:45:45:11:11:0:0:0:100:chair\r\ntile:45:45:11:11:1:1:0:100:carpet3\r\nzone:42:55:1:20:0:20:guest bedroom\r\nzone:0:30:31:50:0:20:living room\r\nzone:56:57:7:14:3:12:window\r\nzone:56:56:7:14:3:6:windowsill\r\nzone:19:22:29:30:0:20:near the entrance to the living room\r\nzone:19:22:30:30:0:20:entrance to the living room:trackme\r\nzone:48:55:1:5:0:0:Near the bed\r\nzone:55:55:1:4:0:6:headboard\r\nzone:55:55:5:5:1:3:Bedside shelf\r\nbed:49:54:1:4:1:3:\r\nzone:49:54:1:4:1:3:bed\r\nzone:55:55:7:14:0:3:near the window\r\nzone:52:55:15:20:0:0:Near the cupboard\r\nzone:53:56:16:20:0:11:cupboard\r\nbed:49:54:1:4:1:1\r\nzone:42:45:9:13:0:0:Near the Chest Of Drawers with a mirror\r\nzone:42:44:10:12:0:10:Chest Of Drawers with a mirror\r\nzone:45:46:11:11:0:5:Chair with back\r\nzone:52:54:17:19:0:10:door of cupboard\r\ntile:37:40:1:20:0:2:0:100:wallbuilding3\r\ntile:37:40:1:20:3:3:0:100:tile5\r\ntile:37:40:12:15:2:2:0:100:wallmetal19\r\ntile:37:40:12:15:3:3:0:100:metal18\r\ntile:38:39:13:14:2:3:0:100:air\r\ntile:38:39:13:14:2:2:0:100:bathtub3\r\ntile:37:40:6:9:0:2:0:100:wallmetal20\r\ntile:37:37:6:9:1:2:0:100:wallglass11\r\ntile:37:40:6:9:3:3:0:100:diamond\r\ntile:39:40:18:20:3:5:0:100:wallmetal20\r\ntile:38:38:18:18:3:5:0:100:walldesk3\r\ntile:38:38:19:20:3:5:0:100:wallglass11\r\ntile:38:40:18:20:6:6:0:100:tile\r\ntile:39:39:19:19:3:3:0:100:tile\r\ntile:39:39:19:19:4:4:0:100:glass6\r\ntile:25:33:0:0:3:12:0:100:air\r\ntile:25:33:-1:-1:3:12:0:100:wallglass5\r\ntile:25:33:0:0:3:3:0:100:carpet310\r\ntile:27:27:1:1:0:0:0:100:walltable\r\ntile:31:31:1:1:0:0:0:100:walltable\r\ntile:27:27:3:3:0:0:0:100:walltable\r\ntile:31:31:3:3:0:0:0:100:walltable\r\ntile:27:31:1:3:1:1:0:100:walltable\r\ntile:27:31:1:3:2:2:0:100:hardwood3\r\ntile:25:25:2:2:0:2:0:100:wallbank\r\ntile:25:25:2:2:3:3:0:100:generic\r\ntile:26:26:2:2:0:0:0:100:chair\r\ntile:26:26:2:2:1:1:0:100:bare\r\ntile:33:33:2:2:0:2:0:100:wallbank\r\ntile:33:33:2:2:3:3:0:100:generic\r\ntile:32:32:2:2:0:0:0:100:chair\r\ntile:32:32:2:2:1:1:0:100:bare\r\ntile:28:28:5:5:0:2:0:100:wallbank\r\ntile:28:28:5:5:3:3:0:100:generic\r\ntile:28:28:4:4:0:0:0:100:chair\r\ntile:28:28:4:4:1:1:0:100:bare\r\ntile:30:30:5:5:0:2:0:100:wallbank\r\ntile:30:30:5:5:3:3:0:100:generic\r\ntile:30:30:4:4:0:0:0:100:chair\r\ntile:30:30:4:4:1:1:0:100:bare\r\ntile:29:32:17:20:0:10:0:100:wallmetal19\r\ntile:29:32:17:20:11:11:0:100:tile2\r\ntile:30:31:18:19:5:5:0:100:glass7\r\ndoor:37:37:19:20:3:3:39:19:4:You can start cooking.:1050:silence.ogg:silence.ogg:dooropen18.ogg:silence.ogg\r\nautomover:39:39:19:19:3:3:37:19:3:Made:60:silence.ogg:silence.ogg:silence.ogg:silence.ogg\r\ndoor:29:32:16:16:0:10:31:18:5: :600:silence.ogg:silence.ogg:dooropen52.ogg:doorclose30.ogg\r\ndoor:30:31:18:18:5:5:31:16:0: :600:silence.ogg:silence.ogg:dooropen52.ogg:doorclose30.ogg\r\nzone:21:40:1:20:0:20:kitchen\r\nzone:25:33:-1:0:3:12:window\r\nzone:25:33:0:0:3:6:windowsill\r\nzone:36:36:1:20:0:3:Near the kitchen headset\r\nzone:37:40:1:20:0:6:kitchen set\r\nzone:37:40:6:9:0:6:kitchen stove\r\nzone:36:36:6:9:0:3:Near the kitchen stove\r\nzone:36:36:12:15:0:3:Near the kitchen sink\r\nzone:37:40:12:15:0:6:kitchen sink\r\nzone:37:40:17:20:3:3:Near Microwave\r\nzone:38:40:18:20:3:8:microwave\r\nzone:37:38:19:20:3:5:Door of Microwave\r\nzone:28:33:16:20:0:0:Near the refrigerator\r\nzone:29:32:17:20:0:11:fridge\r\nzone:29:32:16:18:0:10:door of fridge\r\nzone:27:31:1:3:0:1:under the kitchen table\r\nzone:27:31:1:3:2:5:kitchen table\r\nzone:25:26:2:2:0:5:leather chair with back\r\nzone:32:33:2:2:0:5:leather chair with back\r\nzone:28:28:4:5:0:5:leather chair with back\r\nzone:30:30:4:5:0:5:leather chair with back\r\noven:37:40:6:9:3:3\r\nwashbasin:38:39:13:14:2:2\r\ntile:39:39:14:14:2:2:0:100:water\r\ntile:21:21:1:1:0:0:0:100:debris\r\ntrashcan:21:21:1:1:0:0\r\nzone:56:57:23:28:3:12:window\r\nzone:56:56:23:28:3:6:windowsill\r\nzone:11:18:-1:0:3:12:window\r\nzone:11:18:0:0:3:6:windowsill\r\ntile:30:30:36:38:0:3:0:100:wallbody\r\ntile:29:29:36:38:0:1:0:100:wallbody\r\ntile:30:30:36:38:4:4:0:100:carpet4\r\ntile:29:29:37:37:1:1:0:100:carpet3\r\ntile:29:29:36:36:2:2:0:100:carpet4\r\ntile:29:29:38:38:2:2:0:100:carpet4\r\ntile:30:30:43:45:0:3:0:100:wallbody\r\ntile:29:29:43:45:0:1:0:100:wallbody\r\ntile:29:29:44:44:1:1:0:100:carpet3\r\ntile:29:29:43:43:2:2:0:100:carpet4\r\ntile:29:29:45:45:2:2:0:100:carpet4\r\ntile:30:30:43:45:4:4:0:100:carpet4\r\ntile:29:30:39:42:0:1:0:100:wallwood16\r\ntile:29:30:39:42:2:2:0:100:carpet34\r\ntile:0:0:36:45:3:12:0:100:air\r\ntile:-1:-1:36:45:3:12:0:100:wallglass5\r\ntile:0:0:36:45:3:3:0:100:carpet310\r\ntile:1:16:31:33:0:11:0:100:wallwood16\r\ntile:5:11:32:33:3:10:0:100:air\r\ntile:13:15:33:33:3:10:0:100:wallglass2\r\ntile:2:3:32:33:3:10:0:100:air\r\ntile:2:3:32:33:3:3:0:100:carpet34\r\ntile:2:3:32:33:5:5:0:100:carpet34\r\ntile:2:3:32:33:7:7:0:100:carpet34\r\ntile:2:3:32:33:9:9:0:100:carpet34\r\ntile:1:16:31:33:12:12:0:100:carpet39\r\ntile:5:11:31:31:3:7:0:100:wallglass7\r\ntile:5:11:32:33:3:3:0:100:carpet34\r\ntile:1:1:48:48:0:1:0:100:wallwood16\r\ntile:1:1:50:50:0:1:0:100:wallwood16\r\ntile:3:3:48:48:0:1:0:100:wallwood16\r\ntile:3:3:50:50:0:1:0:100:wallwood16\r\ntile:1:3:48:50:2:2:0:100:carpet34\r\ntile:4:12:50:50:0:3:0:100:wallbody\r\ntile:4:12:50:50:4:4:0:100:carpet4\r\ntile:4:12:48:49:0:1:0:100:wallbody\r\ntile:4:4:48:49:2:2:0:100:carpet4\r\ntile:5:11:48:49:1:1:0:100:carpet3\r\ntile:12:12:48:49:2:2:0:100:carpet4\r\ntile:17:26:51:51:3:12:0:100:air\r\ntile:17:26:52:52:3:12:0:100:wallglass5\r\ntile:17:26:51:51:3:3:0:100:carpet310\r\nzone:-1:0:36:45:3:12:window\r\nzone:0:0:36:45:3:6:windowsill\r\nzone:1:1:36:45:0:3:near the window\r\nzone:17:26:50:50:0:3:near the window\r\nzone:17:26:51:52:3:12:window\r\nzone:17:26:51:51:3:6:windowsill\r\nzone:1:17:31:34:0:12:Near Furniture slide.\r\nzone:1:16:31:33:0:13:Furniture slide\r\nzone:2:3:32:33:3:10:Shelves\r\nzone:5:11:32:32:3:7:Near the TV.\r\nzone:1:3:48:50:0:1:under the table\r\nzone:1:3:48:50:2:4:Side table.\r\nzone:4:13:47:50:0:0:Near the sofa\r\nzone:4:12:50:50:0:7:the back of the sofa\r\nzone:4:12:48:49:0:3:the armrest of the sofa\r\nzone:5:11:48:49:0:3:the seat of the sofa\r\nzone:30:30:36:45:0:6:the back of the armchair\r\nzone:29:29:36:45:0:3:the armrest of the armchair\r\nzone:29:29:37:37:0:3:the seat of the armchair\r\nzone:29:29:44:44:0:3:the seat of the armchair\r\nzone:29:30:39:42:0:6:nightstand\r\ntile:1:5:25:29:0:10:0:100:wallfurniture\r\ntile:1:5:25:29:11:11:0:100:plastic\r\ntile:2:4:26:28:0:11:0:100:air\r\ntile:2:3:26:28:0:0:0:100:wetconcrete\r\ntile:4:4:26:28:0:0:0:100:concrete23\r\ntile:5:5:26:28:0:6:0:100:wallglass11\r\ndoor:6:6:26:28:0:6:4:27:0: :70:silence.ogg:silence.ogg:door1.ogg:silence.ogg\r\ndoor:4:4:26:28:0:6:6:27:0: :700:silence.ogg:silence.ogg:door1.ogg:silence.ogg\r\ntile:5:11:15:17:0:10:0:100:wallbuilding4\r\ntile:5:11:15:17:11:11:0:100:carpet35\r\ntile:7:9:16:17:2:11:0:100:air\r\ntile:7:9:15:17:2:2:0:100:wallstone2\r\ntile:7:9:16:17:3:3:0:100:ceramic3\r\ntile:8:8:16:16:3:3:0:100:air\r\ntile:8:8:16:16:2:2:0:100:wetconcrete\r\ntile:7:9:15:15:3:9:0:100:wallglass8\r\ntile:1:1:20:20:0:2:0:100:wallstone2\r\ntile:1:1:20:20:3:3:0:100:ceramic\r\ntile:2:2:20:20:0:0:0:100:wallstone2\r\ntile:2:2:20:20:1:1:0:100:bare\r\ntile:1:1:19:19:0:0:0:100:debris\r\nzone:1:13:15:29:0:20:bathroom \r\nzone:1:6:24:29:0:0:Near the shower cabin\r\nzone:1:5:25:29:0:11:shower cabin\r\nzone:4:6:26:28:0:6:door of shower cabin:trackme\r\nzone:1:3:19:21:0:0:Near toilet bowl\r\nzone:2:2:20:20:0:2:On the toilet bowl seat:trackme\r\nzone:1:1:20:20:0:4:on the toilet cistern\r\nshower:2:3:26:28:0:6\r\nzone:4:12:15:18:0:0:Near, sink, with lockers and a mirror\r\nzone:5:11:15:17:0:11:sink, with lockers and a mirror\r\nzone:7:9:15:17:3:9:Sink with a mirror.\r\nzone:8:8:16:16:2:2:sink:trackme\r\nwashbasin:8:8:16:16:2:6\r\ntrashcan:1:1:19:19:0:0\r\nzone:1:1:19:19:0:0:trashcan :trackme\r\ntoilet:2:2:20:20:1:6\r\nzone:1:14:1:13:0:20:hallway\r\ntile:1:2:1:2:0:0:0:100:carpet5\r\nzone:1:1:1:1:0:6:exit door:trackme\r\ntile:1:10:10:13:0:11:0:100:wallwood16\r\ntile:3:5:10:10:0:11:0:100:wallglass8\r\ntile:7:9:10:10:0:11:0:100:wallglass8\r\ntile:3:9:11:12:1:10:0:100:air\r\ntile:3:9:11:12:1:1:0:100:carpet35\r\ntile:3:9:11:12:3:3:0:100:carpet35\r\ntile:3:9:11:12:5:5:0:100:carpet35\r\ntile:2:2:11:11:1:5:0:100:carpet35\r\nzone:1:11:9:13:0:0:Near the cabinet with mirror doors, for outerwear and shoes\r\nzone:1:10:10:13:0:12:the cabinet with mirror doors, for outerwear and shoes\r\ntile:1:10:10:13:12:12:0:100:carpet39\r\nzone:3:9:9:11:0:10:Mirror doors\r\ndoor:3:9:9:9:0:10:6:11:1: :1100:silence.ogg:silence.ogg:dooropen30.ogg:doorclose33.ogg\r\ndoor:3:9:11:11:1:10:6:9:0: :1100:silence.ogg:silence.ogg:dooropen30.ogg:doorclose33.ogg\r\ntile:0:2:6:9:0:11:0:100:wallwood16\r\ntile:1:2:6:9:12:12:0:100:carpet39\r\ntile:1:2:7:8:3:10:0:100:air\r\ntile:1:2:7:8:3:3:0:100:carpet35\r\ntile:1:2:7:8:5:5:0:100:carpet35\r\ntile:1:2:7:8:7:7:0:100:carpet35\r\ntile:1:2:7:8:9:9:0:100:carpet35\r\nzone:1:2:6:9:0:12:Shelves\r\ntile:1:1:3:5:0:0:0:100:wallbank\r\ntile:1:1:3:5:1:1:0:100:bare\r\nzone:1:1:3:5:0:3:Leather seat\r\nzone:11:18:1:1:0:3:near the window\r\ntile:15:55:22:29:0:0:0:100:carpet\r\nzone:19:21:10:11:0:6:Kitchen door:trackme\r\nzone:13:15:25:26:0:6:Door of the bathroom:trackme\r\nzone:48:49:20:22:0:6:door of the guest bedroom:trackme\r\nzone:55:55:23:28:0:3:near the window\r\ntile:55:55:40:45:0:2:0:100:wallsofa\r\ntile:55:55:40:45:3:3:0:100:synthetic\r\ntile:48:54:40:45:0:0:0:100:wallcloth\r\ntile:48:54:40:45:1:1:0:100:cloth\r\ntile:55:55:39:39:1:1:0:100:carpet34\r\ntile:55:55:46:46:1:1:0:100:carpet34\r\ntile:49:55:31:34:0:11:0:100:wallbuilding\r\ntile:50:54:32:33:1:10:0:100:air\r\ntile:50:54:32:33:1:1:0:100:carpet35\r\ntile:49:55:31:34:12:12:0:100:carpet39\r\ntile:53:54:32:33:3:3:0:100:carpet35\r\ntile:53:54:32:33:5:5:0:100:carpet35\r\ntile:53:54:32:33:7:7:0:100:carpet35\r\ntile:53:54:32:33:9:9:0:100:carpet35\r\ndoor:50:54:35:35:0:10:52:33:1: :1050:silence.ogg:silence.ogg:tp39.ogg:silence.ogg\r\ndoor:50:54:33:33:1:10:52:35:0: :1050:silence.ogg:silence.ogg:tp39.ogg:silence.ogg\r\ntile:35:47:51:51:3:12:0:100:air\r\ntile:35:47:52:52:3:12:0:100:wallglass5\r\ntile:35:47:51:51:3:3:0:100:carpet310\r\ntile:35:35:50:50:0:0:0:100:walltable\r\ntile:35:35:48:48:0:0:0:100:walltable\r\ntile:39:39:48:48:0:0:0:100:walltable\r\ntile:39:39:50:50:0:0:0:100:walltable\r\ntile:35:39:48:50:1:1:0:100:walltable\r\ntile:35:39:48:50:2:2:0:100:hardwood3\r\ntile:32:32:48:50:0:3:0:100:wallbody\r\ntile:33:33:48:50:0:1:0:100:wallbody\r\ntile:32:32:48:50:4:4:0:100:carpet4\r\ntile:33:33:48:48:2:2:0:100:carpet4\r\ntile:33:33:50:50:2:2:0:100:carpet4\r\ntile:33:33:49:49:1:1:0:100:carpet3\r\ntile:36:38:45:45:0:3:0:100:wallbody\r\ntile:36:38:46:46:0:1:0:100:wallbody\r\ntile:36:38:45:45:4:4:0:100:carpet4\r\ntile:36:36:46:46:2:2:0:100:carpet4\r\ntile:38:38:46:46:2:2:0:100:carpet4\r\ntile:37:37:46:46:1:1:0:100:carpet3\r\ntile:32:34:35:39:0:2:0:100:wallbuilding7\r\ntile:32:32:35:39:3:9:0:100:wallbuilding7\r\ntile:32:32:36:38:3:9:0:100:wallglass8\r\ntile:32:32:35:39:10:10:0:100:carpet316\r\ntile:33:34:35:39:3:3:0:100:carpet34\r\ntile:36:36:37:37:0:0:0:100:chair\r\ntile:36:36:37:37:1:1:0:100:carpet3\r\nzone:32:55:31:50:0:20:bedroom\r\nzone:35:47:51:52:3:12:window\r\nzone:35:47:51:51:3:6:windowsill\r\nzone:48:55:31:35:0:0:Near the cupboard\r\nzone:49:55:31:34:0:11:Cupboard with shelves\r\nzone:50:54:33:35:0:10:doors of Cupboard\r\nzone:47:55:39:46:0:0:Near the a large bed\r\nzone:55:55:40:45:0:6:headboard\r\nzone:48:54:40:45:1:3:a large bed\r\nbed:48:54:40:45:1:1\r\nzone:55:55:39:39:1:3:Bedside Shelf\r\nzone:55:55:46:46:1:3:Bedside Shelf\r\nzone:35:39:48:50:0:1:under the table\r\nzone:35:39:48:50:2:5:writing-table\r\nzone:32:32:48:50:0:6:the back of the armchair\r\nzone:33:33:48:50:0:3:the armrest of the armchair\r\nzone:33:33:49:49:0:3:the seat of the armchair\r\nzone:36:38:45:45:0:6:the back of the armchair\r\nzone:36:38:46:46:0:3:the armrest of the armchair\r\nzone:37:37:46:46:0:3:the seat of the armchair\r\nzone:32:35:34:40:0:0:Near the Chest Of Drawers with a mirror\r\nzone:32:34:35:39:0:10:chest of drawers with a mirror\r\nzone:36:36:37:37:0:3:a soft chair\r\nzone:43:44:29:31:0:6:door of bedroom:trackme\r\nsrc:-1:57:-1:52:0:21:0:100:air.ogg\r\nsrc:11:18:-1:-1:3:12:-11:100:citybirds.ogg\r\nsrc:25:33:-1:-1:3:12:-11:100:citybirds.ogg\r\nsrc:57:57:7:14:3:12:-11:100:Birds_light.ogg\r\nsrc:57:57:23:28:3:12:-11:100:Birds_light.ogg\r\nsrc:35:47:52:52:3:12:-11:100:birds97.ogg\r\nsrc:17:26:52:52:3:12:-11:100:birds97.ogg\r\nsrc:-1:-1:36:45:3:12:-11:100:birds97.ogg\r\nlitem:1\r\nclock:15:15:50:50:0:5:the time is\r\ntile:15:15:51:51:5:5:0:100:wallglass\r\nzone:15:15:50:50:0:20:clock\r\nsrc:15:15:52:52:5:5:-5:100:clock3.ogg\r\nsrc:1:14:15:29:0:20:0:100:bathroom.ogg:1\r\nsrc:1:2:-1:-1:0:6:-11:100:harbor.ogg\r\nsrc:7:7:50:50:4:4:-11:100:pur.ogg\r\nzone:7:7:50:50:4:4:Affectionate kitty\r\nsrc:37:37:49:49:2:2:-5:100:paper.ogg:1\r\ntile:37:37:49:49:2:2:0:100:paper\r\nzone:37:37:49:49:2:2:correspondence\r\ntile:38:39:2:4:1:1:0:100:carpet35\r\ndoor:36:36:2:4:0:0:38:3:1: :700:silence.ogg:silence.ogg:dooropen41.ogg:silence.ogg\r\ndoor:38:38:2:4:1:1:36:3:0: :700:silence.ogg:silence.ogg:dooropen41.ogg:silence.ogg\r\nzone:36:38:2:4:0:2:Door of kitchen headset\r\nsrc:30:31:18:19:5:5:0:100:fridge6.ogg\r\nitem_usage_restriction:0:50:0:50:0:10:conex:partner_house:beehive:small_conex:sky_racer:ford:sorento:dogan_slx:grayhound_bus:m60_tank:tank:truck:v4_by_4_jeep:dodge_charger:doom_buggy:ford_pickup_truck:mlk_mission_cruiser:muscle_car:generic_motorcycle:frog_motorcycle:ducati_street_fighter:onda_cbr_600:yamaha_r6:aprilia_v4:aprilia_rs660:ducati_diavel:yamaha_off_road:kawasaki_hipersport:kawasaki_adventure_tourer:ducati_scrumbler:bmw_off_road:motor_boat\r\nspecified_air_temperature:-1:57:-1:52:0:10:25");
f.close();
init_mapsystem();
string newid=randomstring(6);
int housecode=random(1, 100000);
spawn_house(p.x,p.y,p.z,p.map,p.name,housecode,130000,mapname,parsed[2],newid);
//send_packet(6,"playtvp "+p.x+" "+p.y+" "+p.z, p.x,p.y,p.z,maps[get_map_index(p.map)]);
p.inv_add_item("partner_house",-1);
send_reliable(p,"Your partner_house has been placed, the code to get in to your house is "+housecode+"",2);
}
else if(parsed[2]=="beehive")
{
if(can_use_item_at(p.x,p.y,p.z,maps[get_map_index(p.map)],parsed[2])==false)
{
send_reliable(p,"you can't put your "+parsed[2]+" here",2);
return;
}
string mapname="beehive_of_"+p.name+"";
if(map_exists(mapname))
{
send_reliable(p,"you already have a beehive",0);
return;
}
if(in_beehive(p)>-1)
{
send_reliable(p,"you can't put your beehive inside another one",0);
return;
}
if(in_playerstore(p)>-1)
{
send_reliable(p,"you can't put your beehive inside a store",0);
return;
}
if(is_safe(p.x,p.y,p.z,maps[get_map_index(p.map)])==true and in_house(p)<0)
{
send_reliable(p,"you can't put your beehive in safe places",0);
return;
}
if(is_travelpoint(p.x,p.y,p.z,maps[get_map_index(p.map)]))
{
send_reliable(p,"Building beehive's on travelpoints doesn't works!",2);
return;
}
if(get_tile_at(p.x,p.y,p.z,maps[get_map_index(p.map)])=="air" or get_tile_at(p.x,p.y,p.z,maps[get_map_index(p.map)])=="")
{
send_reliable(p,"can't place beehive' in the air",0);
return;
}
if(p.is_admin()==false)
{
string charfolder="chars/"+p.name;
string[] a=string_split(file_get_contents("pbmaps.svr"),"\r\n",false);
string[] a2=string_split(file_get_contents(charfolder+"/maps.usr"),"\r\n",false);
string[] a3=string_split(file_get_contents("chmaps.svr"),"\r\n",false);
int something=a.find(p.map);
int something2=a2.find(p.map);
int something3=a3.find(p.map);
if(something>-1 or something2>-1 or something3>-1)
{
send_reliable(p,"you can't put this in your map",2);
return;
}
}
for(uint i=0; i<beehives.length(); i++)
{
if(beehives[i].x==p.x and beehives[i].y==p.y and beehives[i].z==p.z and beehives[i].map==p.map)
{
send_reliable(p,"there's a beehive here",0);
return;
}
}
f.open("maps/"+mapname+".map","wb");
f.write("mapname:"+mapname+"\r\nminx:0\r\nmaxx:10\r\nminy:0\r\nmaxy:10\r\nminz:0\r\nmaxz:10\r\ntile:0:10:0:10:0:0:0:100:ledge2\r\nowner:mahdi\r\nlitem:0\r\nsafe_card:0\r\nzone:0:10:0:10:0:10:beehive\r\nsrc:0:10:0:10:0:10:0:100:beehive.ogg\r\nai:0:10:0:10:0:0:100000:1:honey_bee\r\nzone:0:0:0:0:0:10:exit path:trackme\r\nitem:0:10:0:10:0:0:900000:3:honey\r\nrain:none.ogg\r\nwind:silence.ogg\r\nnight:silence.ogg\r\ndeathpoint:0:10:0:10:0:0\r\nstarting_point:0:10:0:10:0:0\r\nitem_usage_restriction:0:10:0:10:0:10:conex:partner_house:beehive:small_conex:locker:fridge:microwave:air_conditioner:steam:fan:sky_racer:ford:sorento:dogan_slx:grayhound_bus:m60_tank:tank:truck:v4_by_4_jeep:dodge_charger:doom_buggy:ford_pickup_truck:mlk_mission_cruiser:muscle_car:generic_motorcycle:frog_motorcycle:ducati_street_fighter:onda_cbr_600:yamaha_r6:aprilia_v4:aprilia_rs660:ducati_diavel:yamaha_off_road:kawasaki_hipersport:kawasaki_adventure_tourer:ducati_scrumbler:bmw_off_road:motor_boat\r\nspecified_air_temperature:0:10:0:10:0:10:25");
f.close();
init_mapsystem();
spawn_beehive(p.x,p.y,p.z,p.map,p.name,10000,mapname);
//send_packet(6,"playtvp "+p.x+" "+p.y+" "+p.z, p.x,p.y,p.z,maps[get_map_index(p.map)]);
p.inv_add_item("beehive",-1);
send_reliable(p,"Your beehive has been placed",2);
}
else if(parsed[2]=="small_conex")
{
if(can_use_item_at(p.x,p.y,p.z,maps[get_map_index(p.map)],parsed[2])==false)
{
send_reliable(p,"you can't put your "+parsed[2]+" here",2);
return;
}
if(p.gender==0 and p.job!="salesman" or p.gender==1 and p.job!="saleswoman")
{
if(p.gender==0) send_reliable(p,"you are not a salesman",2);
else send_reliable(p,"you are not a saleswoman",2);
return;
}
if(p.contabancaria==0)
{
send_reliable(p, "You haven't bank account to do this action", 2);
return;
}
send_serverbox(p.peer_id,2,1,0,-1,"pstore2","press 1 to build a clothing store, 2 to build a weapon store, 3 to build a vehicle store, 4 to build a fastfood store, 5 to build a explosive store, 6 to build a misc store, 7 to build a medical store, 8 to build a fruit store, 9 to build a household store, 0 to build a team store, minus or - to build a jewelry");
}
else if(parsed[2]=="candle")
{
if(can_use_item_at(p.x,p.y,p.z,maps[get_map_index(p.map)],parsed[2])==false)
{
send_reliable(p,"you can't put your "+parsed[2]+" here",2);
return;
}
//send_packet(6,"playtvp "+p.x+" "+p.y+" "+p.z, p.x,p.y,p.z,maps[get_map_index(p.map)]);
spawn_candle(p.x,p.y,p.z,maps[get_map_index(p.map)],0);
p.inv_add_item("candle",-1);
}
else if(parsed[2]=="microwave")
{
if(can_use_item_at(p.x,p.y,p.z,maps[get_map_index(p.map)],parsed[2])==false)
{
send_reliable(p,"you can't put your "+parsed[2]+" here",2);
return;
}
if(in_beehive(p)>-1)
{
send_reliable(p,"you can't put a microwave inside a beehive",0);
return;
}
if(is_safe(p.x,p.y,p.z,maps[get_map_index(p.map)])==true and in_house(p)<0)
{
send_reliable(p,"you can't put your microwave in safe places",0);
return;
}
if(get_tile_at(p.x,p.y,p.z,maps[get_map_index(p.map)])=="air" or get_tile_at(p.x,p.y,p.z,maps[get_map_index(p.map)])=="")
{
send_reliable(p,"can't place microwave' in the air",0);
return;
}
if(p.is_admin()==false)
{
string charfolder="chars/"+p.name;
string[] a=string_split(file_get_contents("pbmaps.svr"),"\r\n",false);
string[] a2=string_split(file_get_contents(charfolder+"/maps.usr"),"\r\n",false);
string[] a3=string_split(file_get_contents("chmaps.svr"),"\r\n",false);
int something=a.find(p.map);
int something2=a2.find(p.map);
int something3=a3.find(p.map);
if(something>-1 or something2>-1 or something3>-1)
{
send_reliable(p,"you can't put this in your map",2);
return;
}
}
for(uint i=0; i<microwaves.length(); i++)
{
if(microwaves[i].x==p.x and microwaves[i].y==p.y and microwaves[i].z==p.z and microwaves[i].map==p.map)
{
send_reliable(p,"there's already a microwave here",0);
return;
}
}
//send_packet(6,"playtvp "+p.x+" "+p.y+" "+p.z, p.x,p.y,p.z,maps[get_map_index(p.map)]);
string newid=randomstring(6);
spawn_microwave(p.x,p.y,p.z,p.map,p.name,5000,newid);
p.inv_add_item("microwave",-1);
send_reliable(p,"Your microwave has been placed successfully",2);
}
else if(parsed[2]=="air_conditioner")
{
if(can_use_item_at(p.x,p.y,p.z,maps[get_map_index(p.map)],parsed[2])==false)
{
send_reliable(p,"you can't put your "+parsed[2]+" here",2);
return;
}
if(in_beehive(p)>-1)
{
send_reliable(p,"you can't put your air_conditioner inside a beehive",0);
return;
}
if(is_safe(p.x,p.y,p.z,maps[get_map_index(p.map)])==true and in_house(p)<0)
{
send_reliable(p,"you can't put your air_conditioner in safe places",0);
return;
}
if(get_tile_at(p.x,p.y,p.z,maps[get_map_index(p.map)])=="air" or get_tile_at(p.x,p.y,p.z,maps[get_map_index(p.map)])=="")
{
send_reliable(p,"can't place air_conditioner' in the air",0);
return;
}
if(p.is_admin()==false)
{
string charfolder="chars/"+p.name;
string[] a=string_split(file_get_contents("pbmaps.svr"),"\r\n",false);
string[] a2=string_split(file_get_contents(charfolder+"/maps.usr"),"\r\n",false);
string[] a3=string_split(file_get_contents("chmaps.svr"),"\r\n",false);
int something=a.find(p.map);
int something2=a2.find(p.map);
int something3=a3.find(p.map);
if(something>-1 or something2>-1 or something3>-1)
{
send_reliable(p,"you can't put this in your map",2);
return;
}
}
for(uint i=0; i<air_conditioners.length(); i++)
{
if(air_conditioners[i].x==p.x and air_conditioners[i].y==p.y and air_conditioners[i].z==p.z and air_conditioners[i].map==p.map)
{
send_reliable(p,"there's already air_conditioner here",0);
return;
}
}
//send_packet(6,"playtvp "+p.x+" "+p.y+" "+p.z, p.x,p.y,p.z,maps[get_map_index(p.map)]);
string newid=randomstring(6);
spawn_air_conditioner(p.x,p.y,p.z,p.map,p.name,5000,0,newid);
p.inv_add_item("air_conditioner",-1);
send_reliable(p,"Your air_conditioner has been placed successfully",2);
}
else if(parsed[2]=="steam")
{
if(can_use_item_at(p.x,p.y,p.z,maps[get_map_index(p.map)],parsed[2])==false)
{
send_reliable(p,"you can't put your "+parsed[2]+" here",2);
return;
}
if(in_beehive(p)>-1)
{
send_reliable(p,"you can't put your steam inside a beehive",0);
return;
}
if(is_safe(p.x,p.y,p.z,maps[get_map_index(p.map)])==true and in_house(p)<0)
{
send_reliable(p,"you can't put your steam in safe places",0);
return;
}
if(get_tile_at(p.x,p.y,p.z,maps[get_map_index(p.map)])=="air" or get_tile_at(p.x,p.y,p.z,maps[get_map_index(p.map)])=="")
{
send_reliable(p,"can't place steam' in the air",0);
return;
}
if(p.is_admin()==false)
{
string charfolder="chars/"+p.name;
string[] a=string_split(file_get_contents("pbmaps.svr"),"\r\n",false);
string[] a2=string_split(file_get_contents(charfolder+"/maps.usr"),"\r\n",false);
string[] a3=string_split(file_get_contents("chmaps.svr"),"\r\n",false);
int something=a.find(p.map);
int something2=a2.find(p.map);
int something3=a3.find(p.map);
if(something>-1 or something2>-1 or something3>-1)
{
send_reliable(p,"you can't put this in your map",2);
return;
}
}
for(uint i=0; i<steams.length(); i++)
{
if(steams[i].x==p.x and steams[i].y==p.y and steams[i].z==p.z and steams[i].map==p.map)
{
send_reliable(p,"there's already steam here",0);
return;
}
}
//send_packet(6,"playtvp "+p.x+" "+p.y+" "+p.z, p.x,p.y,p.z,maps[get_map_index(p.map)]);
string newid=randomstring(6);
spawn_steam(p.x,p.y,p.z,p.map,p.name,5000,0,newid);
p.inv_add_item("steam",-1);
send_reliable(p,"Your steam has been placed successfully",2);
}
else if(parsed[2]=="fan")
{
if(can_use_item_at(p.x,p.y,p.z,maps[get_map_index(p.map)],parsed[2])==false)
{
send_reliable(p,"you can't put your "+parsed[2]+" here",2);
return;
}
if(in_beehive(p)>-1)
{
send_reliable(p,"you can't put your fan inside a beehive",0);
return;
}
if(is_safe(p.x,p.y,p.z,maps[get_map_index(p.map)])==true and in_house(p)<0)
{
send_reliable(p,"you can't put your fan in safe places",0);
return;
}
if(get_tile_at(p.x,p.y,p.z,maps[get_map_index(p.map)])=="air" or get_tile_at(p.x,p.y,p.z,maps[get_map_index(p.map)])=="")
{
send_reliable(p,"can't place fan' in the air",0);
return;
}
if(p.is_admin()==false)
{
string charfolder="chars/"+p.name;
string[] a=string_split(file_get_contents("pbmaps.svr"),"\r\n",false);
string[] a2=string_split(file_get_contents(charfolder+"/maps.usr"),"\r\n",false);
string[] a3=string_split(file_get_contents("chmaps.svr"),"\r\n",false);
int something=a.find(p.map);
int something2=a2.find(p.map);
int something3=a3.find(p.map);
if(something>-1 or something2>-1 or something3>-1)
{
send_reliable(p,"you can't put this in your map",2);
return;
}
}
for(uint i=0; i<fans.length(); i++)
{
if(fans[i].x==p.x and fans[i].y==p.y and fans[i].z==p.z and fans[i].map==p.map)
{
send_reliable(p,"there's already fan here",0);
return;
}
}
//send_packet(6,"playtvp "+p.x+" "+p.y+" "+p.z, p.x,p.y,p.z,maps[get_map_index(p.map)]);
string newid=randomstring(6);
spawn_fan(p.x,p.y,p.z,p.map,p.name,5000,0,newid);
p.inv_add_item("fan",-1);
send_reliable(p,"Your fan has been placed successfully",2);
}
else if(starter_exist_on(p.x,p.y,p.z,maps[get_map_index(p.map)])==true and parsed[2]=="wood")
{
p.inv_add_item(parsed[2],0-1);
//send_packet(6,"playtvp "+p.x+" "+p.y+" "+p.z, p.x,p.y,p.z,maps[get_map_index(p.map)]);
send_packet(6,"play fireburn"+random(1,5)+".ogg "+p.x+" "+p.y+" "+p.z, p.x,p.y,p.z,maps[get_map_index(p.map)]);
for(uint i=0;i<fire_starters.length();i++)
{
fire_starters[i].health+=random(5,10);
}
}
else if(starter_exist_on(p.x,p.y,p.z,maps[get_map_index(p.map)])==true and parsed[2]!="wood")
{
send_packet(6,"play firehit.ogg "+p.x+" "+p.y+" "+p.z, p.x,p.y,p.z,maps[get_map_index(p.map)]);
//send_packet(6,"playtvp "+p.x+" "+p.y+" "+p.z, p.x,p.y,p.z,maps[get_map_index(p.map)]);
p.inv_add_item(parsed[2],0-1);
for(uint i=0;i<fire_starters.length();i++)
{
fire_starters[i].health-=random(5,10);
}
}
else if(parsed[2]=="ball")
{
p.inv_add_item(parsed[2],-string_to_number(amount[0]));
//send_packet(6,"playtvp "+p.x+" "+p.y+" "+p.z, p.x,p.y,p.z,maps[get_map_index(p.map)]);
spawn_silenceobj(p.x,p.y,p.z,maps[get_map_index(p.map)],parsed[2],string_to_number(amount[0]));
send_reliable(p, "hempty "+parsed[2], 0);
}
else
{
p.inv_add_item(parsed[2],-string_to_number(amount[0]));
//send_packet(6,"playtvp "+p.x+" "+p.y+" "+p.z, p.x,p.y,p.z,maps[get_map_index(p.map)]);
spawn_obj(p.x,p.y,p.z,maps[get_map_index(p.map)],parsed[2],string_to_number(amount[0]));
send_reliable(p, "hempty "+parsed[2], 0);
}
}
else
{
double amount=string_to_number(parsed[1]);
if(amount>p.inv_item_number(parsed[2]) or amount<0)
{
send_reliable(p,"You don't have that many",2);
return;
}
if(auction==true and auctionwho==p.name and auctionitem==parsed[2] or auction==true and auctionwho==p.name and auctioncurrency==parsed[2])
{
send_reliable(p,"you can't delete "+parsed[2]+" while putting it in auction",2);
return;
}
if(auction==true and auctionwho2==p.name)
{
send_reliable(p,"you can't do this while bidding",2);
return;
}
if(is_trashcan(p.x,p.y,p.z,maps[get_map_index(p.map)]))
{
p.inv_add_item(parsed[2],-amount);
send_packet(6,"play gethammock.ogg "+p.x+" "+p.y+" "+p.z, p.x,p.y,p.z,maps[get_map_index(p.map)]);
send_reliable(p, "hempty "+parsed[2], 0);
return;
}
string[] a=string_split(file_get_contents("notadg.svr"),"\r\n",false);
int something=a.find(parsed[2]);
if(something>-1)
{
send_reliable(p,"You can't delete "+parsed[2]+"",2);
return;
}
if(parsed[2]=="locker")
{
if(can_use_item_at(p.x,p.y,p.z,maps[get_map_index(p.map)],parsed[2])==false)
{
send_reliable(p,"you can't put your "+parsed[2]+" here",2);
return;
}
if(in_beehive(p)>-1)
{
send_reliable(p,"you can't place this locker inside a beehive",0);
return;
}
if(in_playerstore(p)>-1)
{
send_reliable(p,"you can't place this locker inside a store",0);
return;
}
if(is_safe(p.x,p.y,p.z,maps[get_map_index(p.map)])==true and in_house(p)<0)
{
send_reliable(p,"you can't put your locker in safe places",0);
return;
}
if(is_travelpoint(p.x,p.y,p.z,maps[get_map_index(p.map)]))
{
send_reliable(p,"Building "+parsed[2]+"'s on travelpoints doesn't works!",2);
return;
}
if(get_tile_at(p.x,p.y,p.z,maps[get_map_index(p.map)])=="air" or get_tile_at(p.x,p.y,p.z,maps[get_map_index(p.map)])=="")
{
send_reliable(p,"can't place "+parsed[2]+"'s in the air",0);
return;
}
if(p.is_admin()==false)
{
string charfolder="chars/"+p.name;
string[] a=string_split(file_get_contents("pbmaps.svr"),"\r\n",false);
string[] a2=string_split(file_get_contents(charfolder+"/maps.usr"),"\r\n",false);
string[] a3=string_split(file_get_contents("chmaps.svr"),"\r\n",false);
int something=a.find(p.map);
int something2=a2.find(p.map);
int something3=a3.find(p.map);
if(something>-1 or something2>-1 or something3>-1)
{
send_reliable(p,"you can't put this in your map",2);
return;
}
}
for(uint i=0; i<lockers.length(); i++)
{
if(get_locker_at(p.x,p.y,p.z,maps[get_map_index(p.map)])>-1)
{
send_reliable(p,"there's a locker here",0);
return;
}
}
//send_packet(6,"playtvp "+p.x+" "+p.y+" "+p.z, p.x,p.y,p.z,maps[get_map_index(p.map)]);
p.build_locker();
p.inv_add_item("locker",-1);
}
else if(parsed[2]=="fridge")
{
if(can_use_item_at(p.x,p.y,p.z,maps[get_map_index(p.map)],parsed[2])==false)
{
send_reliable(p,"you can't put your "+parsed[2]+" here",2);
return;
}
if(in_beehive(p)>-1)
{
send_reliable(p,"you can't place this fridge inside a beehive",0);
return;
}
if(is_safe(p.x,p.y,p.z,maps[get_map_index(p.map)])==true and in_house(p)<0)
{
send_reliable(p,"you can't put your fridge in safe places",0);
return;
}
if(is_travelpoint(p.x,p.y,p.z,maps[get_map_index(p.map)]))
{
send_reliable(p,"Building "+parsed[2]+"'s on travelpoints doesn't works!",2);
return;
}
if(get_tile_at(p.x,p.y,p.z,maps[get_map_index(p.map)])=="air" or get_tile_at(p.x,p.y,p.z,maps[get_map_index(p.map)])=="")
{
send_reliable(p,"can't place "+parsed[2]+"'s in the air",0);
return;
}
if(p.is_admin()==false)
{
string charfolder="chars/"+p.name;
string[] a=string_split(file_get_contents("pbmaps.svr"),"\r\n",false);
string[] a2=string_split(file_get_contents(charfolder+"/maps.usr"),"\r\n",false);
string[] a3=string_split(file_get_contents("chmaps.svr"),"\r\n",false);
int something=a.find(p.map);
int something2=a2.find(p.map);
int something3=a3.find(p.map);
if(something>-1 or something2>-1 or something3>-1)
{
send_reliable(p,"you can't put this in your map",2);
return;
}
}
for(uint i=0; i<fridges.length(); i++)
{
if(get_fridge_at(p.x,p.y,p.z,maps[get_map_index(p.map)])>-1)
{
send_reliable(p,"there's a fridge here",0);
return;
}
}
//send_packet(6,"playtvp "+p.x+" "+p.y+" "+p.z, p.x,p.y,p.z,maps[get_map_index(p.map)]);
p.build_fridge();
p.inv_add_item("fridge",-1);
}
else if(parsed[2]=="conex")
{
if(can_use_item_at(p.x,p.y,p.z,maps[get_map_index(p.map)],parsed[2])==false)
{
send_reliable(p,"you can't put your "+parsed[2]+" here",2);
return;
}
string mapname="house_of_"+p.name+"";
if(map_exists(mapname))
{
send_reliable(p,"you already have a house",0);
return;
}
if(in_house(p)>-1)
{
send_reliable(p,"you can't put this house inside another one",0);
return;
}
if(in_beehive(p)>-1)
{
send_reliable(p,"you can't put this house inside a beehive",0);
return;
}
if(in_playerstore(p)>-1)
{
send_reliable(p,"you can't put your house inside a store",0);
return;
}
if(p.is_admin()==false)
{
string charfolder="chars/"+p.name;
string[] a=string_split(file_get_contents("pbmaps.svr"),"\r\n",false);
string[] a2=string_split(file_get_contents(charfolder+"/maps.usr"),"\r\n",false);
string[] a3=string_split(file_get_contents("chmaps.svr"),"\r\n",false);
int something=a.find(p.map);
int something2=a2.find(p.map);
int something3=a3.find(p.map);
if(something>-1 or something2>-1 or something3>-1)
{
send_reliable(p,"you can't put this in your map",2);
return;
}
}
if(is_safe(p.x,p.y,p.z,maps[get_map_index(p.map)])==true)
{
send_reliable(p,"you can't put your conex in safe places",0);
return;
}
if(is_travelpoint(p.x,p.y,p.z,maps[get_map_index(p.map)]))
{
send_reliable(p,"Building "+parsed[2]+"'s on travelpoints doesn't works!",2);
return;
}
if(get_tile_at(p.x,p.y,p.z,maps[get_map_index(p.map)])=="air" or get_tile_at(p.x,p.y,p.z,maps[get_map_index(p.map)])=="")
{
send_reliable(p,"can't place "+parsed[2]+"'s in the air",0);
return;
}
for(uint i=0; i<houses.length(); i++)
{
if(houses[i].x==p.x and houses[i].y==p.y and houses[i].z==p.z and houses[i].map==p.map)
{
send_reliable(p,"there's a house here",0);
return;
}
}
file f;
f.open("maps/"+mapname+".map","wb");
f.write("mapname:"+mapname+"\r\nminx:0\r\nmaxx:50\r\nminy:0\r\nmaxy:50\r\nminz:0\r\nmaxz:10\r\ntile:0:50:0:50:0:0:0:100:carpet3\r\nowner:"+p.name+"\r\nlitem:0\r\nsafe_card:0\r\nstarting_point:1:5:1:5:0:0\r\ndeathpoint:1:5:1:5:0:0\r\nsrc:0:50:0:50:0:10:0:100:calm.ogg\r\nzone:0:50:0:50:0:10:conex\r\ntile:0:50:0:50:10:10:0:100:wallwoodpile\r\ntile:0:50:0:0:0:10:0:100:wallwood16\r\ntile:0:0:1:49:0:10:0:100:wallwood16\r\ntile:50:50:1:49:0:10:0:100:wallwood16\r\ntile:0:50:50:50:0:10:0:100:wallwood16\r\nsafezone:0:50:0:50:0:10\r\ntile:40:40:0:10:0:10:0:100:wallwood16\r\ntile:40:50:10:10:0:10:wallwood16:0:100:0:100\r\ntile:41:49:1:9:0:0:0:100:carpet38\r\nzone:41:49:1:9:0:10:bathroom\r\ntile:45:47:3:5:0:0:0:100:sewer\r\nzone:45:47:3:5:0:10:toilet:trackme\r\nzone:49:49:9:9:0:10:shower:trackme\r\nshower:49:49:9:9:0:0\r\ntoilet:45:47:3:5:0:0\r\nwashbasin:41:41:9:9:0:0\r\nzone:41:41:9:9:0:10:washbasin:trackme\r\nsrc:41:49:1:9:0:10:0:100:bathroom.ogg\r\ndoor:39:39:1:1:0:0:41:1:0: :750:doorsnd7.ogg:silence.ogg:tp37.ogg:tp38.ogg\r\ndoor:41:41:1:1:0:0:39:1:0: :750:silence.ogg:silence.ogg:tp37.ogg:tp36.ogg\r\nzone:39:41:1:1:0:10:bathroom door:trackme\r\ntile:30:49:30:30:0:10:0:100:wallwood16\r\ntile:30:30:30:49:0:10:0:100:wallwood16\r\ntile:30:50:50:50:0:10:0:100:wallwood16\r\ntile:50:50:30:50:0:10:0:100:wallwood16\r\ntile:31:49:31:49:0:0:0:100:concrete20\r\nzone:31:49:31:49:0:10:kitchen\r\nsrc:49:49:49:49:0:10:0:100:oven.ogg\r\noven:49:49:49:49:0:10:trackme\r\nzone:36:36:49:49:0:10:sink:trackme\r\nwashbasin:36:36:49:49:0:0\r\ntile:36:36:49:49:0:0:0:100:water5\r\nzone:31:31:49:49:0:10:fridge:trackme\r\ndoor:31:31:29:29:0:0:31:31:0: :550:door1s.ogg:silence.ogg:tp4.ogg:tp5.ogg\r\ndoor:31:31:31:31:0:0:31:29:0: :550:silence.ogg:silence.ogg:tp4.ogg:tp5.ogg\r\nzone:31:31:29:31:0:10:kitchen door:trackme\r\nzone:38:43:36:41:0:10:table:trackme\r\ntile:38:43:36:41:0:0:0:100:carpet314\r\ntile:44:44:40:40:0:0:0:100:chair\r\ntile:40:40:35:35:0:0:0:100:chair\r\ntile:37:37:39:39:0:0:0:100:chair\r\ntile:40:40:42:42:0:0:0:100:chair\r\nzone:44:44:40:40:0:10:chair\r\nzone:40:40:35:35:0:10:chair\r\nzone:37:37:39:39:0:10:chair\r\nzone:40:40:42:42:0:10:chair\r\nzone:1:1:1:1:0:10:exit door:trackme\r\ntile:0:15:35:49:0:0:0:100:carpet2\r\nrain:telha2.ogg\r\nwind:silence.ogg\r\nnight:silence.ogg\r\ntile:1:16:34:34:0:10:0:100:wallwood16\r\ntile:16:16:35:49:0:10:0:100:wallwood16\r\nzone:1:15:35:49:0:10:bedroom\r\ntile:0:0:35:49:0:10:0:100:wallwood16\r\nzone:1:1:33:35:0:10:bedroom door:trackme\r\ndoor:1:1:33:33:0:0:1:35:0: :660:door1s.ogg:silence.ogg:entering_house3.ogg:exiting_house3.ogg\r\ndoor:1:1:35:35:0:0:1:33:0: :660:silence.ogg:silence.ogg:entering_house3.ogg:exiting_house3.ogg\r\nbed:1:1:49:49:0:10\r\nzone:1:1:49:49:0:0:bed:trackme\r\ntile:1:1:49:49:0:0:0:100:cloth\r\nitem_usage_restriction:0:50:0:50:0:10:conex:partner_house:beehive:small_conex:sky_racer:ford:sorento:dogan_slx:grayhound_bus:m60_tank:tank:truck:v4_by_4_jeep:dodge_charger:doom_buggy:ford_pickup_truck:mlk_mission_cruiser:muscle_car:generic_motorcycle:frog_motorcycle:ducati_street_fighter:onda_cbr_600:yamaha_r6:aprilia_v4:aprilia_rs660:ducati_diavel:yamaha_off_road:kawasaki_hipersport:kawasaki_adventure_tourer:ducati_scrumbler:bmw_off_road:motor_boat");
f.close();
init_mapsystem();
string newid=randomstring(6);
int housecode=random(1, 10000);
spawn_house(p.x,p.y,p.z,p.map,p.name,housecode,50000,mapname,parsed[2],newid);
//send_packet(6,"playtvp "+p.x+" "+p.y+" "+p.z, p.x,p.y,p.z,maps[get_map_index(p.map)]);
p.inv_add_item("conex",-1);
send_reliable(p,"Your conex has been placed, the code to get in to your house is "+housecode+"",2);
}
else if(parsed[2]=="partner_house")
{
if(p.partner=="")
{
send_reliable(p,"you can't put your "+parsed[2]+" here when your single",2);
return;
}
if(can_use_item_at(p.x,p.y,p.z,maps[get_map_index(p.map)],parsed[2])==false)
{
send_reliable(p,"you can't put your "+parsed[2]+" here",2);
return;
}
string mapname="house_of_"+p.name+"";
if(map_exists(mapname))
{
send_reliable(p,"you already have a house",0);
return;
}
if(in_house(p)>-1)
{
send_reliable(p,"you can't put this house inside another one",0);
return;
}
if(in_beehive(p)>-1)
{
send_reliable(p,"you can't put this house inside a beehive",0);
return;
}
if(in_playerstore(p)>-1)
{
send_reliable(p,"you can't put your house inside a store",0);
return;
}
if(p.is_admin()==false)
{
string charfolder="chars/"+p.name;
string[] a=string_split(file_get_contents("pbmaps.svr"),"\r\n",false);
string[] a2=string_split(file_get_contents(charfolder+"/maps.usr"),"\r\n",false);
string[] a3=string_split(file_get_contents("chmaps.svr"),"\r\n",false);
int something=a.find(p.map);
int something2=a2.find(p.map);
int something3=a3.find(p.map);
if(something>-1 or something2>-1 or something3>-1)
{
send_reliable(p,"you can't put this in your map",2);
return;
}
}
if(is_safe(p.x,p.y,p.z,maps[get_map_index(p.map)])==true)
{
send_reliable(p,"you can't put your partner_house in safe places",0);
return;
}
if(is_travelpoint(p.x,p.y,p.z,maps[get_map_index(p.map)]))
{
send_reliable(p,"Building "+parsed[2]+"'s on travelpoints doesn't works!",2);
return;
}
if(get_tile_at(p.x,p.y,p.z,maps[get_map_index(p.map)])=="air" or get_tile_at(p.x,p.y,p.z,maps[get_map_index(p.map)])=="")
{
send_reliable(p,"can't place "+parsed[2]+"'s in the air",0);
return;
}
for(uint i=0; i<houses.length(); i++)
{
if(houses[i].x==p.x and houses[i].y==p.y and houses[i].z==p.z and houses[i].map==p.map)
{
send_reliable(p,"there's a house here",0);
return;
}
}
file f;
f.open("maps/"+mapname+".map","wb");
f.write("mapname:"+mapname+"\r\nminx:-1\r\nmaxx:57\r\nminy:-1\r\nmaxy:52\r\nminz:0\r\nmaxz:21\r\ntile:-1:57:-1:52:0:0:0:100:hardwood7\r\nowner:"+p.name+"\r\nlitem:1\r\nsafe_card:0\r\nstarting_point:1:2:1:1:0:0\r\ndeathpoint:1:2:1:1:0:0\r\ntile:-1:0:-1:52:0:20:0:100:wallwood18\r\ntile:56:57:1:50:0:20:0:100:wallwood18\r\ntile:0:57:51:52:0:20:0:100:wallwood18\r\ntile:1:57:-1:0:0:20:0:100:wallwood18\r\ntile:31:31:31:50:0:20:0:100:wallwood18\r\ntile:0:55:30:30:0:20:0:100:wallwood18\r\ntile:41:41:1:20:0:20:0:100:wallwood18\r\ntile:20:55:21:21:0:20:0:100:wallwood18\r\ntile:14:14:14:29:0:20:0:100:wallwood18\r\ntile:1:13:14:14:0:20:0:100:wallwood18\r\ntile:20:20:1:20:0:20:0:100:wallwood18\r\ntile:1:2:0:0:0:6:0:100:wallwooddoor\r\ntile:-1:57:-1:52:21:21:0:100:wallwood18\r\ntile:20:20:10:11:0:6:0:100:wallwood2\r\ndoor:19:19:10:11:0:6:21:11:0: :700:silence.ogg:silence.ogg:door3.ogg:silence.ogg\r\ndoor:21:21:10:11:0:6:19:11:0: :700:silence.ogg:silence.ogg:door3.ogg:silence.ogg\r\ntile:48:49:21:21:0:6:0:100:wallwood2\r\nrain:none.ogg\r\ndoor:48:49:22:22:0:6:49:20:0: :70:silence.ogg:silence.ogg:door3.ogg:silence.ogg\r\ndoor:48:49:20:20:0:6:49:22:0: :700:silence.ogg:silence.ogg:door3.ogg:silence.ogg\r\ntile:43:44:30:30:0:6:0:100:wallwood2\r\ndoor:43:44:29:29:0:6:43:31:0: :700:silence.ogg:silence.ogg:door3.ogg:silence.ogg\r\ndoor:43:44:31:31:0:6:43:29:0: :700:silence.ogg:silence.ogg:door3.ogg:silence.ogg\r\ntile:14:14:25:26:0:6:0:100:wallwood2\r\ndoor:15:15:25:26:0:6:13:25:0: :1050:silence.ogg:silence.ogg:door3.ogg:doorclose67.ogg\r\ndoor:13:13:25:26:0:6:15:25:0: :1050:silence.ogg:silence.ogg:doorclose67.ogg:door3.ogg\r\nzone:-1:57:-1:52:0:21:partner_house\r\nnight:none.ogg\r\nwind:none.ogg\r\ntile:19:22:30:30:0:6:0:100:air\r\ntile:19:22:30:30:0:0:0:100:hardwood7\r\ntile:1:30:31:50:0:0:0:100:carpet2\r\ntile:42:55:1:20:0:0:0:100:carpet8\r\ntile:32:55:31:50:0:0:0:100:carpet8\r\ntile:1:13:15:29:0:0:0:100:tile4\r\ntile:21:40:1:20:0:0:0:100:carpet32\r\ntile:11:18:0:0:3:12:0:100:air\r\ntile:11:18:-1:-1:3:12:0:100:wallglass5\r\ntile:11:18:0:0:3:3:0:100:carpet310\r\ntile:56:56:23:28:3:12:0:100:air\r\ntile:57:57:23:28:3:12:0:100:wallglass5\r\ntile:56:56:23:28:3:3:0:100:carpet310\r\ntile:56:56:7:14:3:12:0:100:air\r\ntile:57:57:7:14:3:12:0:100:wallglass5\r\ntile:56:56:7:14:3:3:0:100:carpet310\r\ntile:55:55:1:4:0:2:0:100:wallsofa\r\ntile:49:54:1:4:0:0:0:100:wallcloth\r\ntile:49:54:1:4:1:1:0:100:cloth\r\ntile:55:55:1:4:3:3:0:100:synthetic\r\ntile:55:55:5:5:1:1:0:100:carpet34\r\ntile:53:56:16:20:0:10:0:100:wallbuilding\r\ntile:54:55:17:19:1:9:0:100:air\r\ntile:54:55:17:19:1:1:0:100:carpet35\r\ntile:53:55:16:20:11:11:0:100:carpet39\r\ndoor:52:52:17:19:0:10:54:18:1: :1050:silence.ogg:silence.ogg:tp39.ogg:silence.ogg\r\ndoor:54:54:17:19:1:9:52:18:0: :1050:silence.ogg:silence.ogg:tp39.ogg:silence.ogg\r\ntile:42:44:10:12:0:2:0:100:wallbuilding7\r\ntile:42:42:10:12:3:9:0:100:wallglass8\r\ntile:43:44:10:12:3:3:0:100:carpet34\r\ntile:42:42:10:12:10:10:0:100:glass3\r\ntile:46:46:11:11:0:2:0:100:wallsofa\r\ntile:46:46:11:11:3:3:0:100:synthetic\r\ntile:45:45:11:11:0:0:0:100:chair\r\ntile:45:45:11:11:1:1:0:100:carpet3\r\nzone:42:55:1:20:0:20:guest bedroom\r\nzone:0:30:31:50:0:20:living room\r\nzone:56:57:7:14:3:12:window\r\nzone:56:56:7:14:3:6:windowsill\r\nzone:19:22:29:30:0:20:near the entrance to the living room\r\nzone:19:22:30:30:0:20:entrance to the living room:trackme\r\nzone:48:55:1:5:0:0:Near the bed\r\nzone:55:55:1:4:0:6:headboard\r\nzone:55:55:5:5:1:3:Bedside shelf\r\nbed:49:54:1:4:1:3:\r\nzone:49:54:1:4:1:3:bed\r\nzone:55:55:7:14:0:3:near the window\r\nzone:52:55:15:20:0:0:Near the cupboard\r\nzone:53:56:16:20:0:11:cupboard\r\nbed:49:54:1:4:1:1\r\nzone:42:45:9:13:0:0:Near the Chest Of Drawers with a mirror\r\nzone:42:44:10:12:0:10:Chest Of Drawers with a mirror\r\nzone:45:46:11:11:0:5:Chair with back\r\nzone:52:54:17:19:0:10:door of cupboard\r\ntile:37:40:1:20:0:2:0:100:wallbuilding3\r\ntile:37:40:1:20:3:3:0:100:tile5\r\ntile:37:40:12:15:2:2:0:100:wallmetal19\r\ntile:37:40:12:15:3:3:0:100:metal18\r\ntile:38:39:13:14:2:3:0:100:air\r\ntile:38:39:13:14:2:2:0:100:bathtub3\r\ntile:37:40:6:9:0:2:0:100:wallmetal20\r\ntile:37:37:6:9:1:2:0:100:wallglass11\r\ntile:37:40:6:9:3:3:0:100:diamond\r\ntile:39:40:18:20:3:5:0:100:wallmetal20\r\ntile:38:38:18:18:3:5:0:100:walldesk3\r\ntile:38:38:19:20:3:5:0:100:wallglass11\r\ntile:38:40:18:20:6:6:0:100:tile\r\ntile:39:39:19:19:3:3:0:100:tile\r\ntile:39:39:19:19:4:4:0:100:glass6\r\ntile:25:33:0:0:3:12:0:100:air\r\ntile:25:33:-1:-1:3:12:0:100:wallglass5\r\ntile:25:33:0:0:3:3:0:100:carpet310\r\ntile:27:27:1:1:0:0:0:100:walltable\r\ntile:31:31:1:1:0:0:0:100:walltable\r\ntile:27:27:3:3:0:0:0:100:walltable\r\ntile:31:31:3:3:0:0:0:100:walltable\r\ntile:27:31:1:3:1:1:0:100:walltable\r\ntile:27:31:1:3:2:2:0:100:hardwood3\r\ntile:25:25:2:2:0:2:0:100:wallbank\r\ntile:25:25:2:2:3:3:0:100:generic\r\ntile:26:26:2:2:0:0:0:100:chair\r\ntile:26:26:2:2:1:1:0:100:bare\r\ntile:33:33:2:2:0:2:0:100:wallbank\r\ntile:33:33:2:2:3:3:0:100:generic\r\ntile:32:32:2:2:0:0:0:100:chair\r\ntile:32:32:2:2:1:1:0:100:bare\r\ntile:28:28:5:5:0:2:0:100:wallbank\r\ntile:28:28:5:5:3:3:0:100:generic\r\ntile:28:28:4:4:0:0:0:100:chair\r\ntile:28:28:4:4:1:1:0:100:bare\r\ntile:30:30:5:5:0:2:0:100:wallbank\r\ntile:30:30:5:5:3:3:0:100:generic\r\ntile:30:30:4:4:0:0:0:100:chair\r\ntile:30:30:4:4:1:1:0:100:bare\r\ntile:29:32:17:20:0:10:0:100:wallmetal19\r\ntile:29:32:17:20:11:11:0:100:tile2\r\ntile:30:31:18:19:5:5:0:100:glass7\r\ndoor:37:37:19:20:3:3:39:19:4:You can start cooking.:1050:silence.ogg:silence.ogg:dooropen18.ogg:silence.ogg\r\nautomover:39:39:19:19:3:3:37:19:3:Made:60:silence.ogg:silence.ogg:silence.ogg:silence.ogg\r\ndoor:29:32:16:16:0:10:31:18:5: :600:silence.ogg:silence.ogg:dooropen52.ogg:doorclose30.ogg\r\ndoor:30:31:18:18:5:5:31:16:0: :600:silence.ogg:silence.ogg:dooropen52.ogg:doorclose30.ogg\r\nzone:21:40:1:20:0:20:kitchen\r\nzone:25:33:-1:0:3:12:window\r\nzone:25:33:0:0:3:6:windowsill\r\nzone:36:36:1:20:0:3:Near the kitchen headset\r\nzone:37:40:1:20:0:6:kitchen set\r\nzone:37:40:6:9:0:6:kitchen stove\r\nzone:36:36:6:9:0:3:Near the kitchen stove\r\nzone:36:36:12:15:0:3:Near the kitchen sink\r\nzone:37:40:12:15:0:6:kitchen sink\r\nzone:37:40:17:20:3:3:Near Microwave\r\nzone:38:40:18:20:3:8:microwave\r\nzone:37:38:19:20:3:5:Door of Microwave\r\nzone:28:33:16:20:0:0:Near the refrigerator\r\nzone:29:32:17:20:0:11:fridge\r\nzone:29:32:16:18:0:10:door of fridge\r\nzone:27:31:1:3:0:1:under the kitchen table\r\nzone:27:31:1:3:2:5:kitchen table\r\nzone:25:26:2:2:0:5:leather chair with back\r\nzone:32:33:2:2:0:5:leather chair with back\r\nzone:28:28:4:5:0:5:leather chair with back\r\nzone:30:30:4:5:0:5:leather chair with back\r\noven:37:40:6:9:3:3\r\nwashbasin:38:39:13:14:2:2\r\ntile:39:39:14:14:2:2:0:100:water\r\ntile:21:21:1:1:0:0:0:100:debris\r\ntrashcan:21:21:1:1:0:0\r\nzone:56:57:23:28:3:12:window\r\nzone:56:56:23:28:3:6:windowsill\r\nzone:11:18:-1:0:3:12:window\r\nzone:11:18:0:0:3:6:windowsill\r\ntile:30:30:36:38:0:3:0:100:wallbody\r\ntile:29:29:36:38:0:1:0:100:wallbody\r\ntile:30:30:36:38:4:4:0:100:carpet4\r\ntile:29:29:37:37:1:1:0:100:carpet3\r\ntile:29:29:36:36:2:2:0:100:carpet4\r\ntile:29:29:38:38:2:2:0:100:carpet4\r\ntile:30:30:43:45:0:3:0:100:wallbody\r\ntile:29:29:43:45:0:1:0:100:wallbody\r\ntile:29:29:44:44:1:1:0:100:carpet3\r\ntile:29:29:43:43:2:2:0:100:carpet4\r\ntile:29:29:45:45:2:2:0:100:carpet4\r\ntile:30:30:43:45:4:4:0:100:carpet4\r\ntile:29:30:39:42:0:1:0:100:wallwood16\r\ntile:29:30:39:42:2:2:0:100:carpet34\r\ntile:0:0:36:45:3:12:0:100:air\r\ntile:-1:-1:36:45:3:12:0:100:wallglass5\r\ntile:0:0:36:45:3:3:0:100:carpet310\r\ntile:1:16:31:33:0:11:0:100:wallwood16\r\ntile:5:11:32:33:3:10:0:100:air\r\ntile:13:15:33:33:3:10:0:100:wallglass2\r\ntile:2:3:32:33:3:10:0:100:air\r\ntile:2:3:32:33:3:3:0:100:carpet34\r\ntile:2:3:32:33:5:5:0:100:carpet34\r\ntile:2:3:32:33:7:7:0:100:carpet34\r\ntile:2:3:32:33:9:9:0:100:carpet34\r\ntile:1:16:31:33:12:12:0:100:carpet39\r\ntile:5:11:31:31:3:7:0:100:wallglass7\r\ntile:5:11:32:33:3:3:0:100:carpet34\r\ntile:1:1:48:48:0:1:0:100:wallwood16\r\ntile:1:1:50:50:0:1:0:100:wallwood16\r\ntile:3:3:48:48:0:1:0:100:wallwood16\r\ntile:3:3:50:50:0:1:0:100:wallwood16\r\ntile:1:3:48:50:2:2:0:100:carpet34\r\ntile:4:12:50:50:0:3:0:100:wallbody\r\ntile:4:12:50:50:4:4:0:100:carpet4\r\ntile:4:12:48:49:0:1:0:100:wallbody\r\ntile:4:4:48:49:2:2:0:100:carpet4\r\ntile:5:11:48:49:1:1:0:100:carpet3\r\ntile:12:12:48:49:2:2:0:100:carpet4\r\ntile:17:26:51:51:3:12:0:100:air\r\ntile:17:26:52:52:3:12:0:100:wallglass5\r\ntile:17:26:51:51:3:3:0:100:carpet310\r\nzone:-1:0:36:45:3:12:window\r\nzone:0:0:36:45:3:6:windowsill\r\nzone:1:1:36:45:0:3:near the window\r\nzone:17:26:50:50:0:3:near the window\r\nzone:17:26:51:52:3:12:window\r\nzone:17:26:51:51:3:6:windowsill\r\nzone:1:17:31:34:0:12:Near Furniture slide.\r\nzone:1:16:31:33:0:13:Furniture slide\r\nzone:2:3:32:33:3:10:Shelves\r\nzone:5:11:32:32:3:7:Near the TV.\r\nzone:1:3:48:50:0:1:under the table\r\nzone:1:3:48:50:2:4:Side table.\r\nzone:4:13:47:50:0:0:Near the sofa\r\nzone:4:12:50:50:0:7:the back of the sofa\r\nzone:4:12:48:49:0:3:the armrest of the sofa\r\nzone:5:11:48:49:0:3:the seat of the sofa\r\nzone:30:30:36:45:0:6:the back of the armchair\r\nzone:29:29:36:45:0:3:the armrest of the armchair\r\nzone:29:29:37:37:0:3:the seat of the armchair\r\nzone:29:29:44:44:0:3:the seat of the armchair\r\nzone:29:30:39:42:0:6:nightstand\r\ntile:1:5:25:29:0:10:0:100:wallfurniture\r\ntile:1:5:25:29:11:11:0:100:plastic\r\ntile:2:4:26:28:0:11:0:100:air\r\ntile:2:3:26:28:0:0:0:100:wetconcrete\r\ntile:4:4:26:28:0:0:0:100:concrete23\r\ntile:5:5:26:28:0:6:0:100:wallglass11\r\ndoor:6:6:26:28:0:6:4:27:0: :70:silence.ogg:silence.ogg:door1.ogg:silence.ogg\r\ndoor:4:4:26:28:0:6:6:27:0: :700:silence.ogg:silence.ogg:door1.ogg:silence.ogg\r\ntile:5:11:15:17:0:10:0:100:wallbuilding4\r\ntile:5:11:15:17:11:11:0:100:carpet35\r\ntile:7:9:16:17:2:11:0:100:air\r\ntile:7:9:15:17:2:2:0:100:wallstone2\r\ntile:7:9:16:17:3:3:0:100:ceramic3\r\ntile:8:8:16:16:3:3:0:100:air\r\ntile:8:8:16:16:2:2:0:100:wetconcrete\r\ntile:7:9:15:15:3:9:0:100:wallglass8\r\ntile:1:1:20:20:0:2:0:100:wallstone2\r\ntile:1:1:20:20:3:3:0:100:ceramic\r\ntile:2:2:20:20:0:0:0:100:wallstone2\r\ntile:2:2:20:20:1:1:0:100:bare\r\ntile:1:1:19:19:0:0:0:100:debris\r\nzone:1:13:15:29:0:20:bathroom \r\nzone:1:6:24:29:0:0:Near the shower cabin\r\nzone:1:5:25:29:0:11:shower cabin\r\nzone:4:6:26:28:0:6:door of shower cabin:trackme\r\nzone:1:3:19:21:0:0:Near toilet bowl\r\nzone:2:2:20:20:0:2:On the toilet bowl seat:trackme\r\nzone:1:1:20:20:0:4:on the toilet cistern\r\nshower:2:3:26:28:0:6\r\nzone:4:12:15:18:0:0:Near, sink, with lockers and a mirror\r\nzone:5:11:15:17:0:11:sink, with lockers and a mirror\r\nzone:7:9:15:17:3:9:Sink with a mirror.\r\nzone:8:8:16:16:2:2:sink:trackme\r\nwashbasin:8:8:16:16:2:6\r\ntrashcan:1:1:19:19:0:0\r\nzone:1:1:19:19:0:0:trashcan :trackme\r\ntoilet:2:2:20:20:1:6\r\nzone:1:14:1:13:0:20:hallway\r\ntile:1:2:1:2:0:0:0:100:carpet5\r\nzone:1:1:1:1:0:6:exit door:trackme\r\ntile:1:10:10:13:0:11:0:100:wallwood16\r\ntile:3:5:10:10:0:11:0:100:wallglass8\r\ntile:7:9:10:10:0:11:0:100:wallglass8\r\ntile:3:9:11:12:1:10:0:100:air\r\ntile:3:9:11:12:1:1:0:100:carpet35\r\ntile:3:9:11:12:3:3:0:100:carpet35\r\ntile:3:9:11:12:5:5:0:100:carpet35\r\ntile:2:2:11:11:1:5:0:100:carpet35\r\nzone:1:11:9:13:0:0:Near the cabinet with mirror doors, for outerwear and shoes\r\nzone:1:10:10:13:0:12:the cabinet with mirror doors, for outerwear and shoes\r\ntile:1:10:10:13:12:12:0:100:carpet39\r\nzone:3:9:9:11:0:10:Mirror doors\r\ndoor:3:9:9:9:0:10:6:11:1: :1100:silence.ogg:silence.ogg:dooropen30.ogg:doorclose33.ogg\r\ndoor:3:9:11:11:1:10:6:9:0: :1100:silence.ogg:silence.ogg:dooropen30.ogg:doorclose33.ogg\r\ntile:0:2:6:9:0:11:0:100:wallwood16\r\ntile:1:2:6:9:12:12:0:100:carpet39\r\ntile:1:2:7:8:3:10:0:100:air\r\ntile:1:2:7:8:3:3:0:100:carpet35\r\ntile:1:2:7:8:5:5:0:100:carpet35\r\ntile:1:2:7:8:7:7:0:100:carpet35\r\ntile:1:2:7:8:9:9:0:100:carpet35\r\nzone:1:2:6:9:0:12:Shelves\r\ntile:1:1:3:5:0:0:0:100:wallbank\r\ntile:1:1:3:5:1:1:0:100:bare\r\nzone:1:1:3:5:0:3:Leather seat\r\nzone:11:18:1:1:0:3:near the window\r\ntile:15:55:22:29:0:0:0:100:carpet\r\nzone:19:21:10:11:0:6:Kitchen door:trackme\r\nzone:13:15:25:26:0:6:Door of the bathroom:trackme\r\nzone:48:49:20:22:0:6:door of the guest bedroom:trackme\r\nzone:55:55:23:28:0:3:near the window\r\ntile:55:55:40:45:0:2:0:100:wallsofa\r\ntile:55:55:40:45:3:3:0:100:synthetic\r\ntile:48:54:40:45:0:0:0:100:wallcloth\r\ntile:48:54:40:45:1:1:0:100:cloth\r\ntile:55:55:39:39:1:1:0:100:carpet34\r\ntile:55:55:46:46:1:1:0:100:carpet34\r\ntile:49:55:31:34:0:11:0:100:wallbuilding\r\ntile:50:54:32:33:1:10:0:100:air\r\ntile:50:54:32:33:1:1:0:100:carpet35\r\ntile:49:55:31:34:12:12:0:100:carpet39\r\ntile:53:54:32:33:3:3:0:100:carpet35\r\ntile:53:54:32:33:5:5:0:100:carpet35\r\ntile:53:54:32:33:7:7:0:100:carpet35\r\ntile:53:54:32:33:9:9:0:100:carpet35\r\ndoor:50:54:35:35:0:10:52:33:1: :1050:silence.ogg:silence.ogg:tp39.ogg:silence.ogg\r\ndoor:50:54:33:33:1:10:52:35:0: :1050:silence.ogg:silence.ogg:tp39.ogg:silence.ogg\r\ntile:35:47:51:51:3:12:0:100:air\r\ntile:35:47:52:52:3:12:0:100:wallglass5\r\ntile:35:47:51:51:3:3:0:100:carpet310\r\ntile:35:35:50:50:0:0:0:100:walltable\r\ntile:35:35:48:48:0:0:0:100:walltable\r\ntile:39:39:48:48:0:0:0:100:walltable\r\ntile:39:39:50:50:0:0:0:100:walltable\r\ntile:35:39:48:50:1:1:0:100:walltable\r\ntile:35:39:48:50:2:2:0:100:hardwood3\r\ntile:32:32:48:50:0:3:0:100:wallbody\r\ntile:33:33:48:50:0:1:0:100:wallbody\r\ntile:32:32:48:50:4:4:0:100:carpet4\r\ntile:33:33:48:48:2:2:0:100:carpet4\r\ntile:33:33:50:50:2:2:0:100:carpet4\r\ntile:33:33:49:49:1:1:0:100:carpet3\r\ntile:36:38:45:45:0:3:0:100:wallbody\r\ntile:36:38:46:46:0:1:0:100:wallbody\r\ntile:36:38:45:45:4:4:0:100:carpet4\r\ntile:36:36:46:46:2:2:0:100:carpet4\r\ntile:38:38:46:46:2:2:0:100:carpet4\r\ntile:37:37:46:46:1:1:0:100:carpet3\r\ntile:32:34:35:39:0:2:0:100:wallbuilding7\r\ntile:32:32:35:39:3:9:0:100:wallbuilding7\r\ntile:32:32:36:38:3:9:0:100:wallglass8\r\ntile:32:32:35:39:10:10:0:100:carpet316\r\ntile:33:34:35:39:3:3:0:100:carpet34\r\ntile:36:36:37:37:0:0:0:100:chair\r\ntile:36:36:37:37:1:1:0:100:carpet3\r\nzone:32:55:31:50:0:20:bedroom\r\nzone:35:47:51:52:3:12:window\r\nzone:35:47:51:51:3:6:windowsill\r\nzone:48:55:31:35:0:0:Near the cupboard\r\nzone:49:55:31:34:0:11:Cupboard with shelves\r\nzone:50:54:33:35:0:10:doors of Cupboard\r\nzone:47:55:39:46:0:0:Near the a large bed\r\nzone:55:55:40:45:0:6:headboard\r\nzone:48:54:40:45:1:3:a large bed\r\nbed:48:54:40:45:1:1\r\nzone:55:55:39:39:1:3:Bedside Shelf\r\nzone:55:55:46:46:1:3:Bedside Shelf\r\nzone:35:39:48:50:0:1:under the table\r\nzone:35:39:48:50:2:5:writing-table\r\nzone:32:32:48:50:0:6:the back of the armchair\r\nzone:33:33:48:50:0:3:the armrest of the armchair\r\nzone:33:33:49:49:0:3:the seat of the armchair\r\nzone:36:38:45:45:0:6:the back of the armchair\r\nzone:36:38:46:46:0:3:the armrest of the armchair\r\nzone:37:37:46:46:0:3:the seat of the armchair\r\nzone:32:35:34:40:0:0:Near the Chest Of Drawers with a mirror\r\nzone:32:34:35:39:0:10:chest of drawers with a mirror\r\nzone:36:36:37:37:0:3:a soft chair\r\nzone:43:44:29:31:0:6:door of bedroom:trackme\r\nsrc:-1:57:-1:52:0:21:0:100:air.ogg\r\nsrc:11:18:-1:-1:3:12:-11:100:citybirds.ogg\r\nsrc:25:33:-1:-1:3:12:-11:100:citybirds.ogg\r\nsrc:57:57:7:14:3:12:-11:100:Birds_light.ogg\r\nsrc:57:57:23:28:3:12:-11:100:Birds_light.ogg\r\nsrc:35:47:52:52:3:12:-11:100:birds97.ogg\r\nsrc:17:26:52:52:3:12:-11:100:birds97.ogg\r\nsrc:-1:-1:36:45:3:12:-11:100:birds97.ogg\r\nlitem:1\r\nclock:15:15:50:50:0:5:the time is\r\ntile:15:15:51:51:5:5:0:100:wallglass\r\nzone:15:15:50:50:0:20:clock\r\nsrc:15:15:52:52:5:5:-5:100:clock3.ogg\r\nsrc:1:14:15:29:0:20:0:100:bathroom.ogg:1\r\nsrc:1:2:-1:-1:0:6:-11:100:harbor.ogg\r\nsrc:7:7:50:50:4:4:-11:100:pur.ogg\r\nzone:7:7:50:50:4:4:Affectionate kitty\r\nsrc:37:37:49:49:2:2:-5:100:paper.ogg:1\r\ntile:37:37:49:49:2:2:0:100:paper\r\nzone:37:37:49:49:2:2:correspondence\r\ntile:38:39:2:4:1:1:0:100:carpet35\r\ndoor:36:36:2:4:0:0:38:3:1: :700:silence.ogg:silence.ogg:dooropen41.ogg:silence.ogg\r\ndoor:38:38:2:4:1:1:36:3:0: :700:silence.ogg:silence.ogg:dooropen41.ogg:silence.ogg\r\nzone:36:38:2:4:0:2:Door of kitchen headset\r\nsrc:30:31:18:19:5:5:0:100:fridge6.ogg\r\nitem_usage_restriction:0:50:0:50:0:10:conex:partner_house:beehive:small_conex:sky_racer:ford:sorento:dogan_slx:grayhound_bus:m60_tank:tank:truck:v4_by_4_jeep:dodge_charger:doom_buggy:ford_pickup_truck:mlk_mission_cruiser:muscle_car:generic_motorcycle:frog_motorcycle:ducati_street_fighter:onda_cbr_600:yamaha_r6:aprilia_v4:aprilia_rs660:ducati_diavel:yamaha_off_road:kawasaki_hipersport:kawasaki_adventure_tourer:ducati_scrumbler:bmw_off_road:motor_boat\r\nspecified_air_temperature:-1:57:-1:52:0:10:25");
f.close();
init_mapsystem();
string newid=randomstring(6);
int housecode=random(1, 100000);
spawn_house(p.x,p.y,p.z,p.map,p.name,housecode,130000,mapname,parsed[2],newid);
//send_packet(6,"playtvp "+p.x+" "+p.y+" "+p.z, p.x,p.y,p.z,maps[get_map_index(p.map)]);
p.inv_add_item("partner_house",-1);
send_reliable(p,"Your partner_house has been placed, the code to get in to your house is "+housecode+"",2);
}
else if(parsed[2]=="beehive")
{
if(can_use_item_at(p.x,p.y,p.z,maps[get_map_index(p.map)],parsed[2])==false)
{
send_reliable(p,"you can't put your "+parsed[2]+" here",2);
return;
}
string mapname="beehive_of_"+p.name+"";
if(map_exists(mapname))
{
send_reliable(p,"you already have a beehive",0);
return;
}
if(in_beehive(p)>-1)
{
send_reliable(p,"you can't put your beehive inside another one",0);
return;
}
if(in_playerstore(p)>-1)
{
send_reliable(p,"you can't put your beehive inside a store",0);
return;
}
if(is_safe(p.x,p.y,p.z,maps[get_map_index(p.map)])==true and in_house(p)<0)
{
send_reliable(p,"you can't put your beehive in safe places",0);
return;
}
if(is_travelpoint(p.x,p.y,p.z,maps[get_map_index(p.map)]))
{
send_reliable(p,"Building beehive's on travelpoints doesn't works!",2);
return;
}
if(get_tile_at(p.x,p.y,p.z,maps[get_map_index(p.map)])=="air" or get_tile_at(p.x,p.y,p.z,maps[get_map_index(p.map)])=="")
{
send_reliable(p,"can't place beehive' in the air",0);
return;
}
if(p.is_admin()==false)
{
string charfolder="chars/"+p.name;
string[] a=string_split(file_get_contents("pbmaps.svr"),"\r\n",false);
string[] a2=string_split(file_get_contents(charfolder+"/maps.usr"),"\r\n",false);
string[] a3=string_split(file_get_contents("chmaps.svr"),"\r\n",false);
int something=a.find(p.map);
int something2=a2.find(p.map);
int something3=a3.find(p.map);
if(something>-1 or something2>-1 or something3>-1)
{
send_reliable(p,"you can't put this in your map",2);
return;
}
}
for(uint i=0; i<beehives.length(); i++)
{
if(beehives[i].x==p.x and beehives[i].y==p.y and beehives[i].z==p.z and beehives[i].map==p.map)
{
send_reliable(p,"there's a beehive here",0);
return;
}
}
f.open("maps/"+mapname+".map","wb");
f.write("mapname:"+mapname+"\r\nminx:0\r\nmaxx:10\r\nminy:0\r\nmaxy:10\r\nminz:0\r\nmaxz:10\r\ntile:0:10:0:10:0:0:0:100:ledge2\r\nowner:mahdi\r\nlitem:0\r\nsafe_card:0\r\nzone:0:10:0:10:0:10:beehive\r\nsrc:0:10:0:10:0:10:0:100:beehive.ogg\r\nai:0:10:0:10:0:0:100000:1:honey_bee\r\nzone:0:0:0:0:0:10:exit path:trackme\r\nitem:0:10:0:10:0:0:900000:3:honey\r\nrain:none.ogg\r\nwind:silence.ogg\r\nnight:silence.ogg\r\ndeathpoint:0:10:0:10:0:0\r\nstarting_point:0:10:0:10:0:0\r\nitem_usage_restriction:0:10:0:10:0:10:conex:partner_house:beehive:small_conex:locker:fridge:microwave:air_conditioner:steam:fan:sky_racer:ford:sorento:dogan_slx:grayhound_bus:m60_tank:tank:truck:v4_by_4_jeep:dodge_charger:doom_buggy:ford_pickup_truck:mlk_mission_cruiser:muscle_car:generic_motorcycle:frog_motorcycle:ducati_street_fighter:onda_cbr_600:yamaha_r6:aprilia_v4:aprilia_rs660:ducati_diavel:yamaha_off_road:kawasaki_hipersport:kawasaki_adventure_tourer:ducati_scrumbler:bmw_off_road:motor_boat\r\nspecified_air_temperature:0:10:0:10:0:10:25");
f.close();
init_mapsystem();
spawn_beehive(p.x,p.y,p.z,p.map,p.name,10000,mapname);
//send_packet(6,"playtvp "+p.x+" "+p.y+" "+p.z, p.x,p.y,p.z,maps[get_map_index(p.map)]);
p.inv_add_item("beehive",-1);
send_reliable(p,"Your beehive has been placed",2);
}
else if(parsed[2]=="small_conex")
{
if(can_use_item_at(p.x,p.y,p.z,maps[get_map_index(p.map)],parsed[2])==false)
{
send_reliable(p,"you can't put your "+parsed[2]+" here",2);
return;
}
if(p.gender==0 and p.job!="salesman" or p.gender==1 and p.job!="saleswoman")
{
if(p.gender==0) send_reliable(p,"you are not a salesman",2);
else send_reliable(p,"you are not a saleswoman",2);
return;
}
if(p.contabancaria==0)
{
send_reliable(p, "You haven't bank account to do this action", 2);
return;
}
send_serverbox(p.peer_id,2,1,0,-1,"pstore2","press 1 to build a clothing store, 2 to build a weapon store, 3 to build a vehicle store, 4 to build a fastfood store, 5 to build a explosive store, 6 to build a misc store, 7 to build a medical store, 8 to build a fruit store, 9 to build a household store, 0 to build a team store, minus or - to build a jewelry");
}
else if(parsed[2]=="candle")
{
if(can_use_item_at(p.x,p.y,p.z,maps[get_map_index(p.map)],parsed[2])==false)
{
send_reliable(p,"you can't put your "+parsed[2]+" here",2);
return;
}
//send_packet(6,"playtvp "+p.x+" "+p.y+" "+p.z, p.x,p.y,p.z,maps[get_map_index(p.map)]);
spawn_candle(p.x,p.y,p.z,maps[get_map_index(p.map)],0);
p.inv_add_item("candle",-1);
}
else if(parsed[2]=="microwave")
{
if(can_use_item_at(p.x,p.y,p.z,maps[get_map_index(p.map)],parsed[2])==false)
{
send_reliable(p,"you can't put your "+parsed[2]+" here",2);
return;
}
if(in_beehive(p)>-1)
{
send_reliable(p,"you can't put a microwave inside a beehive",0);
return;
}
if(is_safe(p.x,p.y,p.z,maps[get_map_index(p.map)])==true and in_house(p)<0)
{
send_reliable(p,"you can't put your microwave in safe places",0);
return;
}
if(get_tile_at(p.x,p.y,p.z,maps[get_map_index(p.map)])=="air" or get_tile_at(p.x,p.y,p.z,maps[get_map_index(p.map)])=="")
{
send_reliable(p,"can't place microwave' in the air",0);
return;
}
if(p.is_admin()==false)
{
string charfolder="chars/"+p.name;
string[] a=string_split(file_get_contents("pbmaps.svr"),"\r\n",false);
string[] a2=string_split(file_get_contents(charfolder+"/maps.usr"),"\r\n",false);
string[] a3=string_split(file_get_contents("chmaps.svr"),"\r\n",false);
int something=a.find(p.map);
int something2=a2.find(p.map);
int something3=a3.find(p.map);
if(something>-1 or something2>-1 or something3>-1)
{
send_reliable(p,"you can't put this in your map",2);
return;
}
}
for(uint i=0; i<microwaves.length(); i++)
{
if(microwaves[i].x==p.x and microwaves[i].y==p.y and microwaves[i].z==p.z and microwaves[i].map==p.map)
{
send_reliable(p,"there's already a microwave here",0);
return;
}
}
//send_packet(6,"playtvp "+p.x+" "+p.y+" "+p.z, p.x,p.y,p.z,maps[get_map_index(p.map)]);
string newid=randomstring(6);
spawn_microwave(p.x,p.y,p.z,p.map,p.name,5000,newid);
p.inv_add_item("microwave",-1);
send_reliable(p,"Your microwave has been placed successfully",2);
}
else if(parsed[2]=="air_conditioner")
{
if(can_use_item_at(p.x,p.y,p.z,maps[get_map_index(p.map)],parsed[2])==false)
{
send_reliable(p,"you can't put your "+parsed[2]+" here",2);
return;
}
if(in_beehive(p)>-1)
{
send_reliable(p,"you can't put your air_conditioner inside a beehive",0);
return;
}
if(is_safe(p.x,p.y,p.z,maps[get_map_index(p.map)])==true and in_house(p)<0)
{
send_reliable(p,"you can't put your air_conditioner in safe places",0);
return;
}
if(get_tile_at(p.x,p.y,p.z,maps[get_map_index(p.map)])=="air" or get_tile_at(p.x,p.y,p.z,maps[get_map_index(p.map)])=="")
{
send_reliable(p,"can't place air_conditioner' in the air",0);
return;
}
if(p.is_admin()==false)
{
string charfolder="chars/"+p.name;
string[] a=string_split(file_get_contents("pbmaps.svr"),"\r\n",false);
string[] a2=string_split(file_get_contents(charfolder+"/maps.usr"),"\r\n",false);
string[] a3=string_split(file_get_contents("chmaps.svr"),"\r\n",false);
int something=a.find(p.map);
int something2=a2.find(p.map);
int something3=a3.find(p.map);
if(something>-1 or something2>-1 or something3>-1)
{
send_reliable(p,"you can't put this in your map",2);
return;
}
}
for(uint i=0; i<air_conditioners.length(); i++)
{
if(air_conditioners[i].x==p.x and air_conditioners[i].y==p.y and air_conditioners[i].z==p.z and air_conditioners[i].map==p.map)
{
send_reliable(p,"there's already air_conditioner here",0);
return;
}
}
//send_packet(6,"playtvp "+p.x+" "+p.y+" "+p.z, p.x,p.y,p.z,maps[get_map_index(p.map)]);
string newid=randomstring(6);
spawn_air_conditioner(p.x,p.y,p.z,p.map,p.name,5000,0,newid);
p.inv_add_item("air_conditioner",-1);
send_reliable(p,"Your air_conditioner has been placed successfully",2);
}
else if(parsed[2]=="steam")
{
if(can_use_item_at(p.x,p.y,p.z,maps[get_map_index(p.map)],parsed[2])==false)
{
send_reliable(p,"you can't put your "+parsed[2]+" here",2);
return;
}
if(in_beehive(p)>-1)
{
send_reliable(p,"you can't put your steam inside a beehive",0);
return;
}
if(is_safe(p.x,p.y,p.z,maps[get_map_index(p.map)])==true and in_house(p)<0)
{
send_reliable(p,"you can't put your steam in safe places",0);
return;
}
if(get_tile_at(p.x,p.y,p.z,maps[get_map_index(p.map)])=="air" or get_tile_at(p.x,p.y,p.z,maps[get_map_index(p.map)])=="")
{
send_reliable(p,"can't place steam' in the air",0);
return;
}
if(p.is_admin()==false)
{
string charfolder="chars/"+p.name;
string[] a=string_split(file_get_contents("pbmaps.svr"),"\r\n",false);
string[] a2=string_split(file_get_contents(charfolder+"/maps.usr"),"\r\n",false);
string[] a3=string_split(file_get_contents("chmaps.svr"),"\r\n",false);
int something=a.find(p.map);
int something2=a2.find(p.map);
int something3=a3.find(p.map);
if(something>-1 or something2>-1 or something3>-1)
{
send_reliable(p,"you can't put this in your map",2);
return;
}
}
for(uint i=0; i<steams.length(); i++)
{
if(steams[i].x==p.x and steams[i].y==p.y and steams[i].z==p.z and steams[i].map==p.map)
{
send_reliable(p,"there's already steam here",0);
return;
}
}
//send_packet(6,"playtvp "+p.x+" "+p.y+" "+p.z, p.x,p.y,p.z,maps[get_map_index(p.map)]);
string newid=randomstring(6);
spawn_steam(p.x,p.y,p.z,p.map,p.name,5000,0,newid);
p.inv_add_item("steam",-1);
send_reliable(p,"Your steam has been placed successfully",2);
}
else if(parsed[2]=="fan")
{
if(can_use_item_at(p.x,p.y,p.z,maps[get_map_index(p.map)],parsed[2])==false)
{
send_reliable(p,"you can't put your "+parsed[2]+" here",2);
return;
}
if(in_beehive(p)>-1)
{
send_reliable(p,"you can't put your fan inside a beehive",0);
return;
}
if(is_safe(p.x,p.y,p.z,maps[get_map_index(p.map)])==true and in_house(p)<0)
{
send_reliable(p,"you can't put your fan in safe places",0);
return;
}
if(get_tile_at(p.x,p.y,p.z,maps[get_map_index(p.map)])=="air" or get_tile_at(p.x,p.y,p.z,maps[get_map_index(p.map)])=="")
{
send_reliable(p,"can't place fan' in the air",0);
return;
}
if(p.is_admin()==false)
{
string charfolder="chars/"+p.name;
string[] a=string_split(file_get_contents("pbmaps.svr"),"\r\n",false);
string[] a2=string_split(file_get_contents(charfolder+"/maps.usr"),"\r\n",false);
string[] a3=string_split(file_get_contents("chmaps.svr"),"\r\n",false);
int something=a.find(p.map);
int something2=a2.find(p.map);
int something3=a3.find(p.map);
if(something>-1 or something2>-1 or something3>-1)
{
send_reliable(p,"you can't put this in your map",2);
return;
}
}
for(uint i=0; i<fans.length(); i++)
{
if(fans[i].x==p.x and fans[i].y==p.y and fans[i].z==p.z and fans[i].map==p.map)
{
send_reliable(p,"there's already fan here",0);
return;
}
}
//send_packet(6,"playtvp "+p.x+" "+p.y+" "+p.z, p.x,p.y,p.z,maps[get_map_index(p.map)]);
string newid=randomstring(6);
spawn_fan(p.x,p.y,p.z,p.map,p.name,5000,0,newid);
p.inv_add_item("fan",-1);
send_reliable(p,"Your fan has been placed successfully",2);
}
else if(starter_exist_on(p.x,p.y,p.z,maps[get_map_index(p.map)])==true and parsed[2]=="wood")
{
p.inv_add_item(parsed[2],0-1);
//send_packet(6,"playtvp "+p.x+" "+p.y+" "+p.z, p.x,p.y,p.z,maps[get_map_index(p.map)]);
send_packet(6,"play fireburn"+random(1,5)+".ogg "+p.x+" "+p.y+" "+p.z, p.x,p.y,p.z,maps[get_map_index(p.map)]);
for(uint i=0;i<fire_starters.length();i++)
{
fire_starters[i].health+=random(5,10);
}
}
else if(starter_exist_on(p.x,p.y,p.z,maps[get_map_index(p.map)])==true and parsed[2]!="wood")
{
send_packet(6,"play firehit.ogg "+p.x+" "+p.y+" "+p.z, p.x,p.y,p.z,maps[get_map_index(p.map)]);
//send_packet(6,"playtvp "+p.x+" "+p.y+" "+p.z, p.x,p.y,p.z,maps[get_map_index(p.map)]);
p.inv_add_item(parsed[2],0-1);
for(uint i=0;i<fire_starters.length();i++)
{
fire_starters[i].health-=random(5,10);
}
}
else if(parsed[2]=="ball")
{
p.inv_add_item(parsed[2],-amount);
//send_packet(6,"playtvp "+p.x+" "+p.y+" "+p.z, p.x,p.y,p.z,maps[get_map_index(p.map)]);
spawn_silenceobj(p.x,p.y,p.z,maps[get_map_index(p.map)],parsed[2],amount);
send_reliable(p, "hempty "+parsed[2], 0);
}
else
{
p.inv_add_item(parsed[2],-amount);
//send_packet(6,"playtvp "+p.x+" "+p.y+" "+p.z, p.x,p.y,p.z,maps[get_map_index(p.map)]);
spawn_obj(p.x,p.y,p.z,maps[get_map_index(p.map)],parsed[2],amount);
send_reliable(p, "hempty "+parsed[2], 0);
}
}
}
else if(parsed[0]=="tlpset" and parsed.length()>1)
{
if(parsed[1]=="back")
{
p.sendpacket("canceled", 0);
return;
}
if(!map_exists(parsed[1]))
{
send_reliable(p,"this map does not exists",2);
return;
}
string charfolder="chars/"+p.name;
string[] a=string_split(file_get_contents("pbmaps.svr"),"\r\n",false);
string[] a2=string_split(file_get_contents(charfolder+"/maps.usr"),"\r\n",false);
string[] a3=string_split(file_get_contents("chmaps.svr"),"\r\n",false);
int something=a.find(p.map);
int something2=a2.find(p.map);
int something3=a3.find(p.map);
if(something>-1 or something2>-1 or something3>-1)
{
send_reliable(p,"you can't do this",2);
return;
}
send_packet(6,"play teleportstart.ogg "+p.x+" "+p.y+" "+p.z, p.x,p.y,p.z,maps[get_map_index(p.map)]);
send_reliable(0,"stopmoving",0);
if(p.waitingtimer.elapsed>=4597)
{
p.waitingtimer.restart();
int mi=get_map_index(parsed[1]);
if((mi>-1))
{
string mdata=maps[mi].rawdata;
string[] p1=delinear(mdata);
for(uint i=0; i<p1.length(); i++)
{
string[] parsed=string_split(p1[i], ":", true);
if(parsed[0]=="safezone" and parsed.length()>6 and p.pvp==1)
{
send_reliable(p,"you can't teleport to this map when you are pvp",2);
return;
}
}
move_player(p,parsed[1],random(maps[mi].spminx,maps[mi].spmaxx),random(maps[mi].spminy,maps[mi].spmaxy),random(maps[mi].spminz,maps[mi].spmaxz),true);
if(maps[mi].pvp==1 and maps[mi].pvpminx<=p.x and maps[mi].pvpmaxx>=p.x and maps[mi].pvpminy<=p.y and maps[mi].pvpmaxy>=p.y and maps[mi].pvpminz<=p.z and maps[mi].pvpmaxz>=p.z)
{
if(p.pvp!=1)
{
p.pvp=1;
send_reliable(p,"You are now pvp!",2);
send_reliable(0,"play_s pvpon.ogg",6);
send_reliable(0,""+p.nickname+" is now pvp!",2);
}
}
else if(maps[mi].pvp==2 and maps[mi].pvpminx<=p.x and maps[mi].pvpmaxx>=p.x and maps[mi].pvpminy<=p.y and maps[mi].pvpmaxy>=p.y and maps[mi].pvpminz<=p.z and maps[mi].pvpmaxz>=p.z)
{
if(p.pvp!=0)
{
p.pvp=0;
send_reliable(p,"You are no longer pvp!",2);
send_reliable(0,"play_s pvpoff.ogg",6);
send_reliable(0,""+p.nickname+" is no longer pvp!",2);
}
}
}
send_packet(6,"play teleportstop.ogg "+p.x+" "+p.y+" "+p.z, p.x,p.y,p.z,maps[get_map_index(p.map)]);
send_reliable(0,"startmoving",0);
p.inv_add_item("teleporter",-1);
}
}
else if(parsed[0]=="havecycleinventory")
{
if(p.have_cycle_inventory==1)
{
p.have_cycle_inventory=0;
}
else if(p.have_cycle_inventory==0)
{
p.have_cycle_inventory=1;
}
send_reliable(p,"havecycleinventory "+p.have_cycle_inventory,0);
}
else if(parsed[0]=="cycleinventoryrequest")
{
string data=serialize(p.inv);
send_reliable(p,"invis "+data,0);
}
else if(parsed[0]=="pstore2")
{
if(parsed[1]=="back")
{
p.sendpacket("canceled", 0);
return;
}
string number=string_trim_left(get_event_message(),8);
string name;
if(number==1)
{
name="clothing_store";
}
else if(number==2)
{
name="weapon_store";
}
else if(number==3)
{
name="vehicle_store";
}
else if(number==4)
{
name="fastfood_store";
}
else if(number==5)
{
name="explosive_store";
}
else if(number==6)
{
name="misc_store";
}
else if(number==7)
{
name="medical_store";
}
else if(number==8)
{
name="fruit_store";
}
else if(number==9)
{
name="household_store";
}
else if(number==0)
{
name="team_store";
}
else if(number=="-")
{
name="jewelry";
}
else
{
p.sendpacket("canceled", 0);
return;
}
string mapname=""+name+"_of_"+p.name+"";
if(map_exists(mapname))
{
send_reliable(p,"you already have a "+name+"",0);
return;
}
if(in_playerstore(p)>-1)
{
send_reliable(p,"you can't build a store inside another one",0);
return;
}
if(in_house(p)>-1)
{
send_reliable(p,"you can't put your store inside a house",0);
return;
}
if(in_beehive(p)>-1)
{
send_reliable(p,"you can't put your store inside a beehive",0);
return;
}
if(p.is_admin()==false)
{
string charfolder="chars/"+p.name;
string[] a=string_split(file_get_contents("pbmaps.svr"),"\r\n",false);
string[] a2=string_split(file_get_contents(charfolder+"/maps.usr"),"\r\n",false);
int something=a.find(p.map);
int something2=a2.find(p.map);
if(something>-1 or something2>-1)
{
send_reliable(p,"you can't put this in your map",2);
return;
}
}
if(is_safe(p.x,p.y,p.z,maps[get_map_index(p.map)])==true)
{
send_reliable(p,"you can't put your store in safe places",0);
return;
}
if(is_travelpoint(p.x,p.y,p.z,maps[get_map_index(p.map)]))
{
send_reliable(p,"Building store's on travelpoints doesn't works!",2);
return;
}
if(get_tile_at(p.x,p.y,p.z,maps[get_map_index(p.map)])=="air" or get_tile_at(p.x,p.y,p.z,maps[get_map_index(p.map)])=="")
{
send_reliable(p,"can't place playerstore' in the air",0);
return;
}
for(uint i=0; i<playerstores.length(); i++)
{
if(playerstores[i].x==p.x and playerstores[i].y==p.y and playerstores[i].z==p.z and playerstores[i].map==p.map)
{
send_reliable(p,"there's a store here",0);
return;
}
}
f.open("maps/"+mapname+".map","wb");
f.write("mapname:"+mapname+"\r\nminx:0\r\nmaxx:25\r\nminy:0\r\nmaxy:25\r\nminz:0\r\nmaxz:10\r\ntile:0:25:0:25:0:0:0:100:hardwood\r\nowner:mahdi\r\nlitem:1\r\nsafe_card:0\r\nstarting_point:0:25:0:25:0:0\r\ndeathpoint:0:25:0:25:0:0\r\nzone:0:25:0:25:0:10:"+name+"\r\nsrc:0:25:0:25:0:10:0:100:calm.ogg\r\nzone:0:0:0:0:0:10:exit door:trackme\r\nopening_hours:6:24\r\nrain:raininterior.ogg\r\nwind:silence.ogg\r\nnight:silence.ogg\r\nitem_usage_restriction:0:25:0:25:0:10:conex:partner_house:beehive:small_conex:locker:fridge:microwave:sky_racer:ford:sorento:dogan_slx:grayhound_bus:m60_tank:tank:truck:v4_by_4_jeep:dodge_charger:doom_buggy:ford_pickup_truck:mlk_mission_cruiser:muscle_car:generic_motorcycle:frog_motorcycle:ducati_street_fighter:onda_cbr_600:yamaha_r6:aprilia_v4:aprilia_rs660:ducati_diavel:yamaha_off_road:kawasaki_hipersport:kawasaki_adventure_tourer:ducati_scrumbler:bmw_off_road:motor_boat");
f.close();
init_mapsystem();
spawn_playerstore(p.x,p.y,p.z,p.map,p.name,name,40000,mapname);
//send_packet(6,"playtvp "+p.x+" "+p.y+" "+p.z, p.x,p.y,p.z,maps[get_map_index(p.map)]);
p.inv_add_item("small_conex",-1);
send_reliable(p,"Your store has been placed",2);
}
else if(parsed[0]=="describe" and parsed.length()>1)
{
if(parsed[1]=="coins")
{
send_reliable(p,"money",2);
}

else
{
send_reliable(p,"There is no descryption available for "+parsed[1],2);
return;
}
}
else if(parsed[0]=="uptime")
{
send_reliable(p,"The server has been up for "+ms_to_readable_time(uptimer.elapsed)+". Total recorded uptime: "+ms_to_readable_time(accumulated_uptimer.elapsed)+". VPS uptime: "+ms_to_readable_time(TIME_SYSTEM_RUNNING_MILLISECONDS)+"",2);
}
else if(parsed[0]=="icstart" and parsed.length()>1)
{
string selection=parsed[1];
if(selection=="back" or selection=="" or selection==" ")
{
send_reliable(p,"canceled",0);
return;
}
string[] a=string_split(file_get_contents("notadg.svr"),"\r\n",false);
int something=a.find(parsed[1]);
if(something>-1)
{
send_reliable(p,"canceled",0);
return;
}
if(auction==true and auctionwho==p.name and auctionitem==parsed[1] or auction==true and auctionwho==p.name and auctioncurrency==parsed[1])
{
send_reliable(p,"you can't transfer "+parsed[1]+" while putting it in auction",2);
return;
}
if(auction==true and auctionwho2==p.name)
{
send_reliable(p,"you can't do this while bidding",2);
return;
}
p.launchitem=selection;
if(actable_items.find(selection)<0)
{
send_packet(6,"play carrier_missileinput.ogg "+p.x+" "+p.y+" "+p.z, p.x,p.y,p.z,maps[get_map_index(p.map)]);
p.launchmode=0;
send_packet(6,"play item_carying_projectileload"+random(2,4)+".ogg "+p.x+" "+p.y+" "+p.z, p.x,p.y,p.z,maps[get_map_index(p.map)]);
send_serverbox(p.peer_id,2,-1,1,-1,"icx","Enter the X coordinate of the item carier");
return;
}
else
{
string m="yes:yes[]no:no";
send_packet(6,"play item_carying_projectileload1.ogg "+p.x+" "+p.y+" "+p.z, p.x,p.y,p.z,maps[get_map_index(p.map)]);
send_menu(p.peer_id,"Would you like this item to deploy when it has reached its destination?","icmode",m);
}
}
else if(parsed[0]=="icmode" and parsed.length()>1)
{
string answer=parsed[1];
if(answer=="back")
{
p.launchmode=-1;
send_reliable(p,"Canceled",0);
return;
}
if(answer=="yes")
{
p.launchmode=1;
}
else if(answer=="no")
p.launchmode=0;
send_packet(6,"play item_carying_projectileload"+random(2,4)+".ogg "+p.x+" "+p.y+" "+p.z, p.x,p.y,p.z,maps[get_map_index(p.map)]);
send_serverbox(p.peer_id,2,-1,1,-1,"icx","Enter the X coordinate of the item carier");
}
else if(parsed[0]=="icx" and parsed.length()>1)
{
if(parsed[1]=="[cncel]")
{
send_reliable(p,"Operation canceled!",0);
return;
}
else
{
p.missilex=string_to_number(parsed[1]);
send_packet(6,"play item_carying_projectileload"+random(2,4)+".ogg "+p.x+" "+p.y+" "+p.z, p.x,p.y,p.z,maps[get_map_index(p.map)]);
send_serverbox(p.peer_id,2,-1,1,-1,"icy","Enter the y target of the item carier");
}
}
else if(parsed[0]=="icy" and parsed.length()>1)
{
if(parsed[1]=="[cncel]")
{
send_reliable(p,"Operation canceled!",0);
return;
}
else
{
p.missiley=string_to_number(parsed[1]);
send_packet(6,"play item_carying_projectileload"+random(2,4)+".ogg "+p.x+" "+p.y+" "+p.z, p.x,p.y,p.z,maps[get_map_index(p.map)]);
send_serverbox(p.peer_id,2,-1,1,-1,"icz","Enter the z target of the item carier");
}
}
else if(parsed[0]=="icz" and parsed.length()>1)
{
if(parsed[1]=="[cncel]")
{
send_reliable(p,"Operation canceled!",0);
return;
}
else
{
p.inv_add_item("item_carier",-1);
p.missilez=string_to_number(parsed[1]);
if(can_spawn_item_at(p.missilex,p.missiley,p.missilez,maps[get_map_index(p.map)],p.launchitem)==false)
{
send_reliable(p,"play_s error.ogg",6);
send_reliable(p,p.launchitem+"s are not allowed there!",2);
p.inv_add_item("item_carier",1);
return;
}

send_packet(6,"play carrier_missile_start.ogg "+p.x+" "+p.y+" "+p.z, p.x,p.y,p.z,maps[get_map_index(p.map)]);
p.inv_add_item(p.launchitem,-1);
spawn_item_carier(p.x,p.y,p.z,p.missilex,p.missiley,p.missilez,maps[get_map_index(p.map)],p,p.launchitem,int_to_bool(p.launchmode));
p.missiletimer.restart();
p.missilex=0; p.missiley=0; p.missilez=0;p.launchmode=-1;
}
}
else if(parsed[0]=="putback")
{
send_packet(6,"play invput.ogg "+p.x+" "+p.y+" "+p.z, p.x,p.y,p.z,maps[get_map_index(p.map)]);
if(p.weapon_name!="fists")
{
p.weapon_name="fists";
if(p.weapon_ammos>0)
p.inv_add_item(p.weapon_ammo_type, p.weapon_ammos);
p.firetimer=180;
p.weapon_ammos=0;
p.weapon_ammo_type="";
p.weapon_copasity=0;
send_reliable(p, "notrapid", 0);
}
}
else if(parsed[0]=="handdraw")
{
if(parsed.length()>2)
send_packet(6,"play draw"+get_draw_and_get_sound(parsed[2])+".ogg "+p.x+" "+p.y+" "+p.z, p.x,p.y,p.z,maps[get_map_index(p.map)]);
if(parsed.length()<3)
{
if(string_to_number(parsed[1])==1)
send_reliable(p, "left hand", 2);
else if(string_to_number(parsed[1])==2)
send_reliable(p, "right hand", 2);
}
else
{
if(parsed[2]=="axe")
{
if(parsed[2]!=p.weapon_name)
{
p.weapon_name=parsed[2];
if(p.weapon_ammos>0)
p.inv_add_item(p.weapon_ammo_type, p.weapon_ammos);
p.firetimer=590;
p.weapon_ammos=0;
p.weapon_ammo_type="";
p.weapon_copasity=0;
send_reliable(p,parsed[2],0);
send_reliable(p, "notrapid", 0);
}
}
else if(parsed[2]=="axe2")
{
if(parsed[2]!=p.weapon_name)
{
p.weapon_name=parsed[2];
if(p.weapon_ammos>0)
p.inv_add_item(p.weapon_ammo_type, p.weapon_ammos);
p.firetimer=640;
p.weapon_ammos=0;
p.weapon_ammo_type="";
p.weapon_copasity=0;
send_reliable(p,parsed[2],0);
send_reliable(p, "notrapid", 0);
}
}
else if(parsed[2]=="knife")
{
if(parsed[2]!=p.weapon_name)
{
p.weapon_name=parsed[2];
if(p.weapon_ammos>0)
p.inv_add_item(p.weapon_ammo_type, p.weapon_ammos);
p.firetimer=250;
p.weapon_ammos=0;
p.weapon_ammo_type="";
p.weapon_copasity=0;
send_reliable(p,parsed[2],0);
send_reliable(p, "notrapid", 0);
}
}
else if(parsed[2]=="long_knife")
{
if(parsed[2]!=p.weapon_name)
{
p.weapon_name=parsed[2];
if(p.weapon_ammos>0)
p.inv_add_item(p.weapon_ammo_type, p.weapon_ammos);
p.firetimer=270;
p.weapon_ammos=0;
p.weapon_ammo_type="";
p.weapon_copasity=0;
send_reliable(p,parsed[2],0);
send_reliable(p, "notrapid", 0);
}
}
else if(parsed[2]=="spear")
{
if(parsed[2]!=p.weapon_name)
{
p.weapon_name=parsed[2];
if(p.weapon_ammos>0)
p.inv_add_item(p.weapon_ammo_type, p.weapon_ammos);
p.firetimer=430;
p.weapon_ammos=0;
p.weapon_ammo_type="";
p.weapon_copasity=0;
send_reliable(p,parsed[2],0);
send_reliable(p, "notrapid", 0);
}
}
else if(parsed[2]=="hammer")
{
if(parsed[2]!=p.weapon_name)
{
p.weapon_name=parsed[2];
if(p.weapon_ammos>0)
p.inv_add_item(p.weapon_ammo_type, p.weapon_ammos);
p.firetimer=490;
p.weapon_ammos=0;
p.weapon_ammo_type="";
p.weapon_copasity=0;
send_reliable(p,parsed[2],0);
send_reliable(p, "notrapid", 0);
}
}
else if(parsed[2]=="ak47assault_rifle")
{
if(parsed[2]!=p.weapon_name)
{
p.weapon_name=parsed[2];
if(p.weapon_ammos>0)
p.inv_add_item(p.weapon_ammo_type, p.weapon_ammos);
p.firetimer=100;
p.weapon_ammos=0;
p.weapon_ammo_type="7.62mm_ammo";
p.weapon_copasity=30;
send_reliable(p,parsed[2],0);
send_reliable(p, "rapid", 0);
}
}
else if(parsed[2]=="ak48")
{
if(parsed[2]!=p.weapon_name)
{
p.weapon_name=parsed[2];
if(p.weapon_ammos>0)
p.inv_add_item(p.weapon_ammo_type, p.weapon_ammos);
p.firetimer=100;
p.weapon_ammos=0;
p.weapon_ammo_type="7.62mm_ammo";
p.weapon_copasity=30;
send_reliable(p,parsed[2],0);
send_reliable(p, "rapid", 0);
}
}
else if(parsed[2]=="arrow_gun")
{
if(parsed[2]!=p.weapon_name)
{
p.weapon_name=parsed[2];
if(p.weapon_ammos>0)
p.inv_add_item(p.weapon_ammo_type, p.weapon_ammos);
p.firetimer=100;
p.weapon_ammos=0;
p.weapon_ammo_type="arrow";
p.weapon_copasity=20;
send_reliable(p,parsed[2],0);
send_reliable(p, "notrapid", 0);
}
}
else if(parsed[2]=="a90sniper_rifle")
{
if(parsed[2]!=p.weapon_name)
{
p.weapon_name=parsed[2];
if(p.weapon_ammos>0)
p.inv_add_item(p.weapon_ammo_type, p.weapon_ammos);
p.firetimer=4000;
p.weapon_ammos=0;
p.weapon_ammo_type="12.7mm_ammo";
p.weapon_copasity=1;
send_reliable(p,parsed[2],0);
send_reliable(p, "notrapid", 0);
}
}
else if(parsed[2]=="bow")
{
if(parsed[2]!=p.weapon_name)
{
p.weapon_name=parsed[2];
if(p.weapon_ammos>0)
p.inv_add_item(p.weapon_ammo_type, p.weapon_ammos);
p.firetimer=240;
p.weapon_ammos=0;
p.weapon_ammo_type="arrow";
p.weapon_copasity=1;
send_reliable(p,parsed[2],0);
send_reliable(p, "notrapid", 0);
}
}
else if(parsed[2]=="blue_assault_rifle")
{
if(parsed[2]!=p.weapon_name)
{
p.weapon_name=parsed[2];
if(p.weapon_ammos>0)
p.inv_add_item(p.weapon_ammo_type, p.weapon_ammos);
p.firetimer=600;
p.weapon_ammos=0;
p.weapon_ammo_type="12.7mm_ammo";
p.weapon_copasity=3;
send_reliable(p,parsed[2],0);
send_reliable(p, "notrapid", 0);
}
}
else if(parsed[2]=="blue_bolt_action_sniper")
{
if(parsed[2]!=p.weapon_name)
{
p.weapon_name=parsed[2];
if(p.weapon_ammos>0)
p.inv_add_item(p.weapon_ammo_type, p.weapon_ammos);
p.firetimer=2600;
p.weapon_ammos=0;
p.weapon_ammo_type="12.7mm_ammo";
p.weapon_copasity=5;
send_reliable(p,parsed[2],0);
send_reliable(p, "notrapid", 0);
}
}
else if(parsed[2]=="blue_burst_assault_rifle")
{
if(parsed[2]!=p.weapon_name)
{
p.weapon_name=parsed[2];
if(p.weapon_ammos>0)
p.inv_add_item(p.weapon_ammo_type, p.weapon_ammos);
p.firetimer=1900;
p.weapon_ammos=0;
p.weapon_ammo_type="12.7mm_ammo";
p.weapon_copasity=12;
send_reliable(p,parsed[2],0);
send_reliable(p, "notrapid", 0);
}
}
else if(parsed[2]=="blue_heavy_assault_rifle")
{
if(parsed[2]!=p.weapon_name)
{
p.weapon_name=parsed[2];
if(p.weapon_ammos>0)
p.inv_add_item(p.weapon_ammo_type, p.weapon_ammos);
p.firetimer=2800;
p.weapon_ammos=0;
p.weapon_ammo_type="12.7mm_ammo";
p.weapon_copasity=2;
send_reliable(p,parsed[2],0);
send_reliable(p, "notrapid", 0);
}
}
else if(parsed[2]=="blue_hunting_rifle")
{
if(parsed[2]!=p.weapon_name)
{
p.weapon_name=parsed[2];
if(p.weapon_ammos>0)
p.inv_add_item(p.weapon_ammo_type, p.weapon_ammos);
p.firetimer=2500;
p.weapon_ammos=0;
p.weapon_ammo_type="12.7mm_ammo";
p.weapon_copasity=7;
send_reliable(p,parsed[2],0);
send_reliable(p, "notrapid", 0);
}
}
else if(parsed[2]=="blue_infintry_rifle")
{
if(parsed[2]!=p.weapon_name)
{
p.weapon_name=parsed[2];
if(p.weapon_ammos>0)
p.inv_add_item(p.weapon_ammo_type, p.weapon_ammos);
p.firetimer=1700;
p.weapon_ammos=0;
p.weapon_ammo_type="12.7mm_ammo";
p.weapon_copasity=7;
send_reliable(p,parsed[2],0);
send_reliable(p, "notrapid", 0);
}
}
else if(parsed[2]=="blue_tacticle_shotgun")
{
if(parsed[2]!=p.weapon_name)
{
p.weapon_name=parsed[2];
if(p.weapon_ammos>0)
p.inv_add_item(p.weapon_ammo_type, p.weapon_ammos);
p.firetimer=1800;
p.weapon_ammos=0;
p.weapon_ammo_type="shotgun_shell";
p.weapon_copasity=6;
send_reliable(p,parsed[2],0);
send_reliable(p, "notrapid", 0);
}
}
else if(parsed[2]=="drum_shotgun")
{
if(parsed[2]!=p.weapon_name)
{
p.weapon_name=parsed[2];
if(p.weapon_ammos>0)
p.inv_add_item(p.weapon_ammo_type, p.weapon_ammos);
p.firetimer=1800;
p.weapon_ammos=0;
p.weapon_ammo_type="shotgun_shell";
p.weapon_copasity=4;
send_reliable(p,parsed[2],0);
send_reliable(p, "notrapid", 0);
}
}
else if(parsed[2]=="gold_burst_assault_rifle")
{
if(parsed[2]!=p.weapon_name)
{
p.weapon_name=parsed[2];
if(p.weapon_ammos>0)
p.inv_add_item(p.weapon_ammo_type, p.weapon_ammos);
p.firetimer=1900;
p.weapon_ammos=0;
p.weapon_ammo_type="12.7mm_ammo";
p.weapon_copasity=15;
send_reliable(p,parsed[2],0);
send_reliable(p, "rapid", 0);
}
}
else if(parsed[2]=="gold_drum_gun")
{
if(parsed[2]!=p.weapon_name)
{
p.weapon_name=parsed[2];
if(p.weapon_ammos>0)
p.inv_add_item(p.weapon_ammo_type, p.weapon_ammos);
p.firetimer=1600;
p.weapon_ammos=0;
p.weapon_ammo_type="7.62mm_ammo";
p.weapon_copasity=8;
send_reliable(p,parsed[2],0);
send_reliable(p, "notrapid", 0);
}
}
else if(parsed[2]=="gold_heavy_assault_rifle")
{
if(parsed[2]!=p.weapon_name)
{
p.weapon_name=parsed[2];
if(p.weapon_ammos>0)
p.inv_add_item(p.weapon_ammo_type, p.weapon_ammos);
p.firetimer=2900;
p.weapon_ammos=0;
p.weapon_ammo_type="12.7mm_ammo";
p.weapon_copasity=2;
send_reliable(p,parsed[2],0);
send_reliable(p, "notrapid", 0);
}
}
else if(parsed[2]=="gold_scar")
{
if(parsed[2]!=p.weapon_name)
{
p.weapon_name=parsed[2];
if(p.weapon_ammos>0)
p.inv_add_item(p.weapon_ammo_type, p.weapon_ammos);
p.firetimer=2100;
p.weapon_ammos=0;
p.weapon_ammo_type="7.62mm_ammo";
p.weapon_copasity=5;
send_reliable(p,parsed[2],0);
send_reliable(p, "notrapid", 0);
}
}
else if(parsed[2]=="gold_tacticle_shotgun")
{
if(parsed[2]!=p.weapon_name)
{
p.weapon_name=parsed[2];
if(p.weapon_ammos>0)
p.inv_add_item(p.weapon_ammo_type, p.weapon_ammos);
p.firetimer=1700;
p.weapon_ammos=0;
p.weapon_ammo_type="shotgun_shell";
p.weapon_copasity=6;
send_reliable(p,parsed[2],0);
send_reliable(p, "notrapid", 0);
}
}
else if(parsed[2]=="heavy_sniper")
{
if(parsed[2]!=p.weapon_name)
{
p.weapon_name=parsed[2];
if(p.weapon_ammos>0)
p.inv_add_item(p.weapon_ammo_type, p.weapon_ammos);
p.firetimer=3900;
p.weapon_ammos=0;
p.weapon_ammo_type="12.7mm_ammo";
p.weapon_copasity=1;
send_reliable(p,parsed[2],0);
send_reliable(p, "notrapid", 0);
}
}
else if(parsed[2]=="colt_m9")
{
if(parsed[2]!=p.weapon_name)
{
p.weapon_name=parsed[2];
if(p.weapon_ammos>0)
p.inv_add_item(p.weapon_ammo_type, p.weapon_ammos);
p.firetimer=340;
p.weapon_ammos=0;
p.weapon_ammo_type="9mm_ammo";
p.weapon_copasity=12;
send_reliable(p,parsed[2],0);
send_reliable(p, "notrapid", 0);
}
}
else if(parsed[2]=="colt_m19")
{
if(parsed[2]!=p.weapon_name)
{
p.weapon_name=parsed[2];
if(p.weapon_ammos>0)
p.inv_add_item(p.weapon_ammo_type, p.weapon_ammos);
p.firetimer=333;
p.weapon_ammos=0;
p.weapon_ammo_type="9mm_ammo";
p.weapon_copasity=16;
send_reliable(p,parsed[2],0);
send_reliable(p, "notrapid", 0);
}
}
else if(parsed[2]=="e9pistol")
{
if(parsed[2]!=p.weapon_name)
{
p.weapon_name=parsed[2];
if(p.weapon_ammos>0)
p.inv_add_item(p.weapon_ammo_type, p.weapon_ammos);
p.firetimer=370;
p.weapon_ammos=0;
p.weapon_ammo_type="9mm_ammo";
p.weapon_copasity=15;
send_reliable(p,parsed[2],0);
send_reliable(p, "notrapid", 0);
}
}
else if(parsed[2]=="e20shotgun")
{
if(parsed[2]!=p.weapon_name)
{
p.weapon_name=parsed[2];
if(p.weapon_ammos>0)
p.inv_add_item(p.weapon_ammo_type, p.weapon_ammos);
p.firetimer=2410;
p.weapon_ammos=0;
p.weapon_ammo_type="shotgun_shell";
p.weapon_copasity=3;
send_reliable(p,parsed[2],0);
send_reliable(p, "notrapid", 0);
}
}
else if(parsed[2]=="e235shotgun")
{
if(parsed[2]!=p.weapon_name)
{
p.weapon_name=parsed[2];
if(p.weapon_ammos>0)
p.inv_add_item(p.weapon_ammo_type, p.weapon_ammos);
p.firetimer=1823;
p.weapon_ammos=0;
p.weapon_ammo_type="shotgun_shell";
p.weapon_copasity=6;
send_reliable(p,parsed[2],0);
send_reliable(p, "notrapid", 0);
}
}
else if(parsed[2]=="mpt_special_shotgun")
{
if(parsed[2]!=p.weapon_name)
{
p.weapon_name=parsed[2];
if(p.weapon_ammos>0)
p.inv_add_item(p.weapon_ammo_type, p.weapon_ammos);
p.firetimer=1241;
p.weapon_ammos=0;
p.weapon_ammo_type="shotgun_shell";
p.weapon_copasity=6;
send_reliable(p,parsed[2],0);
send_reliable(p, "notrapid", 0);
}
}
else if(parsed[2]=="mb3shotgun")
{
if(parsed[2]!=p.weapon_name)
{
p.weapon_name=parsed[2];
if(p.weapon_ammos>0)
p.inv_add_item(p.weapon_ammo_type, p.weapon_ammos);
p.firetimer=3470;
p.weapon_ammos=0;
p.weapon_ammo_type="shotgun_shell";
p.weapon_copasity=7;
send_reliable(p,parsed[2],0);
send_reliable(p, "notrapid", 0);
}
}
else if(parsed[2]=="mb5shotgun")
{
if(parsed[2]!=p.weapon_name)
{
p.weapon_name=parsed[2];
if(p.weapon_ammos>0)
p.inv_add_item(p.weapon_ammo_type, p.weapon_ammos);
p.firetimer=3670;
p.weapon_ammos=0;
p.weapon_ammo_type="shotgun_shell";
p.weapon_copasity=8;
send_reliable(p,parsed[2],0);
send_reliable(p, "notrapid", 0);
}
}
else if(parsed[2]=="mp5machinegun")
{
if(parsed[2]!=p.weapon_name)
{
p.weapon_name=parsed[2];
if(p.weapon_ammos>0)
p.inv_add_item(p.weapon_ammo_type, p.weapon_ammos);
p.firetimer=100;
p.weapon_ammos=0;
p.weapon_ammo_type="5.56mm_ammo";
p.weapon_copasity=25;
send_reliable(p,parsed[2],0);
send_reliable(p, "rapid", 0);
}
}
else if(parsed[2]=="tranquilizer_gun")
{
if(parsed[2]!=p.weapon_name)
{
p.weapon_name=parsed[2];
if(p.weapon_ammos>0)
p.inv_add_item(p.weapon_ammo_type, p.weapon_ammos);
p.firetimer=3020;
p.weapon_ammos=0;
p.weapon_ammo_type="tranquilizer";
p.weapon_copasity=1;
send_reliable(p,parsed[2],0);
send_reliable(p, "notrapid", 0);
}
}
else if(parsed[2]=="famas_g2")
{
if(parsed[2]!=p.weapon_name)
{
p.weapon_name=parsed[2];
if(p.weapon_ammos>0)
p.inv_add_item(p.weapon_ammo_type, p.weapon_ammos);
p.firetimer=140;
p.weapon_ammos=0;
p.weapon_ammo_type="5.56mm_ammo";
p.weapon_copasity=25;
send_reliable(p,parsed[2],0);
send_reliable(p, "rapid", 0);
}
}
else if(parsed[2]=="k222rifle")
{
if(parsed[2]!=p.weapon_name)
{
p.weapon_name=parsed[2];
if(p.weapon_ammos>0)
p.inv_add_item(p.weapon_ammo_type, p.weapon_ammos);
p.firetimer=3850;
p.weapon_ammos=0;
p.weapon_ammo_type="12.7mm_ammo";
p.weapon_copasity=2;
send_reliable(p,parsed[2],0);
send_reliable(p, "notrapid", 0);
}
}
else if(parsed[2]=="long_bow")
{
if(parsed[2]!=p.weapon_name)
{
p.weapon_name=parsed[2];
if(p.weapon_ammos>0)
p.inv_add_item(p.weapon_ammo_type, p.weapon_ammos);
p.firetimer=270;
p.weapon_ammos=0;
p.weapon_ammo_type="arrow";
p.weapon_copasity=1;
send_reliable(p,parsed[2],0);
send_reliable(p, "notrapid", 0);
}
}
else if(parsed[2]=="p3hunting_shotgun")
{
if(parsed[2]!=p.weapon_name)
{
p.weapon_name=parsed[2];
if(p.weapon_ammos>0)
p.inv_add_item(p.weapon_ammo_type, p.weapon_ammos);
p.firetimer=3400;
p.weapon_ammos=0;
p.weapon_ammo_type="shotgun_shell";
p.weapon_copasity=3;
send_reliable(p,parsed[2],0);
send_reliable(p, "notrapid", 0);
}
}
else if(parsed[2]=="taser")
{
if(parsed[2]!=p.weapon_name)
{
p.weapon_name=parsed[2];
if(p.weapon_ammos>0)
p.inv_add_item(p.weapon_ammo_type, p.weapon_ammos);
p.firetimer=1300;
p.weapon_ammos=0;
p.weapon_ammo_type="battery";
p.weapon_copasity=3;
send_reliable(p,parsed[2],0);
send_reliable(p, "notrapid", 0);
}
}
else if(parsed[2]=="tiny_mg")
{
if(parsed[2]!=p.weapon_name)
{
p.weapon_name=parsed[2];
if(p.weapon_ammos>0)
p.inv_add_item(p.weapon_ammo_type, p.weapon_ammos);
p.firetimer=80;
p.weapon_ammos=0;
p.weapon_ammo_type="5.56mm_ammo";
p.weapon_copasity=15;
send_reliable(p,parsed[2],0);
send_reliable(p, "rapid", 0);
}
}
else if(parsed[2]=="dagger")
{
if(parsed[2]!=p.weapon_name)
{
p.weapon_name=parsed[2];
if(p.weapon_ammos>0)
p.inv_add_item(p.weapon_ammo_type, p.weapon_ammos);
p.firetimer=805;
p.weapon_ammos=0;
p.weapon_ammo_type="";
p.weapon_copasity=0;
send_reliable(p,parsed[2],0);
send_reliable(p, "notrapid", 0);
}
}
else if(parsed[2]=="hook")
{
if(parsed[2]!=p.weapon_name)
{
p.weapon_name=parsed[2];
if(p.weapon_ammos>0)
p.inv_add_item(p.weapon_ammo_type, p.weapon_ammos);
p.firetimer=410;
p.weapon_ammos=0;
p.weapon_ammo_type="";
p.weapon_copasity=0;
send_reliable(p,parsed[2],0);
send_reliable(p, "rapid", 0);
}
}
else if(parsed[2]=="iron_shovel")
{
if(parsed[2]!=p.weapon_name)
{
p.weapon_name=parsed[2];
if(p.weapon_ammos>0)
p.inv_add_item(p.weapon_ammo_type, p.weapon_ammos);
p.firetimer=1400;
p.weapon_ammos=0;
p.weapon_ammo_type="";
p.weapon_copasity=0;
send_reliable(p,parsed[2],0);
send_reliable(p, "notrapid", 0);
}
}
else if(parsed[2]=="machete")
{
if(parsed[2]!=p.weapon_name)
{
p.weapon_name=parsed[2];
if(p.weapon_ammos>0)
p.inv_add_item(p.weapon_ammo_type, p.weapon_ammos);
p.firetimer=525;
p.weapon_ammos=0;
p.weapon_ammo_type="";
p.weapon_copasity=0;
send_reliable(p,parsed[2],0);
send_reliable(p, "notrapid", 0);
}
}
else if(parsed[2]=="small_dagger")
{
if(parsed[2]!=p.weapon_name)
{
p.weapon_name=parsed[2];
if(p.weapon_ammos>0)
p.inv_add_item(p.weapon_ammo_type, p.weapon_ammos);
p.firetimer=125;
p.weapon_ammos=0;
p.weapon_ammo_type="";
p.weapon_copasity=0;
send_reliable(p,parsed[2],0);
send_reliable(p, "notrapid", 0);
}
}
else if(parsed[2]=="sword")
{
if(parsed[2]!=p.weapon_name)
{
p.weapon_name=parsed[2];
if(p.weapon_ammos>0)
p.inv_add_item(p.weapon_ammo_type, p.weapon_ammos);
p.firetimer=490;
p.weapon_ammos=0;
p.weapon_ammo_type="";
p.weapon_copasity=0;
send_reliable(p,parsed[2],0);
send_reliable(p, "notrapid", 0);
}
}
else if(parsed[2]=="long_sword")
{
if(parsed[2]!=p.weapon_name)
{
p.weapon_name=parsed[2];
if(p.weapon_ammos>0)
p.inv_add_item(p.weapon_ammo_type, p.weapon_ammos);
p.firetimer=410;
p.weapon_ammos=0;
p.weapon_ammo_type="";
p.weapon_copasity=0;
send_reliable(p,parsed[2],0);
send_reliable(p, "notrapid", 0);
}
}
else if(parsed[2]=="short_sword")
{
if(parsed[2]!=p.weapon_name)
{
p.weapon_name=parsed[2];
if(p.weapon_ammos>0)
p.inv_add_item(p.weapon_ammo_type, p.weapon_ammos);
p.firetimer=330;
p.weapon_ammos=0;
p.weapon_ammo_type="";
p.weapon_copasity=0;
send_reliable(p,parsed[2],0);
send_reliable(p, "notrapid", 0);
}
}
else if(parsed[2]=="blake_sword")
{
if(parsed[2]!=p.weapon_name)
{
p.weapon_name=parsed[2];
if(p.weapon_ammos>0)
p.inv_add_item(p.weapon_ammo_type, p.weapon_ammos);
p.firetimer=350;
p.weapon_ammos=0;
p.weapon_ammo_type="";
p.weapon_copasity=0;
send_reliable(p,parsed[2],0);
send_reliable(p, "notrapid", 0);
}
}
else if(parsed[2]=="wip")
{
if(parsed[2]!=p.weapon_name)
{
p.weapon_name=parsed[2];
if(p.weapon_ammos>0)
p.inv_add_item(p.weapon_ammo_type, p.weapon_ammos);
p.firetimer=610;
p.weapon_ammos=0;
p.weapon_ammo_type="";
p.weapon_copasity=0;
send_reliable(p,parsed[2],0);
send_reliable(p, "notrapid", 0);
}
}
else if(parsed[2]=="ar15machinegun")
{
if(parsed[2]!=p.weapon_name)
{
p.weapon_name=parsed[2];
if(p.weapon_ammos>0)
p.inv_add_item(p.weapon_ammo_type, p.weapon_ammos);
p.firetimer=100;
p.weapon_ammos=0;
p.weapon_ammo_type="5.56mm_ammo";
p.weapon_copasity=15;
send_reliable(p,parsed[2],0);
send_reliable(p, "rapid", 0);
}
}
else if(parsed[2]=="barett_m1500sniper_rifle")
{
if(parsed[2]!=p.weapon_name)
{
p.weapon_name=parsed[2];
if(p.weapon_ammos>0)
p.inv_add_item(p.weapon_ammo_type, p.weapon_ammos);
p.firetimer=2880;
p.weapon_ammos=0;
p.weapon_ammo_type="12.7mm_ammo";
p.weapon_copasity=3;
send_reliable(p,parsed[2],0);
send_reliable(p, "notrapid", 0);
}
}
else if(parsed[2]=="blz5machinegun")
{
if(parsed[2]!=p.weapon_name)
{
p.weapon_name=parsed[2];
if(p.weapon_ammos>0)
p.inv_add_item(p.weapon_ammo_type, p.weapon_ammos);
p.firetimer=100;
p.weapon_ammos=0;
p.weapon_ammo_type="5.56mm_ammo";
p.weapon_copasity=28;
send_reliable(p,parsed[2],0);
send_reliable(p, "rapid", 0);
}
}
else if(parsed[2]=="browning_m2heavy_machinegun")
{
if(parsed[2]!=p.weapon_name)
{
p.weapon_name=parsed[2];
if(p.weapon_ammos>0)
p.inv_add_item(p.weapon_ammo_type, p.weapon_ammos);
p.firetimer=100;
p.weapon_ammos=0;
p.weapon_ammo_type="7.62mm_ammo";
p.weapon_copasity=50;
send_reliable(p,parsed[2],0);
send_reliable(p, "rapid", 0);
}
}
else if(parsed[2]=="chainsaw")
{
if(parsed[2]!=p.weapon_name)
{
p.weapon_name=parsed[2];
if(p.weapon_ammos>0)
p.inv_add_item(p.weapon_ammo_type, p.weapon_ammos);
p.firetimer=750;
p.weapon_ammos=0;
p.weapon_ammo_type="battery";
p.weapon_copasity=3;
send_reliable(p,parsed[2],0);
send_reliable(p, "notrapid", 0);
}
}
else if(parsed[2]=="crossbow")
{
if(parsed[2]!=p.weapon_name)
{
p.weapon_name=parsed[2];
if(p.weapon_ammos>0)
p.inv_add_item(p.weapon_ammo_type, p.weapon_ammos);
p.firetimer=230;
p.weapon_ammos=0;
p.weapon_ammo_type="arrow";
p.weapon_copasity=5;
send_reliable(p,parsed[2],0);
send_reliable(p, "notrapid", 0);
}
}
else if(parsed[2]=="fn2000pistol")
{
if(parsed[2]!=p.weapon_name)
{
p.weapon_name=parsed[2];
if(p.weapon_ammos>0)
p.inv_add_item(p.weapon_ammo_type, p.weapon_ammos);
p.firetimer=290;
p.weapon_ammos=0;
p.weapon_ammo_type="9mm_ammo";
p.weapon_copasity=15;
send_reliable(p,parsed[2],0);
send_reliable(p, "notrapid", 0);
}
}
else if(parsed[2]=="fnm_pistol")
{
if(parsed[2]!=p.weapon_name)
{
p.weapon_name=parsed[2];
if(p.weapon_ammos>0)
p.inv_add_item(p.weapon_ammo_type, p.weapon_ammos);
p.firetimer=275;
p.weapon_ammos=0;
p.weapon_ammo_type="9mm_ammo";
p.weapon_copasity=18;
send_reliable(p,parsed[2],0);
send_reliable(p, "notrapid", 0);
}
}
else if(parsed[2]=="g36pistol")
{
if(parsed[2]!=p.weapon_name)
{
p.weapon_name=parsed[2];
if(p.weapon_ammos>0)
p.inv_add_item(p.weapon_ammo_type, p.weapon_ammos);
p.firetimer=256;
p.weapon_ammos=0;
p.weapon_ammo_type="9mm_ammo";
p.weapon_copasity=12;
send_reliable(p,parsed[2],0);
send_reliable(p, "notrapid", 0);
}
}
else if(parsed[2]=="gouse_pistol")
{
if(parsed[2]!=p.weapon_name)
{
p.weapon_name=parsed[2];
if(p.weapon_ammos>0)
p.inv_add_item(p.weapon_ammo_type, p.weapon_ammos);
p.firetimer=234;
p.weapon_ammos=0;
p.weapon_ammo_type="9mm_ammo";
p.weapon_copasity=9;
send_reliable(p,parsed[2],0);
send_reliable(p, "notrapid", 0);
}
}
else if(parsed[2]=="hk_machinegun")
{
if(parsed[2]!=p.weapon_name)
{
p.weapon_name=parsed[2];
if(p.weapon_ammos>0)
p.inv_add_item(p.weapon_ammo_type, p.weapon_ammos);
p.firetimer=100;
p.weapon_ammos=0;
p.weapon_ammo_type="5.56mm_ammo";
p.weapon_copasity=18;
send_reliable(p,parsed[2],0);
send_reliable(p, "notrapid", 0);
}
}
else if(parsed[2]=="lr12pistol")
{
if(parsed[2]!=p.weapon_name)
{
p.weapon_name=parsed[2];
if(p.weapon_ammos>0)
p.inv_add_item(p.weapon_ammo_type, p.weapon_ammos);
p.firetimer=280;
p.weapon_ammos=0;
p.weapon_ammo_type="9mm_ammo";
p.weapon_copasity=12;
send_reliable(p,parsed[2],0);
send_reliable(p, "notrapid", 0);
}
}
else if(parsed[2]=="m9pistol")
{
if(parsed[2]!=p.weapon_name)
{
p.weapon_name=parsed[2];
if(p.weapon_ammos>0)
p.inv_add_item(p.weapon_ammo_type, p.weapon_ammos);
p.firetimer=310;
p.weapon_ammos=0;
p.weapon_ammo_type="9mm_ammo";
p.weapon_copasity=12;
send_reliable(p,parsed[2],0);
send_reliable(p, "notrapid", 0);
}
}
else if(parsed[2]=="m10machinegun")
{
if(parsed[2]!=p.weapon_name)
{
p.weapon_name=parsed[2];
if(p.weapon_ammos>0)
p.inv_add_item(p.weapon_ammo_type, p.weapon_ammos);
p.firetimer=100;
p.weapon_ammos=0;
p.weapon_ammo_type="5.56mm_ammo";
p.weapon_copasity=25;
send_reliable(p,parsed[2],0);
send_reliable(p, "rapid", 0);
}
}
else if(parsed[2]=="m16machinegun")
{
if(parsed[2]!=p.weapon_name)
{
p.weapon_name=parsed[2];
if(p.weapon_ammos>0)
p.inv_add_item(p.weapon_ammo_type, p.weapon_ammos);
p.firetimer=100;
p.weapon_ammos=0;
p.weapon_ammo_type="5.56mm_ammo";
p.weapon_copasity=20;
send_reliable(p,parsed[2],0);
send_reliable(p, "rapid", 0);
}
}
else if(parsed[2]=="m125assault_rifle")
{
if(parsed[2]!=p.weapon_name)
{
p.weapon_name=parsed[2];
if(p.weapon_ammos>0)
p.inv_add_item(p.weapon_ammo_type, p.weapon_ammos);
p.firetimer=1980;
p.weapon_ammos=0;
p.weapon_ammo_type="12.7mm_ammo";
p.weapon_copasity=2;
send_reliable(p,parsed[2],0);
send_reliable(p, "notrapid", 0);
}
}
else if(parsed[2]=="m125minigun")
{
if(parsed[2]!=p.weapon_name)
{
p.weapon_name=parsed[2];
if(p.weapon_ammos>0)
p.inv_add_item(p.weapon_ammo_type, p.weapon_ammos);
p.firetimer=150;
p.weapon_ammos=0;
p.weapon_ammo_type="7.62mm_ammo";
p.weapon_copasity=45;
send_reliable(p,parsed[2],0);
send_reliable(p, "rapid", 0);
}
}
else if(parsed[2]=="m152minigun")
{
if(parsed[2]!=p.weapon_name)
{
p.weapon_name=parsed[2];
if(p.weapon_ammos>0)
p.inv_add_item(p.weapon_ammo_type, p.weapon_ammos);
p.firetimer=100;
p.weapon_ammos=0;
p.weapon_ammo_type="7.62mm_ammo";
p.weapon_copasity=50;
send_reliable(p,parsed[2],0);
send_reliable(p, "rapid", 0);
}
}
else if(parsed[2]=="m155minigun")
{
if(parsed[2]!=p.weapon_name)
{
p.weapon_name=parsed[2];
if(p.weapon_ammos>0)
p.inv_add_item(p.weapon_ammo_type, p.weapon_ammos);
p.firetimer=100;
p.weapon_ammos=0;
p.weapon_ammo_type="7.62mm_ammo";
p.weapon_copasity=55;
send_reliable(p,parsed[2],0);
send_reliable(p, "rapid", 0);
}
}
else if(parsed[2]=="m560sniper_rifle")
{
if(parsed[2]!=p.weapon_name)
{
p.weapon_name=parsed[2];
if(p.weapon_ammos>0)
p.inv_add_item(p.weapon_ammo_type, p.weapon_ammos);
p.firetimer=1680;
p.weapon_ammos=0;
p.weapon_ammo_type="12.7mm_ammo";
p.weapon_copasity=3;
send_reliable(p,parsed[2],0);
send_reliable(p, "notrapid", 0);
}
}
else if(parsed[2]=="mg4machinegun")
{
if(parsed[2]!=p.weapon_name)
{
p.weapon_name=parsed[2];
if(p.weapon_ammos>0)
p.inv_add_item(p.weapon_ammo_type, p.weapon_ammos);
p.firetimer=100;
p.weapon_ammos=0;
p.weapon_ammo_type="5.56mm_ammo";
p.weapon_copasity=25;
send_reliable(p,parsed[2],0);
send_reliable(p, "rapid", 0);
}
}
else if(parsed[2]=="mj420machinegun")
{
if(parsed[2]!=p.weapon_name)
{
p.weapon_name=parsed[2];
if(p.weapon_ammos>0)
p.inv_add_item(p.weapon_ammo_type, p.weapon_ammos);
p.firetimer=100;
p.weapon_ammos=0;
p.weapon_ammo_type="5.56mm_ammo";
p.weapon_copasity=23;
send_reliable(p,parsed[2],0);
send_reliable(p, "rapid", 0);
}
}
else if(parsed[2]=="mk_long_machinegun")
{
if(parsed[2]!=p.weapon_name)
{
p.weapon_name=parsed[2];
if(p.weapon_ammos>0)
p.inv_add_item(p.weapon_ammo_type, p.weapon_ammos);
p.firetimer=100;
p.weapon_ammos=0;
p.weapon_ammo_type="5.56mm_ammo";
p.weapon_copasity=35;
send_reliable(p,parsed[2],0);
send_reliable(p, "rapid", 0);
}
}
else if(parsed[2]=="mk52assault_rifle")
{
if(parsed[2]!=p.weapon_name)
{
p.weapon_name=parsed[2];
if(p.weapon_ammos>0)
p.inv_add_item(p.weapon_ammo_type, p.weapon_ammos);
p.firetimer=1880;
p.weapon_ammos=0;
p.weapon_ammo_type="12.7mm_ammo";
p.weapon_copasity=3;
send_reliable(p,parsed[2],0);
send_reliable(p, "notrapid", 0);
}
}
else if(parsed[2]=="mk215machinegun")
{
if(parsed[2]!=p.weapon_name)
{
p.weapon_name=parsed[2];
if(p.weapon_ammos>0)
p.inv_add_item(p.weapon_ammo_type, p.weapon_ammos);
p.firetimer=100;
p.weapon_ammos=0;
p.weapon_ammo_type="5.56mm_ammo";
p.weapon_copasity=25;
send_reliable(p,parsed[2],0);
send_reliable(p, "rapid", 0);
}
}
else if(parsed[2]=="mkv43machinegun")
{
if(parsed[2]!=p.weapon_name)
{
p.weapon_name=parsed[2];
if(p.weapon_ammos>0)
p.inv_add_item(p.weapon_ammo_type, p.weapon_ammos);
p.firetimer=100;
p.weapon_ammos=0;
p.weapon_ammo_type="5.56mm_ammo";
p.weapon_copasity=15;
send_reliable(p,parsed[2],0);
send_reliable(p, "rapid", 0);
}
}
else if(parsed[2]=="ml7rifle")
{
if(parsed[2]!=p.weapon_name)
{
p.weapon_name=parsed[2];
if(p.weapon_ammos>0)
p.inv_add_item(p.weapon_ammo_type, p.weapon_ammos);
p.firetimer=980;
p.weapon_ammos=0;
p.weapon_ammo_type="12.7mm_ammo";
p.weapon_copasity=6;
send_reliable(p,parsed[2],0);
send_reliable(p, "notrapid", 0);
}
}
else if(parsed[2]=="ml15rifle")
{
if(parsed[2]!=p.weapon_name)
{
p.weapon_name=parsed[2];
if(p.weapon_ammos>0)
p.inv_add_item(p.weapon_ammo_type, p.weapon_ammos);
p.firetimer=1090;
p.weapon_ammos=0;
p.weapon_ammo_type="12.7mm_ammo";
p.weapon_copasity=8;
send_reliable(p,parsed[2],0);
send_reliable(p, "notrapid", 0);
}
}
else if(parsed[2]=="mlk290rifle")
{
if(parsed[2]!=p.weapon_name)
{
p.weapon_name=parsed[2];
if(p.weapon_ammos>0)
p.inv_add_item(p.weapon_ammo_type, p.weapon_ammos);
p.firetimer=1380;
p.weapon_ammos=0;
p.weapon_ammo_type="12.7mm_ammo";
p.weapon_copasity=5;
send_reliable(p,parsed[2],0);
send_reliable(p, "notrapid", 0);
}
}
else if(parsed[2]=="mlr_assault_rifle")
{
if(parsed[2]!=p.weapon_name)
{
p.weapon_name=parsed[2];
if(p.weapon_ammos>0)
p.inv_add_item(p.weapon_ammo_type, p.weapon_ammos);
p.firetimer=100;
p.weapon_ammos=0;
p.weapon_ammo_type="7.62mm_ammo";
p.weapon_copasity=35;
send_reliable(p,parsed[2],0);
send_reliable(p, "rapid", 0);
}
}
else if(parsed[2]=="mp12machinegun")
{
if(parsed[2]!=p.weapon_name)
{
p.weapon_name=parsed[2];
if(p.weapon_ammos>0)
p.inv_add_item(p.weapon_ammo_type, p.weapon_ammos);
p.firetimer=100;
p.weapon_ammos=0;
p.weapon_ammo_type="5.56mm_ammo";
p.weapon_copasity=17;
send_reliable(p,parsed[2],0);
send_reliable(p, "rapid", 0);
}
}
else if(parsed[2]=="msb530shotgun")
{
if(parsed[2]!=p.weapon_name)
{
p.weapon_name=parsed[2];
if(p.weapon_ammos>0)
p.inv_add_item(p.weapon_ammo_type, p.weapon_ammos);
p.firetimer=1070;
p.weapon_ammos=0;
p.weapon_ammo_type="shotgun_shell";
p.weapon_copasity=9;
send_reliable(p,parsed[2],0);
send_reliable(p, "notrapid", 0);
}
}
else if(parsed[2]=="pcs_handgun")
{
if(parsed[2]!=p.weapon_name)
{
p.weapon_name=parsed[2];
if(p.weapon_ammos>0)
p.inv_add_item(p.weapon_ammo_type, p.weapon_ammos);
p.firetimer=100;
p.weapon_ammos=0;
p.weapon_ammo_type="9mm_ammo";
p.weapon_copasity=6;
send_reliable(p,parsed[2],0);
send_reliable(p, "notrapid", 0);
}
}
else if(parsed[2]=="rpg_launcher")
{
if(parsed[2]!=p.weapon_name)
{
p.weapon_name=parsed[2];
if(p.weapon_ammos>0)
p.inv_add_item(p.weapon_ammo_type, p.weapon_ammos);
p.firetimer=3980;
p.weapon_ammos=0;
p.weapon_ammo_type="rpg";
p.weapon_copasity=1;
send_reliable(p,parsed[2],0);
send_reliable(p, "notrapid", 0);
}
}
else if(parsed[2]=="rocket_launcher")
{
if(parsed[2]!=p.weapon_name)
{
p.weapon_name=parsed[2];
if(p.weapon_ammos>0)
p.inv_add_item(p.weapon_ammo_type, p.weapon_ammos);
p.firetimer=1000;
p.weapon_ammos=0;
p.weapon_ammo_type="rocket";
p.weapon_copasity=1;
send_reliable(p,parsed[2],0);
send_reliable(p, "rapid", 0);
}
}
else if(parsed[2]=="rpg7")
{
if(parsed[2]!=p.weapon_name)
{
p.weapon_name=parsed[2];
if(p.weapon_ammos>0)
p.inv_add_item(p.weapon_ammo_type, p.weapon_ammos);
p.firetimer=3630;
p.weapon_ammos=0;
p.weapon_ammo_type="rpg";
p.weapon_copasity=2;
send_reliable(p,parsed[2],0);
send_reliable(p, "notrapid", 0);
}
}
else if(parsed[2]=="nak_nk1000_decimater")
{
if(parsed[2]!=p.weapon_name)
{
p.weapon_name=parsed[2];
if(p.weapon_ammos>0)
p.inv_add_item(p.weapon_ammo_type, p.weapon_ammos);
p.firetimer=160;
p.weapon_ammos=0;
p.weapon_ammo_type="12.7mm_ammo";
p.weapon_copasity=100;
send_reliable(p,parsed[2],0);
send_reliable(p, "notrapid", 0);
}
}
else if(parsed[2]=="ruga22revolver")
{
if(parsed[2]!=p.weapon_name)
{
p.weapon_name=parsed[2];
if(p.weapon_ammos>0)
p.inv_add_item(p.weapon_ammo_type, p.weapon_ammos);
p.firetimer=480;
p.weapon_ammos=0;
p.weapon_ammo_type="9mm_ammo";
p.weapon_copasity=5;
send_reliable(p,parsed[2],0);
send_reliable(p, "notrapid", 0);
}
}
else if(parsed[2]=="s55assault_rifle")
{
if(parsed[2]!=p.weapon_name)
{
p.weapon_name=parsed[2];
if(p.weapon_ammos>0)
p.inv_add_item(p.weapon_ammo_type, p.weapon_ammos);
p.firetimer=1580;
p.weapon_ammos=0;
p.weapon_ammo_type="12.7mm_ammo";
p.weapon_copasity=7;
send_reliable(p,parsed[2],0);
send_reliable(p, "notrapid", 0);
}
}
else if(parsed[2]=="s110assault_rifle")
{
if(parsed[2]!=p.weapon_name)
{
p.weapon_name=parsed[2];
if(p.weapon_ammos>0)
p.inv_add_item(p.weapon_ammo_type, p.weapon_ammos);
p.firetimer=1480;
p.weapon_ammos=0;
p.weapon_ammo_type="12.7mm_ammo";
p.weapon_copasity=7;
send_reliable(p,parsed[2],0);
send_reliable(p, "notrapid", 0);
}
}
else if(parsed[2]=="sp5shotgun")
{
if(parsed[2]!=p.weapon_name)
{
p.weapon_name=parsed[2];
if(p.weapon_ammos>0)
p.inv_add_item(p.weapon_ammo_type, p.weapon_ammos);
p.firetimer=980;
p.weapon_ammos=0;
p.weapon_ammo_type="shotgun_shell";
p.weapon_copasity=6;
send_reliable(p,parsed[2],0);
send_reliable(p, "notrapid", 0);
}
}
else if(parsed[2]=="sp150shotgun")
{
if(parsed[2]!=p.weapon_name)
{
p.weapon_name=parsed[2];
if(p.weapon_ammos>0)
p.inv_add_item(p.weapon_ammo_type, p.weapon_ammos);
p.firetimer=1010;
p.weapon_ammos=0;
p.weapon_ammo_type="shotgun_shell";
p.weapon_copasity=8;
send_reliable(p,parsed[2],0);
send_reliable(p, "notrapid", 0);
}
}
else if(parsed[2]=="stp106_long_barreled_pistol")
{
if(parsed[2]!=p.weapon_name)
{
p.weapon_name=parsed[2];
if(p.weapon_ammos>0)
p.inv_add_item(p.weapon_ammo_type, p.weapon_ammos);
p.firetimer=680;
p.weapon_ammos=0;
p.weapon_ammo_type="12.7mm_ammo";
p.weapon_copasity=15;
send_reliable(p,parsed[2],0);
send_reliable(p, "notrapid", 0);
}
}
else if(parsed[2]=="str301machinegun")
{
if(parsed[2]!=p.weapon_name)
{
p.weapon_name=parsed[2];
if(p.weapon_ammos>0)
p.inv_add_item(p.weapon_ammo_type, p.weapon_ammos);
p.firetimer=100;
p.weapon_ammos=0;
p.weapon_ammo_type="5.56mm_ammo";
p.weapon_copasity=25;
send_reliable(p,parsed[2],0);
send_reliable(p, "rapid", 0);
}
}
else if(parsed[2]=="m90machinegun")
{
if(parsed[2]!=p.weapon_name)
{
p.weapon_name=parsed[2];
if(p.weapon_ammos>0)
p.inv_add_item(p.weapon_ammo_type, p.weapon_ammos);
p.firetimer=100;
p.weapon_ammos=0;
p.weapon_ammo_type="5.56mm_ammo";
p.weapon_copasity=32;
send_reliable(p,parsed[2],0);
send_reliable(p, "rapid", 0);
}
}
else if(parsed[2]=="qt_machinegun")
{
if(parsed[2]!=p.weapon_name)
{
p.weapon_name=parsed[2];
if(p.weapon_ammos>0)
p.inv_add_item(p.weapon_ammo_type, p.weapon_ammos);
p.firetimer=100;
p.weapon_ammos=0;
p.weapon_ammo_type="5.56mm_ammo";
p.weapon_copasity=25;
send_reliable(p,parsed[2],0);
send_reliable(p, "rapid", 0);
}
}
else if(parsed[2]=="pst500shotgun")
{
if(parsed[2]!=p.weapon_name)
{
p.weapon_name=parsed[2];
if(p.weapon_ammos>0)
p.inv_add_item(p.weapon_ammo_type, p.weapon_ammos);
p.firetimer=2980;
p.weapon_ammos=0;
p.weapon_ammo_type="shotgun_shell";
p.weapon_copasity=3;
send_reliable(p,parsed[2],0);
send_reliable(p, "notrapid", 0);
}
}
else if(parsed[2]=="sfx12machinegun")
{
if(parsed[2]!=p.weapon_name)
{
p.weapon_name=parsed[2];
if(p.weapon_ammos>0)
p.inv_add_item(p.weapon_ammo_type, p.weapon_ammos);
p.firetimer=100;
p.weapon_ammos=0;
p.weapon_ammo_type="5.56mm_ammo";
p.weapon_copasity=23;
send_reliable(p,parsed[2],0);
send_reliable(p, "rapid", 0);
}
}
else if(parsed[2]=="mb93machinegun")
{
if(parsed[2]!=p.weapon_name)
{
p.weapon_name=parsed[2];
if(p.weapon_ammos>0)
p.inv_add_item(p.weapon_ammo_type, p.weapon_ammos);
p.firetimer=100;
p.weapon_ammos=0;
p.weapon_ammo_type="5.56mm_ammo";
p.weapon_copasity=34;
send_reliable(p,parsed[2],0);
send_reliable(p, "rapid", 0);
}
}
else if(parsed[2]=="stp15rifle")
{
if(parsed[2]!=p.weapon_name)
{
p.weapon_name=parsed[2];
if(p.weapon_ammos>0)
p.inv_add_item(p.weapon_ammo_type, p.weapon_ammos);
p.firetimer=1080;
p.weapon_ammos=0;
p.weapon_ammo_type="12.7mm_ammo";
p.weapon_copasity=7;
send_reliable(p,parsed[2],0);
send_reliable(p, "notrapid", 0);
}
}
else if(parsed[2]=="sp3heavy_machinegun")
{
if(parsed[2]!=p.weapon_name)
{
p.weapon_name=parsed[2];
if(p.weapon_ammos>0)
p.inv_add_item(p.weapon_ammo_type, p.weapon_ammos);
p.firetimer=100;
p.weapon_ammos=0;
p.weapon_ammo_type="5.56mm_ammo";
p.weapon_copasity=65;
send_reliable(p,parsed[2],0);
send_reliable(p, "rapid", 0);
}
}
else if(parsed[2]=="ak9automatic_machinegun")
{
if(parsed[2]!=p.weapon_name)
{
p.weapon_name=parsed[2];
if(p.weapon_ammos>0)
p.inv_add_item(p.weapon_ammo_type, p.weapon_ammos);
p.firetimer=1034;
p.weapon_ammos=0;
p.weapon_ammo_type="5.56mm_ammo";
p.weapon_copasity=44;
send_reliable(p,parsed[2],0);
send_reliable(p, "rapid", 0);
}
}
else if(parsed[2]=="tsp_grenade_launcher")
{
if(parsed[2]!=p.weapon_name)
{
p.weapon_name=parsed[2];
if(p.weapon_ammos>0)
p.inv_add_item(p.weapon_ammo_type, p.weapon_ammos);
p.firetimer=780;
p.weapon_ammos=0;
p.weapon_ammo_type="grenade";
p.weapon_copasity=3;
send_reliable(p,parsed[2],0);
send_reliable(p, "notrapid", 0);
}
}
else if(parsed[2]=="m234minigun")
{
if(parsed[2]!=p.weapon_name)
{
p.weapon_name=parsed[2];
if(p.weapon_ammos>0)
p.inv_add_item(p.weapon_ammo_type, p.weapon_ammos);
p.firetimer=460;
p.weapon_ammos=0;
p.weapon_ammo_type="7.62mm_ammo";
p.weapon_copasity=200;
send_reliable(p,parsed[2],0);
send_reliable(p, "rapid", 0);
}
}
else if(parsed[2]=="missile_launcher")
{
if(parsed[2]!=p.weapon_name)
{
p.weapon_name=parsed[2];
if(p.weapon_ammos>0)
p.inv_add_item(p.weapon_ammo_type, p.weapon_ammos);
p.firetimer=3050;
p.weapon_ammos=0;
p.weapon_ammo_type="missile";
p.weapon_copasity=1;
send_reliable(p,parsed[2],0);
send_reliable(p, "notrapid", 0);
}
}
else if(parsed[2]=="m28mini_machinegun")
{
if(parsed[2]!=p.weapon_name)
{
p.weapon_name=parsed[2];
if(p.weapon_ammos>0)
p.inv_add_item(p.weapon_ammo_type, p.weapon_ammos);
p.firetimer=100;
p.weapon_ammos=0;
p.weapon_ammo_type="5.56mm_ammo";
p.weapon_copasity=28;
send_reliable(p,parsed[2],0);
send_reliable(p, "rapid", 0);
}
}
else if(parsed[2]=="b96machinegun")
{
if(parsed[2]!=p.weapon_name)
{
p.weapon_name=parsed[2];
if(p.weapon_ammos>0)
p.inv_add_item(p.weapon_ammo_type, p.weapon_ammos);
p.firetimer=100;
p.weapon_ammos=0;
p.weapon_ammo_type="5.56mm_ammo";
p.weapon_copasity=35;
send_reliable(p,parsed[2],0);
send_reliable(p, "rapid", 0);
}
}
else if(parsed[2]=="kalashnikov_rifle")
{
if(parsed[2]!=p.weapon_name)
{
p.weapon_name=parsed[2];
if(p.weapon_ammos>0)
p.inv_add_item(p.weapon_ammo_type, p.weapon_ammos);
p.firetimer=2650;
p.weapon_ammos=0;
p.weapon_ammo_type="12.7mm_ammo";
p.weapon_copasity=10;
send_reliable(p,parsed[2],0);
send_reliable(p, "notrapid", 0);
}
}
else if(parsed[2]=="ump45machinegun")
{
if(parsed[2]!=p.weapon_name)
{
p.weapon_name=parsed[2];
if(p.weapon_ammos>0)
p.inv_add_item(p.weapon_ammo_type, p.weapon_ammos);
p.firetimer=100;
p.weapon_ammos=0;
p.weapon_ammo_type="5.56mm_ammo";
p.weapon_copasity=25;
send_reliable(p,parsed[2],0);
send_reliable(p, "rapid", 0);
}
}
else if(parsed[2]=="tac50rifle")
{
if(parsed[2]!=p.weapon_name)
{
p.weapon_name=parsed[2];
if(p.weapon_ammos>0)
p.inv_add_item(p.weapon_ammo_type, p.weapon_ammos);
p.firetimer=2500;
p.weapon_ammos=0;
p.weapon_ammo_type="12.7mm_ammo";
p.weapon_copasity=5;
send_reliable(p,parsed[2],0);
send_reliable(p, "notrapid", 0);
}
}
else if(parsed[2]=="uzi_machinegun")
{
if(parsed[2]!=p.weapon_name)
{
p.weapon_name=parsed[2];
if(p.weapon_ammos>0)
p.inv_add_item(p.weapon_ammo_type, p.weapon_ammos);
p.firetimer=100;
p.weapon_ammos=0;
p.weapon_ammo_type="5.56mm_ammo";
p.weapon_copasity=20;
send_reliable(p,parsed[2],0);
send_reliable(p, "rapid", 0);
}
}
else if(parsed[2]=="d23machete")
{
if(parsed[2]!=p.weapon_name)
{
p.weapon_name=parsed[2];
if(p.weapon_ammos>0)
p.inv_add_item(p.weapon_ammo_type, p.weapon_ammos);
p.firetimer=175;
p.weapon_ammos=0;
p.weapon_ammo_type="";
p.weapon_copasity=0;
send_reliable(p,parsed[2],0);
send_reliable(p, "notrapid", 0);
}
}
else send_reliable(p, parsed[2], 2);
}
}
else if(parsed[0]=="drawi" )
{
send_packet(6,"play draw"+get_draw_and_get_sound(parsed[1])+".ogg "+p.x+" "+p.y+" "+p.z, p.x,p.y,p.z,maps[get_map_index(p.map)]);
}
else if(parsed[0]=="j1" and parsed.length()>1)
{
int id=get_player_index_from(parsed[1]);
if(id>-1)
{
if(players[id].is_trusted(p)==false and p.name!=players[id].name and p.is_admin()==false)
{
send_reliable(p,"error: "+players[id].name+" doesn't trust you",2);
return;
}
if(players[id].looking!="" and p.name!=players[id].name and p.is_admin()==false)
{
send_reliable(p,"error: "+players[id].name+" is looking at someone",2);
return;
}
string z=""+get_zone_at(players[id].x,players[id].y,players[id].z,maps[get_map_index(players[id].map)]);
if(z=="") z="unknown area";
send_reliable(p, ""+players[id].name+" is in "+z+"", 2);
}
else send_reliable(p, "msgnormal player not found", 0);
}
else if(parsed[0]=="j2" and parsed.length()>1)
{
int id=get_player_index_from(parsed[1]);
if(id>-1)
{
if(players[id].langchan=="disable_chat") send_reliable(p, "msg2 "+players[id].name+" has disabled chat", 0);
else if(players[id].langchan=="arabic" or players[id].langchan=="english" or players[id].langchan=="german" or players[id].langchan=="indonesian" or players[id].langchan=="malay" or players[id].langchan=="persian" or players[id].langchan=="polish" or players[id].langchan=="portuguese" or players[id].langchan=="russian" or players[id].langchan=="slovak" or players[id].langchan=="spanish" or players[id].langchan=="thai" or players[id].langchan=="turkish") send_reliable(p, "msg2 "+players[id].name+" is in "+players[id].langchan+" language channel", 0);
else send_reliable(p, "msg2 "+players[id].name+" is in "+players[id].langchan+"", 0);
}
}
else if(parsed[0]=="j3" and parsed.length()>1)
{
int id=get_player_index_from(parsed[1]);
if(id>-1)
{
send_reliable(p,""+players[id].name+" Has "+players[id].deaths+" deaths and "+players[id].kills+" kills",2);
}
else send_reliable(p, "msgnormal player not found", 0);
}
else if(parsed[0]=="dep_r")
{
double n=string_to_number(parsed[1]);
if(n<=0)send_reliable(p, "Invalid or blank bank account", 2);
else if(n>p.inv_item_number("coins"))send_reliable(p, "you haven't that much", 0);
//else if(p.paid==0 and n>1000000) send_reliable(p, "you can't deposit more than 1000000 coins in your bank account when you have a free account", 2);
else
{
p.inv_add_item("coins", -n);
send_reliable(p, "you deposited "+n+" ;coins.", 0);
p.balance+=n;
}
}
else if(parsed[0]=="dep2_r")
{
double n=string_to_number(parsed[1]);
if(p.balance<=0)send_reliable(p, "Invalid or blank bank account", 2);
else if(n<=0)send_reliable(p, "Invalid or blank bank account", 2);
else if(n>p.balance)send_reliable(p, "you haven't that much", 2);
else
{
send_reliable(p, "mtext What is the account to receive this transfer?:dep3_r", 0);
p.vconta=n;
}
}
else if(parsed[0]=="dep3_r")
{
dep3(p, parsed);
}
else if(parsed[0]=="sac_r")
{
double n=string_to_number(parsed[1]);
if(n<=0)send_reliable(p, "Invalid or blank bank account", 0);
else if(n>p.balance)send_reliable(p, "you haven't that much", 0);
//else if(n>p.balance/2 and p.paid==0) send_reliable(p, "you can't take this much when you have free account", 0);
//else if(p.paid==0 and n>1000000) send_reliable(p, "you can't withdraw more than 1000000 coins in your bank account when you have a free account", 2);
else
{
p.inv_add_item("coins", n);
send_reliable(p, "You took out ;"+n+" coins.", 0);
p.balance-=n;
}
}
else if(parsed[0]=="clothing")
{
clothing(p, true);
}
else if(parsed[0]=="smartphoneenter" and parsed.length()>1)
{
if(parsed[1]=="back")
{
p.sendpacket("canceled", 0);
return;
}
if(parsed[1]=="charge")
{
send_reliable(p,"this phone has "+p.smartphonecharge+"% charge",2);
}
else if(parsed[1]=="properties")
{
server_menu m;
m.intro="Select an option";
m.initial_packet="propertyset";
m.add("property info","propertyinfo");
m.add("change the house code","changehousecode");
m.send(e.peer_id);
}
else if(parsed[1]=="phone")
{
send_reliable(p,"phone",0);
}
else if(parsed[1]=="msg")
{
send_reliable(p,"msg",0);
}
else if(parsed[1]=="apps")
{
send_reliable(p,"apps",0);
}
else if(parsed[1]=="yourprofile")
{
server_menu menu;
menu.intro="Select an option";
menu.initial_packet="spyourprofile";
if(p.langchan=="") menu.add("select your language channel","langchan");
if(p.age==0) menu.add("select your age","age");
if(p.country=="") menu.add("select your country","country");
if(p.day==0||p.month==0||p.year==0) menu.add("set your birth date","birthday");
menu.send(e.peer_id);
}
}
else if(parsed[0]=="spyourprofile" and parsed.length()>1)
{
if(parsed[1]=="back")
{
p.sendpacket("canceled", 0);
if(p.smartphoneon==0)
{
send_reliable(p, "your phone is off", 0);
return;
}
server_menu m;
m.intro="one UI home";
m.initial_packet="smartphoneenter";
if(p.langchan=="" or p.age==0 or p.country=="" or p.day==0 or p.month==0 or p.year==0) m.add("complete your profile","yourprofile");
else
{
m.add("check battery level","charge");
m.add("phone","phone");
m.add("messages","msg");
m.add("apps","apps");
m.add("properties menu","properties");
}
m.send(p.peer_id);
}
else if(parsed[1]=="langchan")
{
server_menu menu;
menu.intro="Select a new language channel";
menu.initial_packet="lchannelset2";
for(uint i=0; i<language_channels.length(); i+=1)
{
menu.add(language_channels[i],language_channels[i]);
}
menu.add("password protected channels","ppc");
menu.send(e.peer_id);
}
else if(parsed[1]=="age")
{
server_menu menu;
menu.intro="how old are you?";
menu.initial_packet="ageset";
for(uint i=0; i<ages.length(); i+=1)
{
menu.add(ages[i],ages[i]);
}
menu.send(e.peer_id);
}
else if(parsed[1]=="country")
{
server_menu2 menu;
menu.intro="Where are you from?";
menu.initial_packet="countryset";
for(uint i=0; i<countrys.length(); i+=1)
{
menu.add(countrys[i],countrys[i]);
}
menu.send(e.peer_id);
}
else if(parsed[1]=="birthday")
{
server_menu menu;
menu.intro="set your birth date";
menu.initial_packet="birthdayset";
if(p.day==0) menu.add("day","day");
if(p.month==0) menu.add("month","month");
if(p.year==0) menu.add("year","year");
menu.send(e.peer_id);
}
}
else if(parsed[0]=="birthdayset" and parsed.length()>1)
{
if(parsed[1]=="back")
{
p.sendpacket("canceled", 0);
if(p.smartphoneon==0)
{
send_reliable(p, "your phone is off", 0);
return;
}
server_menu m;
m.intro="one UI home";
m.initial_packet="smartphoneenter";
if(p.langchan=="" or p.age==0 or p.country=="" or p.day==0 or p.month==0 or p.year==0) m.add("complete your profile","yourprofile");
else
{
m.add("check battery level","charge");
m.add("phone","phone");
m.add("messages","msg");
m.add("apps","apps");
m.add("properties menu","properties");
}
m.send(p.peer_id);
}
else if(parsed[1]=="day")
{
server_menu menu;
menu.intro="select your day of birth";
menu.initial_packet="dayset";
for(uint i=0; i<days.length(); i+=1)
{
menu.add(days[i],days[i]);
}
menu.send(e.peer_id);
}
else if(parsed[1]=="month")
{
server_menu menu;
menu.intro="select your month of birth";
menu.initial_packet="monthset";
for(uint i=0; i<months.length(); i+=1)
{
menu.add(monthnames[i],months[i]);
}
menu.send(e.peer_id);
}
else if(parsed[1]=="year")
{
server_menu menu;
menu.intro="select your year of birth";
menu.initial_packet="yearset";
for(uint i=0; i<years.length(); i+=1)
{
menu.add(years[i],years[i]);
}
menu.send(e.peer_id);
}
}
else if(parsed[0]=="lockcommand" and parsed.length()>1)
{
int l=get_locker_at(p.x,p.y,p.z,maps[get_map_index(p.map)]);
if(l>-1)
{
string cmd=string_replace(get_event_message(),"lockcommand ","",false);
lockers[l].command(cmd,p.peer_id);
}
}
else if(parsed[0]=="changelockcode" and parsed.length>1)
{
int l = get_locker_at(p.x, p.y, p.z,maps[get_map_index(p.map)]);
if(string_is_digits(parsed[1]))
{
lockers[l].code=string_to_number(parsed[1]);
send_reliable(p, "the code was changed successfully. New code is "+lockers[l].code, 2);
}
else
{
send_reliable(p, "error", 2);
}
}
else if(parsed[0]=="lock_auth" and parsed.length()>1)
{
int code=string_to_number(parsed[1]);
int l=get_locker_at(p.x, p.y, p.z,maps[get_map_index(p.map)]);
if(l==-1)
{
p.packet("Sorry, no locker here",0);
return;
}
else
{
if(lockers[l].code==code)
{
send_packet(6,"play locker_dooropen.ogg "+p.x+" "+p.y+" "+p.z, p.x,p.y,p.z,maps[get_map_index(p.map)]);
lockers[l].main_ui(p);
}
else
{
send_packet(6,"play locker_code_error.ogg "+p.x+" "+p.y+" "+p.z, p.x,p.y,p.z,maps[get_map_index(p.map)]);
}
}
}
else if(parsed[0]=="lockergive" and parsed.length()>1)
{
if(get_locker_at(p.x,p.y,p.z,maps[get_map_index(p.map)])<0)
{
send_reliable(p,"An internal error happened. Sorry",0);
return;
}
if(parsed[1]=="back")
{
send_reliable(p,"Canceled",0);
return;
}
if(parsed[1]=="invall")
{
int s=get_locker_at(p.x,p.y,p.z,maps[get_map_index(p.map)]);
string invstring=p.get_inv();
string[] invarray=delinear(invstring);
for(uint i=0; i<invarray.length(); i++)
{
string[] ite=string_split(invarray[i],"=",false);
if((ite[0]=="creamy_ice_cream" or ite[0]=="vanilla_ice_cream" or ite[0]=="caramel_ice_cream" or ite[0]=="smoothie" or ite[0]=="iced_tea" or ite[0]=="lemonade" or ite[0]=="lime_cordial" or ite[0]=="milkshake" or ite[0]=="orange_squash" or ite[0]=="squash" or ite[0]=="cocoa" or ite[0]=="coffee" or ite[0]=="black_coffee" or ite[0]=="decaffeinated_coffee" or ite[0]=="fruit_tea" or ite[0]=="green_tea" or ite[0]=="herbal_tea" or ite[0]=="hot_chocolate" or ite[0]=="tea" or ite[0]=="fruit_juice" or ite[0]=="grapefruit_juice" or ite[0]=="orange_juice" or ite[0]=="pineapple_juice" or ite[0]=="tomato_juice" or ite[0]=="cola" or ite[0]=="opened_cola" or ite[0]=="sos" or ite[0]=="ice" or ite[0]=="snow" or ite[0]=="cup_of_water" or ite[0]=="cup_of_cola" or ite[0]=="glass_of_water" or ite[0]=="cup_of_boiling_water" or ite[0]=="glass_of_boiling_water" or ite[0]=="cup_of_beer" or ite[0]=="glass_of_beer" or ite[0]=="glass_of_cola" or ite[0]=="water_bottle" or ite[0]=="beer_bottle" or string_contains(ite[0],"cooked_",1)>-1 or string_contains(ite[0],"gutted_",1)>-1 or string_contains(ite[0],"eatable_",1)>-1 or string_contains(ite[0],"skillit_with_",1)>-1 or ite[0]=="open_water_bottle" or ite[0]=="open_beer_bottle" or ite[0]=="pot_of_water" or ite[0]=="fish" or ite[0]=="hotdog" or ite[0]=="hamburger" or ite[0]=="cheeseburger" or ite[0]=="chicken_sandwich" or ite[0]=="piece_of_hotdog" or ite[0]=="piece_of_hamburger" or ite[0]=="piece_of_cheeseburger" or ite[0]=="piece_of_chicken_sandwich" or ite[0]=="hotdog_with_sos" or ite[0]=="hamburger_with_sos" or ite[0]=="cheeseburger_with_sos" or ite[0]=="chicken_sandwich_with_sos" or ite[0]=="piece_of_hotdog_with_sos" or ite[0]=="piece_of_hamburger_with_sos" or ite[0]=="piece_of_cheeseburger_with_sos" or ite[0]=="piece_of_chicken_sandwich_with_sos" or ite[0]=="piece_of_cake" or ite[0]=="cake" or ite[0]=="apple" or ite[0]=="watermelon" or ite[0]=="orange" or ite[0]=="pear" or ite[0]=="cherry" or ite[0]=="strawberry" or ite[0]=="berry" or ite[0]=="nectarine" or ite[0]=="grape" or ite[0]=="mango" or ite[0]=="blueberry" or ite[0]=="pomegranate" or ite[0]=="carambola" or ite[0]=="plum" or ite[0]=="banana" or ite[0]=="raspberry" or ite[0]=="mandarin" or ite[0]=="jackfruit" or ite[0]=="papaya" or ite[0]=="kiwi" or ite[0]=="pineapple" or ite[0]=="lime" or ite[0]=="lemon" or ite[0]=="apricot" or ite[0]=="grapefruit" or ite[0]=="melon" or ite[0]=="coconut" or ite[0]=="avocado" or ite[0]=="peach" or ite[0]=="green_almond" or ite[0]=="tamarind" or ite[0]=="cornelian_cherry" or ite[0]=="rhubarb" or ite[0]=="persimmon" or ite[0]=="fig" or ite[0]=="sour_cherry" or ite[0]=="sour_grapes" or ite[0]=="sitron" or ite[0]=="sour_orange" or ite[0]=="mushroom" or ite[0]=="broccoli" or ite[0]=="cucumber" or ite[0]=="red_pepper" or ite[0]=="tomato" or ite[0]=="swede" or ite[0]=="carrot" or ite[0]=="brussels_sprout" or ite[0]=="pumpkin" or ite[0]=="cabbage" or ite[0]=="potato" or ite[0]=="eggplant" or ite[0]=="sweet_potato" or ite[0]=="turnip" or ite[0]=="courgette" or ite[0]=="green_chilli" or ite[0]=="onion" or ite[0]=="lettuce" or ite[0]=="radish" or ite[0]=="pea" or ite[0]=="asparagus" or ite[0]=="selery" or ite[0]=="green_pepper" or ite[0]=="french_beans" or ite[0]=="spinach" or ite[0]=="beetroot" or ite[0]=="red_chillies" or ite[0]=="bean" or ite[0]=="cilantro" or ite[0]=="artichoke" or ite[0]=="rosemary" or ite[0]=="bay_leaves" or ite[0]=="mint_leaves" or ite[0]=="basil" or ite[0]=="clove" or ite[0]=="olive" or ite[0]=="shallot" or ite[0]=="turmeric" or ite[0]=="garlic" or ite[0]=="ginger" or ite[0]=="spring_onions" or ite[0]=="lemongrass" or ite[0]=="chives" or ite[0]=="nut" or string_contains(ite[0],"piece_of_bread",1)>-1) and string_contains(ite[0],"corrupted_",1)<0 and string_contains(ite[0],"heated_",1)<0) continue;
p.inv_add_item(ite[0],-string_to_number(ite[1]));
lockers[s].give(ite[0],string_to_number(ite[1]));
}

send_packet(6,"play base_storage_store.ogg "+p.x+" "+p.y+" "+p.z, p.x,p.y,p.z,maps[get_map_index(p.map)]);
return;
}
p.shitem=parsed[1];
send_serverbox(p.peer_id,2,-1,0,-1,"lockergivenow","How many "+p.shitem+" would you like to store");
}
else if(parsed[0]=="lockertake" and parsed.length()>1)
{
if(get_locker_at(p.x,p.y,p.z,maps[get_map_index(p.map)])<0)
{
send_reliable(p,"An internal error happened. Sorry",0);
return;
}
if(parsed[1]=="back")
{
send_reliable(p,"Canceled",0);
return;
}
if(parsed[1]=="invall")
{
int s=get_locker_at(p.x,p.y,p.z,maps[get_map_index(p.map)]);
string invstring=lockers[s].invdic_to_string();
if(invstring=="")
{
send_reliable(p,"nothing to take",0);
return;
}
string[] invarray=delinear(invstring);
for(uint i=0; i<invarray.length(); i++)
{
string[] ite=string_split(invarray[i],"=",false);
p.inv_add_item(ite[0],string_to_number(ite[1]));
lockers[s].give(ite[0],-string_to_number(ite[1]));
}
send_packet(6,"play base_storage_remove.ogg "+p.x+" "+p.y+" "+p.z, p.x,p.y,p.z,maps[get_map_index(p.map)]);
return;
}
p.shitem=parsed[1];
send_serverbox(p.peer_id,2,-1,0,-1,"lockertakenow","How many "+p.shitem+"s would you like to take from the locker");
}
else if(parsed[0]=="lockergivenow" and parsed.length()>1)
{
if(get_locker_at(p.x,p.y,p.z,maps[get_map_index(p.map)])<0)
{
send_reliable(p,"An internal error happened. Sorry",0);
return;
}
if(string_contains(parsed[1],"[cncel]",1)>-1)
{
send_reliable(p,"Canceled",0);
return;
}
int index2=get_locker_at(p.x,p.y,p.z,maps[get_map_index(p.map)]);
double amount=string_to_number(parsed[1]);
if(amount<=0)
{
send_reliable(p,"At least 1 item must be deposited!",0);
return;
}
double has=p.inv_item_number(p.shitem);
if(has<amount)
{
send_reliable(p,"Error: You do not have enough "+p.shitem+"s!",0);
return;
}
else
{
if((p.shitem=="creamy_ice_cream" or p.shitem=="vanilla_ice_cream" or p.shitem=="caramel_ice_cream" or p.shitem=="smoothie" or p.shitem=="iced_tea" or p.shitem=="lemonade" or p.shitem=="lime_cordial" or p.shitem=="milkshake" or p.shitem=="orange_squash" or p.shitem=="squash" or p.shitem=="cocoa" or p.shitem=="coffee" or p.shitem=="black_coffee" or p.shitem=="decaffeinated_coffee" or p.shitem=="fruit_tea" or p.shitem=="green_tea" or p.shitem=="herbal_tea" or p.shitem=="hot_chocolate" or p.shitem=="tea" or p.shitem=="fruit_juice" or p.shitem=="grapefruit_juice" or p.shitem=="orange_juice" or p.shitem=="pineapple_juice" or p.shitem=="tomato_juice" or p.shitem=="cola" or p.shitem=="opened_cola" or p.shitem=="sos" or p.shitem=="ice" or p.shitem=="snow" or p.shitem=="cup_of_water" or p.shitem=="cup_of_cola" or p.shitem=="glass_of_water" or p.shitem=="cup_of_boiling_water" or p.shitem=="glass_of_boiling_water" or p.shitem=="cup_of_beer" or p.shitem=="glass_of_beer" or p.shitem=="glass_of_cola" or p.shitem=="water_bottle" or p.shitem=="beer_bottle" or string_contains(p.shitem,"cooked_",1)>-1 or string_contains(p.shitem,"gutted_",1)>-1 or string_contains(p.shitem,"eatable_",1)>-1 or string_contains(p.shitem,"skillit_with_",1)>-1 or p.shitem=="open_water_bottle" or p.shitem=="open_beer_bottle" or p.shitem=="pot_of_water" or p.shitem=="fish" or p.shitem=="hotdog" or p.shitem=="hamburger" or p.shitem=="cheeseburger" or p.shitem=="chicken_sandwich" or p.shitem=="piece_of_hotdog" or p.shitem=="piece_of_hamburger" or p.shitem=="piece_of_cheeseburger" or p.shitem=="piece_of_chicken_sandwich" or p.shitem=="hotdog_with_sos" or p.shitem=="hamburger_with_sos" or p.shitem=="cheeseburger_with_sos" or p.shitem=="chicken_sandwich_with_sos" or p.shitem=="piece_of_hotdog_with_sos" or p.shitem=="piece_of_hamburger_with_sos" or p.shitem=="piece_of_cheeseburger_with_sos" or p.shitem=="piece_of_chicken_sandwich_with_sos" or p.shitem=="piece_of_cake" or p.shitem=="cake" or p.shitem=="apple" or p.shitem=="watermelon" or p.shitem=="orange" or p.shitem=="pear" or p.shitem=="cherry" or p.shitem=="strawberry" or p.shitem=="berry" or p.shitem=="nectarine" or p.shitem=="grape" or p.shitem=="mango" or p.shitem=="blueberry" or p.shitem=="pomegranate" or p.shitem=="carambola" or p.shitem=="plum" or p.shitem=="banana" or p.shitem=="raspberry" or p.shitem=="mandarin" or p.shitem=="jackfruit" or p.shitem=="papaya" or p.shitem=="kiwi" or p.shitem=="pineapple" or p.shitem=="lime" or p.shitem=="lemon" or p.shitem=="apricot" or p.shitem=="grapefruit" or p.shitem=="melon" or p.shitem=="coconut" or p.shitem=="avocado" or p.shitem=="peach" or p.shitem=="green_almond" or p.shitem=="tamarind" or p.shitem=="cornelian_cherry" or p.shitem=="rhubarb" or p.shitem=="persimmon" or p.shitem=="fig" or p.shitem=="sour_cherry" or p.shitem=="sour_grapes" or p.shitem=="sitron" or p.shitem=="sour_orange" or p.shitem=="mushroom" or p.shitem=="broccoli" or p.shitem=="cucumber" or p.shitem=="red_pepper" or p.shitem=="tomato" or p.shitem=="swede" or p.shitem=="carrot" or p.shitem=="brussels_sprout" or p.shitem=="pumpkin" or p.shitem=="cabbage" or p.shitem=="potato" or p.shitem=="eggplant" or p.shitem=="sweet_potato" or p.shitem=="turnip" or p.shitem=="courgette" or p.shitem=="green_chilli" or p.shitem=="onion" or p.shitem=="lettuce" or p.shitem=="radish" or p.shitem=="pea" or p.shitem=="asparagus" or p.shitem=="selery" or p.shitem=="green_pepper" or p.shitem=="french_beans" or p.shitem=="spinach" or p.shitem=="beetroot" or p.shitem=="red_chillies" or p.shitem=="bean" or p.shitem=="cilantro" or p.shitem=="artichoke" or p.shitem=="rosemary" or p.shitem=="bay_leaves" or p.shitem=="mint_leaves" or p.shitem=="basil" or p.shitem=="clove" or p.shitem=="olive" or p.shitem=="shallot" or p.shitem=="turmeric" or p.shitem=="garlic" or p.shitem=="ginger" or p.shitem=="spring_onions" or p.shitem=="lemongrass" or p.shitem=="chives" or p.shitem=="nut" or string_contains(p.shitem,"piece_of_bread",1)>-1) and string_contains(p.shitem,"corrupted_",1)<0 and string_contains(p.shitem,"heated_",1)<0) return;
p.inv_add_item(p.shitem,-amount);
lockers[index2].give(p.shitem,amount);
send_packet(6,"play base_storage_store.ogg "+p.x+" "+p.y+" "+p.z, p.x,p.y,p.z,maps[get_map_index(p.map)]);
send_reliable(p,"You put "+amount+" "+p.shitem+"s inside the locker",0);
}
}
else if(parsed[0]=="lockertakenow" and parsed.length()>1)
{
if(get_locker_at(p.x,p.y,p.z,maps[get_map_index(p.map)])<0)
{
send_reliable(p,"An internal error happened. Sorry",0);
return;
}
if(string_contains(parsed[1],"[cncel]",1)>-1)
{
send_reliable(p,"Canceled",0);
return;
}
int index2=get_locker_at(p.x,p.y,p.z,maps[get_map_index(p.map)]);
double amount=string_to_number(parsed[1]);
if(amount<=0)
{
send_reliable(p,"At least 1 item must be taken out!",0);
return;
}
double has=lockers[index2].get_item_count(p.shitem);
if(has<amount)
{
send_reliable(p,"Error: This locker does not have enough "+p.shitem+"s!",0);
return;
}
else
{
p.inv_add_item(p.shitem,amount);
lockers[index2].give(p.shitem,-amount);
send_packet(6,"play base_storage_remove.ogg "+p.x+" "+p.y+" "+p.z, p.x,p.y,p.z,maps[get_map_index(p.map)]);
send_reliable(p,"You take "+amount+" "+p.shitem+"s out of the locker's ",0);
}
}
else if(parsed[0]=="fridgecommand" and parsed.length()>1)
{
int l=get_fridge_at(p.x,p.y,p.z,maps[get_map_index(p.map)]);
if(l>-1)
{
string cmd=string_replace(get_event_message(),"fridgecommand ","",false);
fridges[l].command(cmd,p.peer_id);
}
}
else if(parsed[0]=="fridgegive" and parsed.length()>1)
{
if(get_fridge_at(p.x,p.y,p.z,maps[get_map_index(p.map)])<0)
{
send_reliable(p,"An internal error happened. Sorry",0);
return;
}
if(parsed[1]=="back")
{
send_reliable(p,"Canceled",0);
return;
}
if(parsed[1]=="invall")
{
int s=get_fridge_at(p.x,p.y,p.z,maps[get_map_index(p.map)]);
string invstring=p.get_inv();
string[] invarray=delinear(invstring);
for(uint i=0; i<invarray.length(); i++)
{
string[] ite=string_split(invarray[i],"=",false);
if((ite[0]=="creamy_ice_cream" or ite[0]=="vanilla_ice_cream" or ite[0]=="caramel_ice_cream" or ite[0]=="smoothie" or ite[0]=="iced_tea" or ite[0]=="lemonade" or ite[0]=="lime_cordial" or ite[0]=="milkshake" or ite[0]=="orange_squash" or ite[0]=="squash" or ite[0]=="cocoa" or ite[0]=="coffee" or ite[0]=="black_coffee" or ite[0]=="decaffeinated_coffee" or ite[0]=="fruit_tea" or ite[0]=="green_tea" or ite[0]=="herbal_tea" or ite[0]=="hot_chocolate" or ite[0]=="tea" or ite[0]=="fruit_juice" or ite[0]=="grapefruit_juice" or ite[0]=="orange_juice" or ite[0]=="pineapple_juice" or ite[0]=="tomato_juice" or ite[0]=="cola" or ite[0]=="opened_cola" or ite[0]=="sos" or ite[0]=="ice" or ite[0]=="snow" or ite[0]=="cup_of_water" or ite[0]=="cup_of_cola" or ite[0]=="glass_of_water" or ite[0]=="cup_of_boiling_water" or ite[0]=="glass_of_boiling_water" or ite[0]=="cup_of_beer" or ite[0]=="glass_of_beer" or ite[0]=="glass_of_cola" or ite[0]=="water_bottle" or ite[0]=="beer_bottle" or string_contains(ite[0],"cooked_",1)>-1 or string_contains(ite[0],"gutted_",1)>-1 or string_contains(ite[0],"eatable_",1)>-1 or string_contains(ite[0],"skillit_with_",1)>-1 or ite[0]=="open_water_bottle" or ite[0]=="open_beer_bottle" or ite[0]=="pot_of_water" or ite[0]=="fish" or ite[0]=="hotdog" or ite[0]=="hamburger" or ite[0]=="cheeseburger" or ite[0]=="chicken_sandwich" or ite[0]=="piece_of_hotdog" or ite[0]=="piece_of_hamburger" or ite[0]=="piece_of_cheeseburger" or ite[0]=="piece_of_chicken_sandwich" or ite[0]=="hotdog_with_sos" or ite[0]=="hamburger_with_sos" or ite[0]=="cheeseburger_with_sos" or ite[0]=="chicken_sandwich_with_sos" or ite[0]=="piece_of_hotdog_with_sos" or ite[0]=="piece_of_hamburger_with_sos" or ite[0]=="piece_of_cheeseburger_with_sos" or ite[0]=="piece_of_chicken_sandwich_with_sos" or ite[0]=="piece_of_cake" or ite[0]=="cake" or ite[0]=="apple" or ite[0]=="watermelon" or ite[0]=="orange" or ite[0]=="pear" or ite[0]=="cherry" or ite[0]=="strawberry" or ite[0]=="berry" or ite[0]=="nectarine" or ite[0]=="grape" or ite[0]=="mango" or ite[0]=="blueberry" or ite[0]=="pomegranate" or ite[0]=="carambola" or ite[0]=="plum" or ite[0]=="banana" or ite[0]=="raspberry" or ite[0]=="mandarin" or ite[0]=="jackfruit" or ite[0]=="papaya" or ite[0]=="kiwi" or ite[0]=="pineapple" or ite[0]=="lime" or ite[0]=="lemon" or ite[0]=="apricot" or ite[0]=="grapefruit" or ite[0]=="melon" or ite[0]=="coconut" or ite[0]=="avocado" or ite[0]=="peach" or ite[0]=="green_almond" or ite[0]=="tamarind" or ite[0]=="cornelian_cherry" or ite[0]=="rhubarb" or ite[0]=="persimmon" or ite[0]=="fig" or ite[0]=="sour_cherry" or ite[0]=="sour_grapes" or ite[0]=="sitron" or ite[0]=="sour_orange" or ite[0]=="mushroom" or ite[0]=="broccoli" or ite[0]=="cucumber" or ite[0]=="red_pepper" or ite[0]=="tomato" or ite[0]=="swede" or ite[0]=="carrot" or ite[0]=="brussels_sprout" or ite[0]=="pumpkin" or ite[0]=="cabbage" or ite[0]=="potato" or ite[0]=="eggplant" or ite[0]=="sweet_potato" or ite[0]=="turnip" or ite[0]=="courgette" or ite[0]=="green_chilli" or ite[0]=="onion" or ite[0]=="lettuce" or ite[0]=="radish" or ite[0]=="pea" or ite[0]=="asparagus" or ite[0]=="selery" or ite[0]=="green_pepper" or ite[0]=="french_beans" or ite[0]=="spinach" or ite[0]=="beetroot" or ite[0]=="red_chillies" or ite[0]=="bean" or ite[0]=="cilantro" or ite[0]=="artichoke" or ite[0]=="rosemary" or ite[0]=="bay_leaves" or ite[0]=="mint_leaves" or ite[0]=="basil" or ite[0]=="clove" or ite[0]=="olive" or ite[0]=="shallot" or ite[0]=="turmeric" or ite[0]=="garlic" or ite[0]=="ginger" or ite[0]=="spring_onions" or ite[0]=="lemongrass" or ite[0]=="chives" or ite[0]=="nut" or string_contains(ite[0],"piece_of_bread",1)>-1) and string_contains(ite[0],"corrupted_",1)<0 and string_contains(ite[0],"heated_",1)<0)
{
p.inv_add_item(ite[0],-string_to_number(ite[1]));
fridges[s].give(ite[0],string_to_number(ite[1]));
}
}
send_packet(6,"play base_fridge_store.ogg "+p.x+" "+p.y+" "+p.z, p.x,p.y,p.z,maps[get_map_index(p.map)]);
return;
}
p.shitem=parsed[1];
send_serverbox(p.peer_id,2,-1,0,-1,"fridgegivenow","How many "+p.shitem+"s would you like to store");
}
else if(parsed[0]=="fridgetake" and parsed.length()>1)
{
if(get_fridge_at(p.x,p.y,p.z,maps[get_map_index(p.map)])<0)
{
send_reliable(p,"An internal error happened. Sorry",0);
return;
}
if(parsed[1]=="back")
{
send_reliable(p,"Canceled",0);
return;
}
if(parsed[1]=="invall")
{
int s=get_fridge_at(p.x,p.y,p.z,maps[get_map_index(p.map)]);
string invstring=fridges[s].invdic_to_string();
if(invstring=="")
{
send_reliable(p,"nothing to take",0);
return;
}
string[] invarray=delinear(invstring);
for(uint i=0; i<invarray.length(); i++)
{
string[] ite=string_split(invarray[i],"=",false);
p.inv_add_item(ite[0],string_to_number(ite[1]));
fridges[s].give(ite[0],-string_to_number(ite[1]));
}
send_packet(6,"play base_fridge_remove.ogg "+p.x+" "+p.y+" "+p.z, p.x,p.y,p.z,maps[get_map_index(p.map)]);
return;
}
p.shitem=parsed[1];
send_serverbox(p.peer_id,2,-1,0,-1,"fridgetakenow","How many "+p.shitem+"s would you like to take from the fridge");
}
else if(parsed[0]=="fridgegivenow" and parsed.length()>1)
{
if(get_fridge_at(p.x,p.y,p.z,maps[get_map_index(p.map)])<0)
{
send_reliable(p,"An internal error happened. Sorry",0);
return;
}
if(string_contains(parsed[1],"[cncel]",1)>-1)
{
send_reliable(p,"Canceled",0);
return;
}
int index2=get_fridge_at(p.x,p.y,p.z,maps[get_map_index(p.map)]);
double amount=string_to_number(parsed[1]);
if(amount<=0)
{
send_reliable(p,"At least 1 item must be deposited!",0);
return;
}
double has=p.inv_item_number(p.shitem);
if(has<amount)
{
send_reliable(p,"Error: You do not have enough "+p.shitem+"s!",0);
return;
}
else
{
if((p.shitem=="creamy_ice_cream" or p.shitem=="vanilla_ice_cream" or p.shitem=="caramel_ice_cream" or p.shitem=="smoothie" or p.shitem=="iced_tea" or p.shitem=="lemonade" or p.shitem=="lime_cordial" or p.shitem=="milkshake" or p.shitem=="orange_squash" or p.shitem=="squash" or p.shitem=="cocoa" or p.shitem=="coffee" or p.shitem=="black_coffee" or p.shitem=="decaffeinated_coffee" or p.shitem=="fruit_tea" or p.shitem=="green_tea" or p.shitem=="herbal_tea" or p.shitem=="hot_chocolate" or p.shitem=="tea" or p.shitem=="fruit_juice" or p.shitem=="grapefruit_juice" or p.shitem=="orange_juice" or p.shitem=="pineapple_juice" or p.shitem=="tomato_juice" or p.shitem=="cola" or p.shitem=="opened_cola" or p.shitem=="sos" or p.shitem=="ice" or p.shitem=="snow" or p.shitem=="cup_of_water" or p.shitem=="cup_of_cola" or p.shitem=="glass_of_water" or p.shitem=="cup_of_boiling_water" or p.shitem=="glass_of_boiling_water" or p.shitem=="cup_of_beer" or p.shitem=="glass_of_beer" or p.shitem=="glass_of_cola" or p.shitem=="water_bottle" or p.shitem=="beer_bottle" or string_contains(p.shitem,"cooked_",1)>-1 or string_contains(p.shitem,"gutted_",1)>-1 or string_contains(p.shitem,"eatable_",1)>-1 or string_contains(p.shitem,"skillit_with_",1)>-1 or p.shitem=="open_water_bottle" or p.shitem=="open_beer_bottle" or p.shitem=="pot_of_water" or p.shitem=="fish" or p.shitem=="hotdog" or p.shitem=="hamburger" or p.shitem=="cheeseburger" or p.shitem=="chicken_sandwich" or p.shitem=="piece_of_hotdog" or p.shitem=="piece_of_hamburger" or p.shitem=="piece_of_cheeseburger" or p.shitem=="piece_of_chicken_sandwich" or p.shitem=="hotdog_with_sos" or p.shitem=="hamburger_with_sos" or p.shitem=="cheeseburger_with_sos" or p.shitem=="chicken_sandwich_with_sos" or p.shitem=="piece_of_hotdog_with_sos" or p.shitem=="piece_of_hamburger_with_sos" or p.shitem=="piece_of_cheeseburger_with_sos" or p.shitem=="piece_of_chicken_sandwich_with_sos" or p.shitem=="piece_of_cake" or p.shitem=="cake" or p.shitem=="apple" or p.shitem=="watermelon" or p.shitem=="orange" or p.shitem=="pear" or p.shitem=="cherry" or p.shitem=="strawberry" or p.shitem=="berry" or p.shitem=="nectarine" or p.shitem=="grape" or p.shitem=="mango" or p.shitem=="blueberry" or p.shitem=="pomegranate" or p.shitem=="carambola" or p.shitem=="plum" or p.shitem=="banana" or p.shitem=="raspberry" or p.shitem=="mandarin" or p.shitem=="jackfruit" or p.shitem=="papaya" or p.shitem=="kiwi" or p.shitem=="pineapple" or p.shitem=="lime" or p.shitem=="lemon" or p.shitem=="apricot" or p.shitem=="grapefruit" or p.shitem=="melon" or p.shitem=="coconut" or p.shitem=="avocado" or p.shitem=="peach" or p.shitem=="green_almond" or p.shitem=="tamarind" or p.shitem=="cornelian_cherry" or p.shitem=="rhubarb" or p.shitem=="persimmon" or p.shitem=="fig" or p.shitem=="sour_cherry" or p.shitem=="sour_grapes" or p.shitem=="sitron" or p.shitem=="sour_orange" or p.shitem=="mushroom" or p.shitem=="broccoli" or p.shitem=="cucumber" or p.shitem=="red_pepper" or p.shitem=="tomato" or p.shitem=="swede" or p.shitem=="carrot" or p.shitem=="brussels_sprout" or p.shitem=="pumpkin" or p.shitem=="cabbage" or p.shitem=="potato" or p.shitem=="eggplant" or p.shitem=="sweet_potato" or p.shitem=="turnip" or p.shitem=="courgette" or p.shitem=="green_chilli" or p.shitem=="onion" or p.shitem=="lettuce" or p.shitem=="radish" or p.shitem=="pea" or p.shitem=="asparagus" or p.shitem=="selery" or p.shitem=="green_pepper" or p.shitem=="french_beans" or p.shitem=="spinach" or p.shitem=="beetroot" or p.shitem=="red_chillies" or p.shitem=="bean" or p.shitem=="cilantro" or p.shitem=="artichoke" or p.shitem=="rosemary" or p.shitem=="bay_leaves" or p.shitem=="mint_leaves" or p.shitem=="basil" or p.shitem=="clove" or p.shitem=="olive" or p.shitem=="shallot" or p.shitem=="turmeric" or p.shitem=="garlic" or p.shitem=="ginger" or p.shitem=="spring_onions" or p.shitem=="lemongrass" or p.shitem=="chives" or p.shitem=="nut" or string_contains(p.shitem,"piece_of_bread",1)>-1) and string_contains(p.shitem,"corrupted_",1)<0 and string_contains(p.shitem,"heated_",1)<0)
{
p.inv_add_item(p.shitem,-amount);
fridges[index2].give(p.shitem,amount);
}
send_packet(6,"play base_fridge_store.ogg "+p.x+" "+p.y+" "+p.z, p.x,p.y,p.z,maps[get_map_index(p.map)]);
send_reliable(p,"You put "+amount+" "+p.shitem+"s inside the fridge",0);
}
}
else if(parsed[0]=="fridgetakenow" and parsed.length()>1)
{
if(get_fridge_at(p.x,p.y,p.z,maps[get_map_index(p.map)])<0)
{
send_reliable(p,"An internal error happened. Sorry",0);
return;
}
if(string_contains(parsed[1],"[cncel]",1)>-1)
{
send_reliable(p,"Canceled",0);
return;
}
int index2=get_fridge_at(p.x,p.y,p.z,maps[get_map_index(p.map)]);
double amount=string_to_number(parsed[1]);
if(amount<=0)
{
send_reliable(p,"At least 1 item must be taken out!",0);
return;
}
double has=fridges[index2].get_item_count(p.shitem);
if(has<amount)
{
send_reliable(p,"Error: This fridge does not have enough "+p.shitem+"s!",0);
return;
}
else
{
p.inv_add_item(p.shitem,amount);
fridges[index2].give(p.shitem,-amount);
send_packet(6,"play base_fridge_remove.ogg "+p.x+" "+p.y+" "+p.z, p.x,p.y,p.z,maps[get_map_index(p.map)]);
send_reliable(p,"You take "+amount+" "+p.shitem+"s out of the fridge's ",0);
}
}
else if(parsed[0]=="propertyset" and parsed.length()>1)
{
if(parsed[1]=="back")
{
p.sendpacket("canceled", 0);
return;
}
else if(parsed[1]=="propertyinfo")
{
server_menu m;
m.intro="properties menu";
m.initial_packet="propertieslist";
m.add("your air conditioners","air_conditioners");
m.add("your beehives","beehives");
m.add("your cars","vehicles");
m.add("your fans","fans");
m.add("your fridges","fridges");
m.add("your house","house");
m.add("your lockers","lockers");
m.add("your microwaves","microwaves");
m.add("your motorcycles","motors");
m.add("your steams","steams");
m.add("your stores","stores");
m.send(p.peer_id);
}
else if(parsed[1]=="changehousecode")
{
for(uint i=0; i<houses.length(); i++)
{
if(houses[i].owner==p.name)
{
send_serverbox(p.peer_id,2,-1,-1,-1,"housepasschange","Enter a new code for your house");
}
}
}
}
else if(parsed[0]=="propertieslist" and parsed.length()>1)
{
if(parsed[1]=="back")
{
p.sendpacket("canceled", 0);
return;
}
else if(parsed[1]=="beehives")
{
string bs="";
for(uint i=0; i<beehives.length(); i++)
{
if(beehives[i].owner==p.name)
{
bs+="In coordinates "+beehives[i].x+", "+beehives[i].y+", "+beehives[i].z+", in "+get_zone_at(beehives[i].x,beehives[i].y,beehives[i].z,maps[get_map_index(beehives[i].map)])+", with "+beehives[i].health+" health. ";
}
}
send_reliable(p,""+(bs==""?"nothing found":"beehives: "+bs+"")+"",2);
server_menu m;
m.intro="properties menu";
m.initial_packet="propertieslist";
m.add("your air conditioners","air_conditioners");
m.add("your beehives","beehives");
m.add("your cars","vehicles");
m.add("your fans","fans");
m.add("your fridges","fridges");
m.add("your house","house");
m.add("your lockers","lockers");
m.add("your microwaves","microwaves");
m.add("your motorcycles","motors");
m.add("your steams","steams");
m.add("your stores","stores");
m.send(p.peer_id);
}
else if(parsed[1]=="fridges")
{
string fs="";
for(uint i=0; i<fridges.length(); i++)
{
if(fridges[i].owner==p.name)
{
fs+="In coordinates "+fridges[i].x+", "+fridges[i].y+", "+fridges[i].z+", in "+get_zone_at(fridges[i].x,fridges[i].y,fridges[i].z,maps[get_map_index(fridges[i].map)])+", with "+fridges[i].health+" health. ";
}
}
send_reliable(p,""+(fs==""?"nothing found":"fridges: "+fs+"")+"",2);
server_menu m;
m.intro="properties menu";
m.initial_packet="propertieslist";
m.add("your air conditioners","air_conditioners");
m.add("your beehives","beehives");
m.add("your cars","vehicles");
m.add("your fans","fans");
m.add("your fridges","fridges");
m.add("your house","house");
m.add("your lockers","lockers");
m.add("your microwaves","microwaves");
m.add("your motorcycles","motors");
m.add("your steams","steams");
m.add("your stores","stores");
m.send(p.peer_id);
}
else if(parsed[1]=="house")
{
string hs="";
for(uint i=0; i<houses.length(); i++)
{
if(houses[i].owner==p.name)
{
hs+=""+houses[i].itemdeleted+" In coordinates "+houses[i].x+", "+houses[i].y+", "+houses[i].z+", in "+get_zone_at(houses[i].x,houses[i].y,houses[i].z,maps[get_map_index(houses[i].map)])+", with "+houses[i].health+" health, code: "+houses[i].code+". ";
}
}
send_reliable(p,""+(hs==""?"nothing found":""+hs+"")+"",2);
server_menu m;
m.intro="properties menu";
m.initial_packet="propertieslist";
m.add("your air conditioners","air_conditioners");
m.add("your beehives","beehives");
m.add("your cars","vehicles");
m.add("your fans","fans");
m.add("your fridges","fridges");
m.add("your house","house");
m.add("your lockers","lockers");
m.add("your microwaves","microwaves");
m.add("your motorcycles","motors");
m.add("your steams","steams");
m.add("your stores","stores");
m.send(p.peer_id);
}
else if(parsed[1]=="lockers")
{
string ls="";
for(uint i=0; i<lockers.length(); i++)
{
if(lockers[i].owner==p.name)
{
ls+="In coordinates "+lockers[i].x+", "+lockers[i].y+", "+lockers[i].z+", in "+get_zone_at(lockers[i].x,lockers[i].y,lockers[i].z,maps[get_map_index(lockers[i].map)])+", with "+lockers[i].health+" health, code: "+lockers[i].code+". ";
}
}
send_reliable(p,""+(ls==""?"nothing found":"lockers: "+ls+"")+"",2);
server_menu m;
m.intro="properties menu";
m.initial_packet="propertieslist";
m.add("your air conditioners","air_conditioners");
m.add("your beehives","beehives");
m.add("your cars","vehicles");
m.add("your fans","fans");
m.add("your fridges","fridges");
m.add("your house","house");
m.add("your lockers","lockers");
m.add("your microwaves","microwaves");
m.add("your motorcycles","motors");
m.add("your steams","steams");
m.add("your stores","stores");
m.send(p.peer_id);
}
else if(parsed[1]=="microwaves")
{
string ms="";
for(uint i=0; i<microwaves.length(); i++)
{
if(microwaves[i].owner==p.name)
{
ms+="In coordinates "+microwaves[i].x+", "+microwaves[i].y+", "+microwaves[i].z+", in "+get_zone_at(microwaves[i].x,microwaves[i].y,microwaves[i].z,maps[get_map_index(microwaves[i].map)])+", with "+microwaves[i].health+" health. ";
}
}
send_reliable(p,""+(ms==""?"nothing found":"microwaves: "+ms+"")+"",2);
server_menu m;
m.intro="properties menu";
m.initial_packet="propertieslist";
m.add("your air conditioners","air_conditioners");
m.add("your beehives","beehives");
m.add("your cars","vehicles");
m.add("your fans","fans");
m.add("your fridges","fridges");
m.add("your house","house");
m.add("your lockers","lockers");
m.add("your microwaves","microwaves");
m.add("your motorcycles","motors");
m.add("your steams","steams");
m.add("your stores","stores");
m.send(p.peer_id);
}
else if(parsed[1]=="air_conditioners")
{
string ms="";
for(uint i=0; i<air_conditioners.length(); i++)
{
if(air_conditioners[i].owner==p.name)
{
ms+="In coordinates "+air_conditioners[i].x+", "+air_conditioners[i].y+", "+air_conditioners[i].z+", in "+get_zone_at(air_conditioners[i].x,air_conditioners[i].y,air_conditioners[i].z,maps[get_map_index(air_conditioners[i].map)])+", with "+air_conditioners[i].health+" health. ";
}
}
send_reliable(p,""+(ms==""?"nothing found":"air_conditioners: "+ms+"")+"",2);
server_menu m;
m.intro="properties menu";
m.initial_packet="propertieslist";
m.add("your air conditioners","air_conditioners");
m.add("your beehives","beehives");
m.add("your cars","vehicles");
m.add("your fans","fans");
m.add("your fridges","fridges");
m.add("your house","house");
m.add("your lockers","lockers");
m.add("your microwaves","microwaves");
m.add("your motorcycles","motors");
m.add("your steams","steams");
m.add("your stores","stores");
m.send(p.peer_id);
}
else if(parsed[1]=="steams")
{
string ms="";
for(uint i=0; i<steams.length(); i++)
{
if(steams[i].owner==p.name)
{
ms+="In coordinates "+steams[i].x+", "+steams[i].y+", "+steams[i].z+", in "+get_zone_at(steams[i].x,steams[i].y,steams[i].z,maps[get_map_index(steams[i].map)])+", with "+steams[i].health+" health. ";
}
}
send_reliable(p,""+(ms==""?"nothing found":"steams: "+ms+"")+"",2);
server_menu m;
m.intro="properties menu";
m.initial_packet="propertieslist";
m.add("your air conditioners","air_conditioners");
m.add("your beehives","beehives");
m.add("your cars","vehicles");
m.add("your fans","fans");
m.add("your fridges","fridges");
m.add("your house","house");
m.add("your lockers","lockers");
m.add("your microwaves","microwaves");
m.add("your motorcycles","motors");
m.add("your steams","steams");
m.add("your stores","stores");
m.send(p.peer_id);
}
else if(parsed[1]=="fans")
{
string ms="";
for(uint i=0; i<fans.length(); i++)
{
if(fans[i].owner==p.name)
{
ms+="In coordinates "+fans[i].x+", "+fans[i].y+", "+fans[i].z+", in "+get_zone_at(fans[i].x,fans[i].y,fans[i].z,maps[get_map_index(fans[i].map)])+", with "+fans[i].health+" health. ";
}
}
send_reliable(p,""+(ms==""?"nothing found":"fans: "+ms+"")+"",2);
server_menu m;
m.intro="properties menu";
m.initial_packet="propertieslist";
m.add("your air conditioners","air_conditioners");
m.add("your beehives","beehives");
m.add("your cars","vehicles");
m.add("your fans","fans");
m.add("your fridges","fridges");
m.add("your house","house");
m.add("your lockers","lockers");
m.add("your microwaves","microwaves");
m.add("your motorcycles","motors");
m.add("your steams","steams");
m.add("your stores","stores");
m.send(p.peer_id);
}
else if(parsed[1]=="motors")
{
string mms="";
for(uint i=0; i<mmotors.length(); i++)
{
if(mmotors[i].owner==p.name)
{
mms+="In coordinates "+mmotors[i].x+", "+mmotors[i].y+", "+mmotors[i].z+", in "+get_zone_at(mmotors[i].x,mmotors[i].y,mmotors[i].z,maps[get_map_index(mmotors[i].map)])+", with "+mmotors[i].health+" health. ";
}
}
send_reliable(p,""+(mms==""?"nothing found":"motors: "+mms+"")+"",2);
server_menu m;
m.intro="properties menu";
m.initial_packet="propertieslist";
m.add("your air conditioners","air_conditioners");
m.add("your beehives","beehives");
m.add("your cars","vehicles");
m.add("your fans","fans");
m.add("your fridges","fridges");
m.add("your house","house");
m.add("your lockers","lockers");
m.add("your microwaves","microwaves");
m.add("your motorcycles","motors");
m.add("your steams","steams");
m.add("your stores","stores");
m.send(p.peer_id);
}
else if(parsed[1]=="stores")
{
string ss="";
for(uint i=0; i<playerstores.length(); i++)
{
if(playerstores[i].owner==p.name)
{
ss+="In coordinates "+playerstores[i].x+", "+playerstores[i].y+", "+playerstores[i].z+", in "+get_zone_at(playerstores[i].x,playerstores[i].y,playerstores[i].z,maps[get_map_index(playerstores[i].map)])+", with "+playerstores[i].health+" health. ";
}
}
send_reliable(p,""+(ss==""?"nothing found":"stores: "+ss+"")+"",2);
server_menu m;
m.intro="properties menu";
m.initial_packet="propertieslist";
m.add("your air conditioners","air_conditioners");
m.add("your beehives","beehives");
m.add("your cars","vehicles");
m.add("your fans","fans");
m.add("your fridges","fridges");
m.add("your house","house");
m.add("your lockers","lockers");
m.add("your microwaves","microwaves");
m.add("your motorcycles","motors");
m.add("your steams","steams");
m.add("your stores","stores");
m.send(p.peer_id);
}
else if(parsed[1]=="vehicles")
{
string vvs="";
for(uint i=0; i<vvehicles.length(); i++)
{
if(vvehicles[i].owner==p.name)
{
vvs+="In coordinates "+vvehicles[i].x+", "+vvehicles[i].y+", "+vvehicles[i].z+", in "+get_zone_at(vvehicles[i].x,vvehicles[i].y,vvehicles[i].z,maps[get_map_index(vvehicles[i].map)])+", with "+vvehicles[i].health+" health. ";
}
}
send_reliable(p,""+(vvs==""?"nothing found":"vehicles: "+vvs+"")+"",2);
server_menu m;
m.intro="properties menu";
m.initial_packet="propertieslist";
m.add("your air conditioners","air_conditioners");
m.add("your beehives","beehives");
m.add("your cars","vehicles");
m.add("your fans","fans");
m.add("your fridges","fridges");
m.add("your house","house");
m.add("your lockers","lockers");
m.add("your microwaves","microwaves");
m.add("your motorcycles","motors");
m.add("your steams","steams");
m.add("your stores","stores");
m.send(p.peer_id);
}
}
else if(parsed[0]=="housepasschange" and parsed.length()>1)
{
if(parsed[1]=="back")
{
p.sendpacket("canceled", 0);
return;
}
for(uint i=0; i<houses.length(); i++)
{
if(houses[i].owner==p.name)
{
if(string_is_digits(parsed[1]))
{
houses[i].code=string_to_number(parsed[1]);
send_reliable(p,"your house code has been changed to "+parsed[1]+"",2);
}
}
}
}
else if(parsed[0]=="employ" and parsed.length()>1)
{
if(parsed[1]=="back")
{
p.sendpacket("canceled", 0);
return;
}
else if(parsed[1]=="quitjob")
{
if(p.inv_item_number("coins")<=20000)
{
send_reliable(p, "not enough money", 0);
return;
}
p.job="";
p.inv_add_item("coins",-20000);
servermoney+=20000;
send_reliable(p,"done",2);
p.jobtitle="";
}
else if(parsed[1]=="salesman")
{
if(p.inv_item_number("coins")<=15000)
{
send_reliable(p, "not enough money", 0);
return;
}
p.job="salesman";
p.inv_add_item("coins",-15000);
servermoney+=15000;
send_reliable(p,"you are now a salesman",2);
p.jobtitle="salesman";
}
else if(parsed[1]=="saleswoman")
{
if(p.inv_item_number("coins")<=15000)
{
send_reliable(p, "not enough money", 0);
return;
}
p.job="saleswoman";
p.inv_add_item("coins",-15000);
servermoney+=15000;
send_reliable(p,"you are now a saleswoman",2);
p.jobtitle="saleswoman";
}
}
else if(parsed[0]=="marriage" and parsed.length()>1)
{
if(parsed[1]=="back")
{
p.sendpacket("canceled", 0);
return;
}
server_menu m;
m.intro=""+p.name+", are you sure you want to marry to "+parsed[1]+" and pay "+p.inv_item_number("coins")/10+" coins?";
m.initial_packet="marriage2";
m.add("yes",parsed[1]);
m.add("no","no");
m.send(p.peer_id);
}
else if(parsed[0]=="marriage2" and parsed.length()>1)
{
if(parsed[1]=="back")
{
p.sendpacket("canceled", 0);
return;
}
else if(parsed[1]=="no")
{
send_reliable(p,"ok",2);
return;
}
else
{
int index2=get_player_index_from(parsed[1]);
if(index2<0)
{
send_reliable(p,""+parsed[1]+" is offline",2);
return;
}
server_menu m;
m.intro=""+players[index2].name+", "+p.name+" wants to marry to you, do you accept and pay "+players[index2].inv_item_number("coins")/10+" coins?";
m.initial_packet="marriage3";
m.add("yes",p.name);
m.add("no","no");
m.send(players[index2].peer_id);
}
}
else if(parsed[0]=="marriage3" and parsed.length()>1)
{
if(parsed[1]=="back")
{
p.sendpacket("canceled", 0);
return;
}
else if(parsed[1]=="no")
{
send_reliable(p,"ok",2);
return;
}
else
{
int index2=get_player_index_from(parsed[1]);
if(index2<0)
{
send_reliable(p,""+parsed[1]+" is offline",2);
return;
}
double d=round(p.inv_item_number("coins")/10,0);
double d2=round(players[index2].inv_item_number("coins")/10,0);
double d3=d+d2;
send_reliable(p,"you've paid "+d+" coins to get married with "+players[index2].name+"",2);
servermoney+=d;
p.inv_add_item("coins",-d);
send_reliable(players[index2],"you've paid "+d2+" coins to get married with "+p.name+"",2);
servermoney+=d2;
players[index2].inv_add_item("coins",-d2);
p.ex_partner="";
players[index2].ex_partner="";
p.partner=players[index2].name;
players[index2].partner=p.name;
p.trust(players[index2]);
players[index2].trust(p);
send_reliable(p,""+p.name+" and "+players[index2].name+": Me as the mayor and with the authority given to me, declare you as a couple!",2);
send_reliable(players[index2],""+p.name+" and "+players[index2].name+": Me as the mayor and with the authority given to me, declare you as a couple!",2);
send_reliable(0,"attention! "+p.name+" and "+players[index2].name+" got married! "+p.name+" paid "+d+" coins and "+players[index2].name+" paid "+d2+" coins, adding up to a total of "+d3+" coins",2);
int n=random(1,2);
if(n==1) send_reliable(0, "play_s fireworkloop.ogg", 6);
else if(n==2) send_reliable(0, "play_s fireworkloop.ogg", 6);
send_reliable(0, "play_s applause"+random(1,6)+".ogg", 6);
}
}
else if(parsed[0]=="devorce" and parsed.length()>1)
{
if(parsed[1]=="back")
{
p.sendpacket("canceled", 0);
return;
}
server_menu m;
m.intro=""+p.name+", are you sure you want to devorce from "+parsed[1]+" and pay "+p.inv_item_number("coins")/2+" coins?";
m.initial_packet="devorce2";
m.add("yes",parsed[1]);
m.add("no","no");
m.send(p.peer_id);
}
else if(parsed[0]=="devorce2" and parsed.length()>1)
{
if(parsed[1]=="back")
{
p.sendpacket("canceled", 0);
return;
}
else if(parsed[1]=="no")
{
send_reliable(p,"ok",2);
return;
}
else
{
int index2=get_player_index_from(p.partner);
if(index2<0)
{
send_reliable(p,""+parsed[1]+" is offline",2);
return;
}
server_menu m;
m.intro=""+players[index2].name+", "+p.name+" wants to devorce from you, do you accept and pay "+players[index2].inv_item_number("coins")/2+" coins?";
m.initial_packet="devorce3";
m.add("yes",p.name);
m.add("no","no");
m.send(players[index2].peer_id);
}
}
else if(parsed[0]=="devorce3" and parsed.length()>1)
{
if(parsed[1]=="back")
{
p.sendpacket("canceled", 0);
return;
}
else if(parsed[1]=="no")
{
send_reliable(p,"ok",2);
return;
}
else
{
int index2=get_player_index_from(p.partner);
if(index2<0)
{
send_reliable(p,""+parsed[1]+" is offline",2);
return;
}
double d=round(p.inv_item_number("coins")/2,0);
double d2=round(players[index2].inv_item_number("coins")/2,0);
double d3=d+d2;
send_reliable(p,"you've paid "+d+" coins to devorce from "+players[index2].name+"",2);
servermoney+=d;
p.inv_add_item("coins",-d);
send_reliable(players[index2],"you've paid "+d2+" coins to devorce from "+p.name+"",2);
servermoney+=d2;
players[index2].inv_add_item("coins",-d2);
p.partner="";
players[index2].partner="";
p.ex_partner=players[index2].name;
players[index2].ex_partner=p.name;
p.untrust(players[index2].name);
players[index2].untrust(p.name);
send_reliable(p,"court judgment: "+p.name+" and "+players[index2].name+": Me as the judge, I declare you as two single individuals. You are now devorced.",2);
send_reliable(players[index2],"court judgment: "+p.name+" and "+players[index2].name+": Me as the judge, I declare you as two single individuals. You are now devorced.",2);
send_reliable(0,"attention! "+p.name+" and "+players[index2].name+" devorced. "+p.name+" paid "+d+" coins and "+players[index2].name+" paid "+d2+" coins, adding up to a total of "+d+d2+" coins",2);
send_reliable(0, "play_s notify"+random(1,10)+".ogg", 6);
}
}
else if(parsed[0]=="editline" and parsed.length()>1)
{
if(parsed[1]=="back")
{
p.sendpacket("canceled", 0);
return;
}
send_reliable(p,"buildeditline "+string_replace(get_event_message(),parsed[0]+" ","",true),0);
p.editline=string_replace(get_event_message(),parsed[0]+" ","",true);
}
else if(parsed[0]=="removeline" and parsed.length()>1)
{
if(parsed[1]=="back")
{
p.sendpacket("canceled", 0);
return;
}
send_reliable(p,"buildremoveline "+string_replace(get_event_message(),parsed[0]+" ","",true),0);
p.removeline=string_replace(get_event_message(),parsed[0]+" ","",true);
}
else if(parsed[0]=="aieditlinetext" and parsed.length()>1)
{
if(parsed[1]=="back")
{
p.sendpacket("canceled", 0);
return;
}
send_reliable(p,"buildaieditlinetext "+string_replace(get_event_message(),parsed[0]+" ","",true),0);
p.aieditline=string_replace(get_event_message(),parsed[0]+" ","",true);
}
else if(parsed[0]=="airemovelinetext" and parsed.length()>1)
{
if(parsed[1]=="back")
{
p.sendpacket("canceled", 0);
return;
}
send_reliable(p,"buildairemovelinetext "+string_replace(get_event_message(),parsed[0]+" ","",true),0);
p.airemoveline=string_replace(get_event_message(),parsed[0]+" ","",true);
}
else if(parsed[0]=="drawsoundseditlinetext" and parsed.length()>1)
{
if(parsed[1]=="back")
{
p.sendpacket("canceled", 0);
return;
}
send_reliable(p,"builddrawsoundseditlinetext "+string_replace(get_event_message(),parsed[0]+" ","",true),0);
p.drawsoundseditline=string_replace(get_event_message(),parsed[0]+" ","",true);
}
else if(parsed[0]=="drawsoundsremovelinetext" and parsed.length()>1)
{
if(parsed[1]=="back")
{
p.sendpacket("canceled", 0);
return;
}
send_reliable(p,"builddrawsoundsremovelinetext "+string_replace(get_event_message(),parsed[0]+" ","",true),0);
p.drawsoundsremoveline=string_replace(get_event_message(),parsed[0]+" ","",true);
}
else if(parsed[0]=="itemusagelimiteditlinetext" and parsed.length()>1)
{
if(parsed[1]=="back")
{
p.sendpacket("canceled", 0);
return;
}
send_reliable(p,"builditemusagelimiteditlinetext "+string_replace(get_event_message(),parsed[0]+" ","",true),0);
p.itemusagelimiteditline=string_replace(get_event_message(),parsed[0]+" ","",true);
}
else if(parsed[0]=="itemusagelimitremovelinetext" and parsed.length()>1)
{
if(parsed[1]=="back")
{
p.sendpacket("canceled", 0);
return;
}
send_reliable(p,"builditemusagelimitremovelinetext "+string_replace(get_event_message(),parsed[0]+" ","",true),0);
p.itemusagelimitremoveline=string_replace(get_event_message(),parsed[0]+" ","",true);
}
else if(parsed[0]=="fadeditlinetext" and parsed.length()>1)
{
if(parsed[1]=="back")
{
p.sendpacket("canceled", 0);
return;
}
p.fadtoedit=parsed[1];
file f;
f.open("foods_and_drinks/"+parsed[1],"rb");
send_reliable(p,"buildfadeditlinetext "+f.read(),0);
f.close();
}
else if(parsed[0]=="removeowner" and parsed.length()>1)
{
if(parsed[1]=="back")
{
p.sendpacket("canceled", 0);
return;
}
send_reliable(p,"buildremoveowner "+string_replace(get_event_message(),parsed[0]+" ","",true),0);
p.removeowner=string_replace(get_event_message(),parsed[0]+" ","",true);
}
else if(parsed[0]=="reviveset" and parsed.length()>1)
{
if(parsed[1]=="back")
{
p.sendpacket("canceled", 0);
return;
}
string name=string_trim_left(parsed[1],10);
spawn_ai(p.x,p.y,p.z,maps[get_map_index(p.map)],name,1);
p.inv_add_item("animal_revitalizer",-1);
p.inv_add_item("corpse_of_"+name+"",-1);
if(p.pvp!=1)
{
p.pvp=1;
send_reliable(p,"You are now pvp!",2);
send_reliable(0,"play_s pvpon.ogg",6);
send_reliable(0,""+p.nickname+" is now pvp!",2);
}
}
else if(parsed[0]=="friendshipset" and parsed.length()>1 and p.looking=="" and p.prison==false)
{
if(parsed[1]=="back")
{
p.sendpacket("canceled", 0);
return;
}
if(parsed[1]==p.name)
{
p.sendpacket("you can't do this", 0);
return;
}
for(uint i=0; i<arenas.length(); i++)
{
if(p.map==arenas[i].map)
{
send_reliable(p,"You can't do this in here",2);
return;
}
}
string charfolder="chars/"+p.name;
string[] a=string_split(file_get_contents("pbmaps.svr"),"\r\n",false);
string[] a2=string_split(file_get_contents(charfolder+"/maps.usr"),"\r\n",false);
string[] a3=string_split(file_get_contents("chmaps.svr"),"\r\n",false);
int something=a.find(p.map);
int something2=a2.find(p.map);
int something3=a3.find(p.map);
if(something>-1 or something2>-1 or something3>-1)
{
send_reliable(p,"you can't do this",2);
return;
}
int i2=get_player_index_from(parsed[1]);
if(i2>-1)
{
string charfolder="chars/"+players[i2].name;
string[] a=string_split(file_get_contents("pbmaps.svr"),"\r\n",false);
string[] a2=string_split(file_get_contents(charfolder+"/maps.usr"),"\r\n",false);
string[] a3=string_split(file_get_contents("chmaps.svr"),"\r\n",false);
int something=a.find(players[i2].map);
int something2=a2.find(players[i2].map);
int something3=a3.find(players[i2].map);
if(something>-1 or something2>-1 or something3>-1)
{
send_reliable(p,"you can't do this",2);
return;
}
for(uint i=0; i<arenas.length(); i++)
{
if(arenas[i].map==players[i2].map)
{
send_reliable(p,""+players[i2].name+" is in an arena and you can't go to him",2);
return;
}
}
if(players[i2].map=="jail")
{
p.sendpacket(""+players[i2].name+" is in jail", 2);
return;
}
int mi=get_map_index(players[i2].map);
if((mi>-1))
{
string mdata=maps[mi].rawdata;
string[] p1=delinear(mdata);
for(uint i=0; i<p1.length(); i++)
{
string[] parsed=string_split(p1[i], ":", true);
if(parsed[0]=="safezone" and parsed.length()>6 and p.pvp==1)
{
send_reliable(p,"you can't go to "+players[i2].map+"'s map when you are pvp",2);
return;
}
}
move_player(p,players[i2].map,players[i2].x,players[i2].y,players[i2].z);
if(maps[mi].pvp==1 and maps[mi].pvpminx<=p.x and maps[mi].pvpmaxx>=p.x and maps[mi].pvpminy<=p.y and maps[mi].pvpmaxy>=p.y and maps[mi].pvpminz<=p.z and maps[mi].pvpmaxz>=p.z)
{
if(p.pvp!=1)
{
p.pvp=1;
send_reliable(p,"You are now pvp!",2);
send_reliable(0,"play_s pvpon.ogg",6);
send_reliable(0,""+p.nickname+" is now pvp!",2);
}
}
else if(maps[mi].pvp==2 and maps[mi].pvpminx<=p.x and maps[mi].pvpmaxx>=p.x and maps[mi].pvpminy<=p.y and maps[mi].pvpmaxy>=p.y and maps[mi].pvpminz<=p.z and maps[mi].pvpmaxz>=p.z)
{
if(p.pvp!=0)
{
p.pvp=0;
send_reliable(p,"You are no longer pvp!",2);
send_reliable(0,"play_s pvpoff.ogg",6);
send_reliable(0,""+p.nickname+" is no longer pvp!",2);
}
}
send_packet(6,"play tele.ogg "+p.x+" "+p.y+" "+p.z, p.x,p.y,p.z,maps[get_map_index(p.map)]);
p.inv_add_item("friendship_sphere", -1);
}
}
}
else if(parsed[0]=="objs") 
{
string data;
for(int i=0; i<objs.length(); i++)
{
double distance=get_3d_distance(p.x, p.y, p.z, objs[i].x, objs[i].y, objs[i].z);
distance=round(distance, 0);
if(p.map==objs[i].map.name and distance<31)
data+=objs[i].amount+":"+objs[i].name+":"+objs[i].x+":"+objs[i].y+":"+objs[i].z+":"+distance+"@";
}
for(int i=0; i<silenceobjs.length(); i++)
{
double distance=get_3d_distance(p.x, p.y, p.z, silenceobjs[i].x, silenceobjs[i].y, silenceobjs[i].z);
distance=round(distance, 0);
if(p.map==silenceobjs[i].map.name and distance<31)
data+=silenceobjs[i].amount+":"+silenceobjs[i].name+":"+silenceobjs[i].x+":"+silenceobjs[i].y+":"+silenceobjs[i].z+":"+distance+"@";
}
if(data=="")
send_reliable(p, "No items around you", 2);
else
send_reliable(p, "objs "+data, 0);
}
else if(parsed[0]=="hfish")
{
if(p.tenter.elapsed>=600)
{
p.tenter.restart();
string tile=get_tile_at(p.x,p.y,p.z,maps[get_map_index(p.map)]);
if (tile=="water" or tile=="water2" or tile=="water3" or tile=="water4" or tile=="water5" or tile=="water6" or tile=="water7" or tile=="water8" or tile=="water9" or tile=="water10" or tile=="puddle" or tile=="deepwater" or tile=="swim" or tile=="swimming" or tile=="swimming2" or tile=="spring" or tile=="spring2" or tile=="wallboat" and p.jpescar)
{
if(p.npescar>0)
{
p.npescar--;
p.tppeixe.restart();
if(p.npescar<0)p.npescar=0;
if(p.ppeixe==1) send_packet(6,"play fishlure.ogg "+p.x+" "+p.y+" "+p.z, p.x,p.y,p.z,maps[get_map_index(p.map)]);
else
{
send_packet(6,"play fishreal.ogg "+p.x+" "+p.y+" "+p.z, p.x,p.y,p.z,maps[get_map_index(p.map)]);
p.plinha=1;
}
if(p.npescar==0)
{
p.tppeixe.force(0);p.tppeixe.pause();
if(p.ppeixe==1) send_packet(6,"play getfish.ogg "+p.x+" "+p.y+" "+p.z, p.x,p.y,p.z,maps[get_map_index(p.map)]); p.inv_add_item("fish", 1);
send_reliable(p, "hempty "+parsed[2], 0);
p.ppeixe=0;
p.plinha=0;
}
}
else if(p.npescar<=0)
{
p.npescar=1;
p.npescando=0;
p.tppeixe.restart();
p.npescar=random(15, 35);
p.npescando=1;
}
send_packet(6,"play fishcast.ogg "+p.x+" "+p.y+" "+p.z, p.x,p.y,p.z,maps[get_map_index(p.map)]);
}
return;
}
}
else if(parsed[0]=="transfer" and parsed.length()>2)
{
if(file_exists("chars/"+p.name+"/"+parsed[1]+".usr")==true)
{
f.open("chars/"+p.name+"/"+parsed[1]+".usr", "rb");
double ar=string_to_number(f.read());
f.close();
send_reliable(p, "you've already transfered "+ar+" "+parsed[1]+"", 2);
return;
}
double amount=string_to_number(parsed[2]);
if(amount<=p.inv_item_number(parsed[1]) and amount>0)
{
if(string_contains(parsed[1],"credit",1)>-1 or string_contains(parsed[1],"paid_gift",1)>-1 or string_contains(parsed[1],"quick_thirst_fix_drug",1)>-1 or string_contains(parsed[1],"quick_hunger_fix_snack",1)>-1 or string_contains(parsed[1],"xp_potion",1)>-1 or string_contains(parsed[1],"armor",1)>-1 or string_contains(parsed[1],"safe_card",1)>-1 or string_contains(parsed[1],"health_box",1)>-1 or string_contains(parsed[1],"energy_box",1)>-1 or string_contains(parsed[1],"teleporter",1)>-1 or string_contains(parsed[1],"nuclear_bomb",1)>-1 or string_contains(parsed[1],"small_nuclear_bomb",1)>-1 or string_contains(parsed[1],"large_nuclear_bomb",1)>-1)
{
p.inv_add_item(parsed[1],-amount);
file_put_contents("chars/"+p.name+"/"+parsed[1]+".usr",amount,250);
p.add_log_entry("player_actions","transfered "+amount+" "+parsed[1]+"");
send_reliable(p, "you've transfered "+amount+" "+parsed[1]+"", 2);
}
}
}
else if(parsed[0]=="admintell" and parsed.length()>1)
{
if(p.ds.find("chat")>-1)
{
send_reliable(p,"your chats have been disabled",0);
return;
}
string final;
final=string_trim_left(get_event_message(),10);
admintell("admintell message from "+p.name+": "+final);
if(!p.is_admin())
send_reliable(p,"Your message has been sent to the admins.",2);
f.open("admintells.svr","ab");
f.write(p.name+" said: "+final+"\r\n");
f.close();
}
else if(parsed[0]=="weaponpings")
{
if(p.weaponpings==0)
{
p.weaponpings=1;
send_reliable(p,"play_s toggleon.ogg",6);
send_reliable(p,"weapon pings enabled",2);
}
else
{
p.weaponpings=0;
send_reliable(p,"play_s toggleoff.ogg",6);
send_reliable(p,"weapon pings disabled",2);
}
}
else if(parsed[0]=="pmreceive")
{
p.pmreceiving=toggle(p.pmreceiving);
if(p.pmreceiving==0)
{
send_reliable(p,"play_s toggleoff.ogg",6);
send_reliable(p,"You will no longer receive private messages",0);
}
else
{
send_reliable(p,"play_s toggleon.ogg",6);
send_reliable(p,"You will receive private messages from now on",0);
return;
}
}
else if(parsed[0]=="beacon")
{
p.beacon=toggle(p.beacon);
if(p.beacon==0)
{
send_reliable(p,"play_s toggleoff.ogg",6);
send_reliable(p,"beacons disabled",0);
}
else
{
send_reliable(p,"play_s toggleon.ogg",6);
send_reliable(p,"beacons enabled",0);
return;
}
}
else if(parsed[0]=="localchat" and parsed.length()>=1)
{
if(p.ds.find("chat")>-1)
{
send_reliable(p,"your chats have been disabled",0);
return;
}
if(p.away==true and string_replace(get_event_message(),parsed[0]+" ","",true)!="/afk" and !p.is_admin()==false)
{
send_reliable(p,"You can't chat while you are away",2);
return;
}
if(chatting==0)
{
string message;
message="Sorry, server chats are currently disabled.";
if(p.is_admin()) message+=" If you want to turn them back on, type /varset chatting 1";
send_reliable(p,message,2);
return;
}
if(p.looking=="")
{
p.chats+=1;
log(p.name+"_chats","local chat from "+p.name+": "+string_replace(get_event_message(),parsed[0]+" ","",true),true,true);
send_packet(0,"localchat local chat from "+p.title+" "+p.nickname+" ("+p.name+"): "+string_replace(get_event_message(),parsed[0]+" ","",true),p.x,p.y,p.z,maps[get_map_index(p.map)]);
}
}
else if(parsed[0]=="levelsound")
{
if(p.levelsound==0)
{
p.levelsound=1;
send_reliable(p,"play_s toggleon.ogg",6);
send_reliable(p,"level sounds enabled", 2);
}
else if(p.levelsound==1)
{
p.levelsound=0;
send_reliable(p,"play_s toggleoff.ogg",6);
send_reliable(p,"level sounds disabled", 2);
}
}
else if(parsed[0]=="2dnewmap" and parsed.length()>8 and p.prison==false)
{ 
string mapname=parsed[1];
if(map_exists(mapname))
{
send_reliable(p,"this map already exists",0);
return;
}
if(string_contains(mapname,"house_of_",1)>-1 or string_contains(mapname,"beehive_of_",1)>-1 or string_contains(mapname,"store_of_",1)>-1)
{
send_reliable(p,"error: please change the map name",0);
return;
}
int minx=string_to_number(parsed[2]);
int maxx=string_to_number(parsed[3]);
int miny=string_to_number(parsed[4]);
int maxy=string_to_number(parsed[5]);
int minz=string_to_number(parsed[6]);
int maxz=string_to_number(parsed[7]);
string platform=parsed[8];
int volume=string_to_number(parsed[9]);
int pitch=string_to_number(parsed[10]);
string owner=p.name;
int litem=1;
f.open("maps/"+mapname+".map","wb");
f.write("mapname:"+mapname+"\r\nminx:"+minx+"\r\nmaxx:"+maxx+"\r\nminy:"+miny+"\r\nmaxy:"+maxy+"\r\nminz:"+minz+"\r\nmaxz:"+maxz+"\r\ntile:"+minx+":"+maxx+":"+miny+":"+maxy+":0:0:"+volume+":"+pitch+":"+platform+"\r\nowner:"+owner+"\r\nlitem:"+litem+"\r\nsafe_card:0\r\nstarting_point:"+minx+":"+maxx+":"+miny+":"+maxy+":0:0\r\ndeathpoint:"+minx+":"+maxx+":"+miny+":"+maxy+":0:0\r\nenable:2dsupport");
f.close();
init_mapsystem();
move_player(p,mapname,0,0,0,true);
if(string_contains(mapname,"house_of_",1)<0 and string_contains(mapname,"beehive_of_",1)<0 and string_contains(mapname,"store_of_",1)<0) file_put_contents("chars/"+p.name+"/maps.usr",""+mapname+"\r\n",255);
send_reliable(p,"Done",0);
}
else if(parsed[0]=="newmap" and parsed.length()>8 and p.prison==false)
{ 
string mapname=parsed[1];
if(map_exists(mapname))
{
send_reliable(p,"this map already exists",0);
return;
}
if(string_contains(mapname,"house_of_",1)>-1 or string_contains(mapname,"beehive_of_",1)>-1 or string_contains(mapname,"store_of_",1)>-1)
{
send_reliable(p,"error: please change the map name",0);
return;
}
int minx=string_to_number(parsed[2]);
int maxx=string_to_number(parsed[3]);
int miny=string_to_number(parsed[4]);
int maxy=string_to_number(parsed[5]);
int minz=string_to_number(parsed[6]);
int maxz=string_to_number(parsed[7]);
string platform=parsed[8];
int volume=string_to_number(parsed[9]);
int pitch=string_to_number(parsed[10]);
string owner=p.name;
int litem=1;
f.open("maps/"+mapname+".map","wb");
f.write("mapname:"+mapname+"\r\nminx:"+minx+"\r\nmaxx:"+maxx+"\r\nminy:"+miny+"\r\nmaxy:"+maxy+"\r\nminz:"+minz+"\r\nmaxz:"+maxz+"\r\ntile:"+minx+":"+maxx+":"+miny+":"+maxy+":0:0:"+volume+":"+pitch+":"+platform+"\r\nowner:"+owner+"\r\nlitem:"+litem+"\r\nsafe_card:0\r\nstarting_point:"+minx+":"+maxx+":"+miny+":"+maxy+":0:0\r\ndeathpoint:"+minx+":"+maxx+":"+miny+":"+maxy+":0:0");
f.close();
init_mapsystem();
move_player(p,mapname,0,0,0,true);
if(string_contains(mapname,"house_of_",1)<0 and string_contains(mapname,"beehive_of_",1)<0 and string_contains(mapname,"store_of_",1)<0) file_put_contents("chars/"+p.name+"/maps.usr",""+mapname+"\r\n",255);
send_reliable(p,"Done",0);
}
else if(parsed[0]=="uploadsound")
{
if(can_upload_files==0&&p.dev==false) send_reliable(p,"Sorry! File uploading is not permitted!",2);
else send_reliable(p,"upload",0);
}
else if(parsed[0]=="vpartnercheck")
{
if(p.partner!="" and p.ex_partner=="")
{
send_reliable(p,"vpartnercheck",0);
}
}
else if(parsed[0]=="delmap" and parsed.length()>1)
{
}
else if(parsed[0]=="auction" and parsed.length()>=5)
{
if(p.prison==true)
{
send_reliable(p,"You can't do this in prison",2);
return;
}
for(uint i=0; i<arenas.length(); i++)
{
if(p.map==arenas[i].map)
{
send_reliable(p,"You can't do this in here",2);
return;
}
}
string[] adg=string_split(file_get_contents("notadg.svr"),"\r\n",false);
int something=adg.find(parsed[2]);
if(something>-1)
{
send_reliable(p,"You can't auction "+parsed[2]+"",2);
return;
}
if(string_contains(parsed[1],".",1)>-1)
{
string[] amount=string_split(parsed[1],".",false);
if(string_to_number(amount[0])<=0)
{
send_reliable(p,"You cannot auction negative amounts!",2);
}
else
{
string what=parsed[2];
string currency=parsed[3];
if(string_contains(parsed[4],".",1)>-1)
{
string[] minbid=string_split(parsed[4],".",false);
if(string_to_number(minbid[0])<=0)
{
send_reliable(p,"you cannot have a negative bid!",2);
}
else
{
if (auction==false)
{
if (p.inv.exists(what))
{
if (p.inv_item_number(what)>=string_to_number(amount[0]))
{
auctionitem=what;
auctioncurrency=currency;
auctionbid=string_to_number(minbid[0]);
auctionamount=string_to_number(amount[0]);
auctionwho=p.name;
send_reliable(0,"auctions New auction from "+p.nickname+"! "+amount[0]+" "+auctionitem+", minimum bid "+minbid[0]+" "+auctioncurrency+".",0);
send_reliable(0,"play_s auction.ogg",6);
auctiontimer.restart();
auction=true;
auctionbidder=false;
}
else
{
send_reliable(p,"You don't have this many.",2);
}
}
else
{
send_reliable(p,"You don't have this item.",2);
}
}
}
}
else
{
double minbid=string_to_number(parsed[4]);
if(minbid<=0)
{
send_reliable(p,"you cannot have a negative bid!",2);
}
else
{
if (auction==false)
{
if (p.inv.exists(what))
{
if (p.inv_item_number(what)>=string_to_number(amount[0]))
{
auctionitem=what;
auctioncurrency=currency;
auctionbid=minbid;
auctionamount=string_to_number(amount[0]);
auctionwho=p.name;
send_reliable(0,"auctions New auction from "+p.nickname+"! "+amount[0]+" "+auctionitem+", minimum bid "+minbid+" "+auctioncurrency+".",0);
send_reliable(0,"play_s auction.ogg",6);
auctiontimer.restart();
auction=true;
auctionbidder=false;
}
else
{
send_reliable(p,"You don't have this many.",2);
}
}
else
{
send_reliable(p,"You don't have this item.",2);
}
}
}
}
}
}
else
{
double amount=string_to_number(parsed[1]);
if(amount<=0)
{
send_reliable(p,"You cannot auction negative amounts!",2);
}
else
{
string what=parsed[2];
string currency=parsed[3];
if(string_contains(parsed[4],".",1)>-1)
{
string[] minbid=string_split(parsed[4],".",false);
if(string_to_number(minbid[0])<=0)
{
send_reliable(p,"you cannot have a negative bid!",2);
}
else
{
if (auction==false)
{
if (p.inv.exists(what))
{
if (p.inv_item_number(what)>=amount)
{
auctionitem=what;
auctioncurrency=currency;
auctionbid=string_to_number(minbid[0]);
auctionamount=amount;
auctionwho=p.name;
send_reliable(0,"auctions New auction from "+p.nickname+"! "+amount+" "+auctionitem+", minimum bid "+minbid[0]+" "+auctioncurrency+".",0);
send_reliable(0,"play_s auction.ogg",6);
auctiontimer.restart();
auction=true;
auctionbidder=false;
}
else
{
send_reliable(p,"You don't have this many.",2);
}
}
else
{
send_reliable(p,"You don't have this item.",2);
}
}
}
}
else
{
double minbid=string_to_number(parsed[4]);
if(minbid<=0)
{
send_reliable(p,"you cannot have a negative bid!",2);
}
else
{
if (auction==false)
{
if (p.inv.exists(what))
{
if (p.inv_item_number(what)>=amount)
{
auctionitem=what;
auctioncurrency=currency;
auctionbid=minbid;
auctionamount=amount;
auctionwho=p.name;
send_reliable(0,"auctions New auction from "+p.nickname+"! "+amount+" "+auctionitem+", minimum bid "+minbid+" "+auctioncurrency+".",0);
send_reliable(0,"play_s auction.ogg",6);
auctiontimer.restart();
auction=true;
auctionbidder=false;
}
else
{
send_reliable(p,"You don't have this many.",2);
}
}
else
{
send_reliable(p,"You don't have this item.",2);
}
}
}
}
}
}
}
else if(string_left(parsed[0],12)=="transferinv/" and parsed.length>1)
{
if(parsed[1]=="[cncel]") return;
double amount=string_to_number(parsed[1]);
parsed=string_split(parsed[0],"/",false);
if(parsed[1]==p.name)
{
send_reliable(p,"What would be the point in transfering something to yourself? You already have it!",0);
return;
}
int index2=get_player_index_from(parsed[1]);
if(index2<0)
{
send_reliable(p,"player "+parsed[1]+" not found",0);
return;
}
if (p.inv_item_number(parsed[2])>=amount)
{
if(p.distancecheck(players[index2].x,players[index2].y,players[index2].z)<=5 and p.map==players[index2].map)
{
string[] adg=string_split(file_get_contents("notadg.svr"),"\r\n",false);
int something=adg.find(parsed[2]);
if(something>-1)
{
send_reliable(p,"You can't give "+parsed[2]+"",2);
return;
}
if(amount<=0)
{
send_reliable(p,"An error has occured. Error region: item transfer. Error description: attempted to give non-positive number of item to a player",2);
return;
}
p.inv_add_item(parsed[2],-amount);
players[index2].inv_add_item(parsed[2],amount);
send_packet(6,"play give.ogg "+p.x+" "+p.y+" "+p.z, p.x,p.y,p.z,maps[get_map_index(p.map)]);
send_reliable(p,"Done",0);
send_reliable(players[index2],p.nickname+" has given you "+amount+" "+parsed[2]+"!",2);
}
else
{
send_reliable(p,"Error: "+players[index2].name+" is too far away from you. You must be at least 5 tiles in range to give items",0);
return;
}
}
}
else if (parsed[0]=="inv" and parsed.length()>=3)
{
p.inv_add_item(parsed[1],string_to_number(parsed[2]));
}
else if(parsed[0]=="giveitem" and parsed.length()>1)
{
if(p.looker=="" and p.looking=="")
{
string item=parsed[1];
double itemamount=p.inv_item_number(item);
if(itemamount<=0)
{
p.sendpacket("You dont' have any "+item+"",0);
return;
}
if(string_contains(parsed[1],"rocket_launcher",1)!=-1 or string_contains(parsed[1],"nak_nk1000_decimater",1)!=-1)
{
send_reliable(p, "you can't give "+parsed[1]+"", 12);
return;
}
if(auction==true and auctionwho==p.name and auctionitem==item or auction==true and auctionwho==p.name and auctioncurrency==item)
{
send_reliable(p,"you can't give "+item+" to someone while putting it in auction",2);
return;
}
if(auction==true and auctionwho2==p.name)
{
send_reliable(p,"you can't do this while bidding",2);
return;
}
string[] names;
for(uint px=0; px<players.length(); px+=1)
{
if(p.name==players[px].name) continue;
if(players[px].distancecheck(p.x,p.y,p.z)<=5 and players[px].map==p.map) names.insert_last(players[px].name);
}
if(names.length()<=0)
{
p.sendpacket("There are no players near you",0);
return;
}
server_menu m;
m.initial_packet="playergive/"+item;
m.intro="players menu";
for(uint i=0; i<names.length(); i++)
{
m.add(names[i],names[i]);
}
m.send(p.peer_id);
}
}
else if(string_left(parsed[0],11)=="playergive/" and parsed.length()>1)
{
parsed.insert_last(parsed[1]);
parsed[1]=string_trim_left(parsed[0],11);
string n=parsed[2];
if(n=="back") return;
int index2=get_player_index_from(parsed[2]);
if(index2<0)
{
p.sendpacket("Player not found",0);
return;
}
int dist=players[index2].distancecheck(p.x,p.y,p.z);
if(dist>5 or players[index2].map!=p.map)
{
p.sendpacket("This player is too far away",0);
return;
}
send_serverbox(p.peer_id,2,-1,1,-1,"transferinv/"+n+"/"+parsed[1],"How many "+parsed[1]+"s would you like to give to "+n+"?");
}
else if(parsed[0]=="mtester" and parsed.length()>1)
{
string mapname=parsed[1];
if(file_exists("maps/"+mapname+".map"))
{
p.finishchallengemaptimer.force(0);
p.finishchallengemaptimer.pause();
move_player(p,mapname,0,0,0,true);
}
}
else if(parsed[0]=="mtester3" and parsed.length()>1)
{
string mapname=parsed[1];
if(file_exists("maps/"+mapname+".map"))
{
p.finishchallengemaptimer.force(0);
p.finishchallengemaptimer.pause();
move_player(p,mapname,0,0,0,true);
}
}
else if(parsed[0]=="publicmapgo" and parsed.length()>1)
{
if(parsed[1]=="back")
{
p.sendpacket("canceled", 0);
return;
}
if(!map_exists(parsed[1]))
{
send_reliable(p,"this map does not exists",2);
return;
}
int mi=get_map_index(parsed[1]);
if((mi>-1))
{
if(TIME_HOUR<maps[mi].minhour or TIME_HOUR>maps[mi].maxhour)
{
send_reliable(p,""+maps[mi].name+" is currently closed. Opening hours: "+maps[mi].minhour+" until "+maps[mi].maxhour+"",2);
return;
}
if(p.level<maps[mi].minlevel or p.level>maps[mi].maxlevel)
{
send_reliable(p,""+maps[mi].name+" is only for players with level range of "+maps[mi].minlevel+" until "+maps[mi].maxlevel+"",2);
return;
}
if(p.reinforcement<maps[mi].minreinforcement or p.reinforcement>maps[mi].maxreinforcement)
{
send_reliable(p,""+maps[mi].name+" is only for players with reinforcement range of "+maps[mi].minreinforcement+" until "+maps[mi].maxreinforcement+"",2);
return;
}
string s="";
string s2;
if(maps[mi].owners.length>1)
{
for(uint i=0; i<maps[mi].owners.length(); i++)
{
if(i==(maps[mi].owners.length-1)) s+="and "+maps[mi].owners[i]+".";
else s+=maps[mi].owners[i]+", ";
}
}
else
for(uint i=0; i<maps[mi].owners.length(); i++){
s=maps[mi].owners[i]+".";}
if(maps[mi].owners.length()>1) s2=" "+maps[mi].owners.length()+" owners: ";
else s2=" "+maps[mi].owners.length()+" owner: ";
move_player(p,parsed[1],random(maps[mi].spminx,maps[mi].spmaxx),random(maps[mi].spminy,maps[mi].spmaxy),random(maps[mi].spminz,maps[mi].spmaxz),true);
if(maps[mi].pvp==1 and maps[mi].pvpminx<=p.x and maps[mi].pvpmaxx>=p.x and maps[mi].pvpminy<=p.y and maps[mi].pvpmaxy>=p.y and maps[mi].pvpminz<=p.z and maps[mi].pvpmaxz>=p.z)
{
if(p.pvp!=1)
{
p.pvp=1;
send_reliable(p,"You are now pvp!",2);
send_reliable(0,"play_s pvpon.ogg",6);
send_reliable(0,""+p.nickname+" is now pvp!",2);
}
}
else if(maps[mi].pvp==2 and maps[mi].pvpminx<=p.x and maps[mi].pvpmaxx>=p.x and maps[mi].pvpminy<=p.y and maps[mi].pvpmaxy>=p.y and maps[mi].pvpminz<=p.z and maps[mi].pvpmaxz>=p.z)
{
if(p.pvp!=0)
{
p.pvp=0;
send_reliable(p,"You are no longer pvp!",2);
send_reliable(0,"play_s pvpoff.ogg",6);
send_reliable(0,""+p.nickname+" is no longer pvp!",2);
}
}
send_reliable(0,"maps "+p.nickname+" is now visiting the public map "+maps[mi].name+", created by "+s2+" "+s+"",0);
p.finishchallengemaptimer.force(0);
}
}
else if(parsed[0]=="challengemapgo" and parsed.length()>1)
{
if(parsed[1]=="back")
{
p.sendpacket("canceled", 0);
return;
}
if(!map_exists(parsed[1]))
{
send_reliable(p,"this map does not exists",2);
return;
}
int mi=get_map_index(parsed[1]);
if((mi>-1))
{
if(TIME_HOUR<maps[mi].minhour or TIME_HOUR>maps[mi].maxhour)
{
send_reliable(p,""+maps[mi].name+" is currently closed. Opening hours: "+maps[mi].minhour+" until "+maps[mi].maxhour+"",2);
return;
}
if(p.level<maps[mi].minlevel or p.level>maps[mi].maxlevel)
{
send_reliable(p,""+maps[mi].name+" is only for players with level range of "+maps[mi].minlevel+" until "+maps[mi].maxlevel+"",2);
return;
}
if(p.reinforcement<maps[mi].minreinforcement or p.reinforcement>maps[mi].maxreinforcement)
{
send_reliable(p,""+maps[mi].name+" is only for players with reinforcement range of "+maps[mi].minreinforcement+" until "+maps[mi].maxreinforcement+"",2);
return;
}
int ind=get_player_index_from(p.looker);
if(ind>-1)
{
p.looker="";
send_reliable(players[ind],"lookstop",0);
players[ind].looking="";
int newx=string_to_number(get_char_val(players[ind].name,"oldx"));
int newy=string_to_number(get_char_val(players[ind].name,"oldy"));
int newz=string_to_number(get_char_val(players[ind].name,"oldz"));
string newmap=get_char_val(players[ind].name,"oldmap");
if(map_exists(newmap)==false)
newmap="main";
string charfolder="chars/"+players[ind].name;
file_delete(charfolder+"/oldx.usr");
file_delete(charfolder+"/oldy.usr");
file_delete(charfolder+"/oldz.usr");
file_delete(charfolder+"/oldmap.usr");
move_player(players[ind],newmap,newx,newy,newz);
send_packet(6,"play toggleoff.ogg "+p.x+" "+p.y+" "+p.z, p.x,p.y,p.z,maps[get_map_index(p.map)]);
send_reliable(players[ind],"you've stopped looking at "+p.name+"",2);
send_reliable(p,""+players[ind].name+" stopped watching you",2);
}
string s="";
string s2;
if(maps[mi].owners.length>1)
{
for(uint i=0; i<maps[mi].owners.length(); i++)
{
if(i==(maps[mi].owners.length-1)) s+="and "+maps[mi].owners[i]+".";
else s+=maps[mi].owners[i]+", ";
}
}
else
for(uint i=0; i<maps[mi].owners.length(); i++){
s=maps[mi].owners[i]+".";}
if(maps[mi].owners.length()>1) s2=" "+maps[mi].owners.length()+" owners: ";
else s2=" "+maps[mi].owners.length()+" owner: ";
move_player(p,parsed[1],random(maps[mi].spminx,maps[mi].spmaxx),random(maps[mi].spminy,maps[mi].spmaxy),random(maps[mi].spminz,maps[mi].spmaxz),true);
if(maps[mi].pvp==1 and maps[mi].pvpminx<=p.x and maps[mi].pvpmaxx>=p.x and maps[mi].pvpminy<=p.y and maps[mi].pvpmaxy>=p.y and maps[mi].pvpminz<=p.z and maps[mi].pvpmaxz>=p.z)
{
if(p.pvp!=1)
{
p.pvp=1;
send_reliable(p,"You are now pvp!",2);
send_reliable(0,"play_s pvpon.ogg",6);
send_reliable(0,""+p.nickname+" is now pvp!",2);
}
}
else if(maps[mi].pvp==2 and maps[mi].pvpminx<=p.x and maps[mi].pvpmaxx>=p.x and maps[mi].pvpminy<=p.y and maps[mi].pvpmaxy>=p.y and maps[mi].pvpminz<=p.z and maps[mi].pvpmaxz>=p.z)
{
if(p.pvp!=0)
{
p.pvp=0;
send_reliable(p,"You are no longer pvp!",2);
send_reliable(0,"play_s pvpoff.ogg",6);
send_reliable(0,""+p.nickname+" is no longer pvp!",2);
}
}
send_reliable(0,"maps "+p.nickname+" is now trying the challenge map "+maps[mi].name+". Reward: "+maps[mi].finishamount+" "+maps[mi].finishitem+". Created by "+s2+" "+s+"",0);
p.finishchallengemaptimer.force(0);
}
}
else if(parsed[0]=="mapgo" and parsed.length()>1)
{
if(parsed[1]=="back")
{
p.sendpacket("canceled", 0);
return;
}
if(!map_exists(parsed[1]))
{
send_reliable(p,"this map does not exists",2);
return;
}
string[] a=string_split(file_get_contents("pbmaps.svr"),"\r\n",false);
int something=a.find(parsed[1]);
if(something>-1)
{
send_reliable(p,"you can only go to this map from the public maps menu!",2);
return;
}
string[] a2=string_split(file_get_contents("chmaps.svr"),"\r\n",false);
int something2=a2.find(parsed[1]);
if(something2>-1)
{
send_reliable(p,"you can only go to this map from the challenge maps menu!",2);
return;
}
int mi=get_map_index(parsed[1]);
if((mi>-1))
{
int ind=get_player_index_from(p.looker);
if(ind>-1)
{
p.looker="";
send_reliable(players[ind],"lookstop",0);
players[ind].looking="";
int newx=string_to_number(get_char_val(players[ind].name,"oldx"));
int newy=string_to_number(get_char_val(players[ind].name,"oldy"));
int newz=string_to_number(get_char_val(players[ind].name,"oldz"));
string newmap=get_char_val(players[ind].name,"oldmap");
if(map_exists(newmap)==false)
newmap="main";
string charfolder="chars/"+players[ind].name;
file_delete(charfolder+"/oldx.usr");
file_delete(charfolder+"/oldy.usr");
file_delete(charfolder+"/oldz.usr");
file_delete(charfolder+"/oldmap.usr");
move_player(players[ind],newmap,newx,newy,newz);
send_packet(6,"play toggleoff.ogg "+p.x+" "+p.y+" "+p.z, p.x,p.y,p.z,maps[get_map_index(p.map)]);
send_reliable(players[ind],"you've stopped looking at "+p.name+"",2);
send_reliable(p,""+players[ind].name+" stopped watching you",2);
}
move_player(p,parsed[1],random(maps[mi].spminx,maps[mi].spmaxx),random(maps[mi].spminy,maps[mi].spmaxy),random(maps[mi].spminz,maps[mi].spmaxz),true);
if(maps[mi].pvp==1 and maps[mi].pvpminx<=p.x and maps[mi].pvpmaxx>=p.x and maps[mi].pvpminy<=p.y and maps[mi].pvpmaxy>=p.y and maps[mi].pvpminz<=p.z and maps[mi].pvpmaxz>=p.z)
{
if(p.pvp!=1)
{
p.pvp=1;
send_reliable(p,"You are now pvp!",2);
send_reliable(0,"play_s pvpon.ogg",6);
send_reliable(0,""+p.nickname+" is now pvp!",2);
}
}
else if(maps[mi].pvp==2 and maps[mi].pvpminx<=p.x and maps[mi].pvpmaxx>=p.x and maps[mi].pvpminy<=p.y and maps[mi].pvpmaxy>=p.y and maps[mi].pvpminz<=p.z and maps[mi].pvpmaxz>=p.z)
{
if(p.pvp!=0)
{
p.pvp=0;
send_reliable(p,"You are no longer pvp!",2);
send_reliable(0,"play_s pvpoff.ogg",6);
send_reliable(0,""+p.nickname+" is no longer pvp!",2);
}
}
p.finishchallengemaptimer.force(0);
}
}
else if(parsed[0]=="fists")
{
if(parsed[0]!=p.weapon_name)
{
p.weapon_name=parsed[0];
if(p.weapon_ammos>0)
p.inv_add_item(p.weapon_ammo_type, p.weapon_ammos);
p.firetimer=180;
p.weapon_ammos=0;
p.weapon_ammo_type="";
p.weapon_copasity=0;
send_reliable(p, "notrapid", 0);
}
}
else if(parsed[0]=="feet")
{
if(parsed[0]!=p.weapon_name)
{
p.weapon_name=parsed[0];
if(p.weapon_ammos>0)
p.inv_add_item(p.weapon_ammo_type, p.weapon_ammos);
p.firetimer=220;
p.weapon_ammos=0;
p.weapon_ammo_type="";
p.weapon_copasity=0;
send_reliable(p, "notrapid", 0);
}
}
else if(parsed[0]=="splay")
{
send_packet(6,"play draw"+get_draw_and_get_sound(parsed[2])+".ogg "+p.x+" "+p.y+" "+p.z, p.x,p.y,p.z,maps[get_map_index(p.map)]);
}
else if(parsed[0]=="lcm" and parsed.length()>1)
{
if(p.ds.find("chat")>-1)
{
send_reliable(p,"your chats have been disabled",0);
return;
}
if(p.away==true and string_replace(get_event_message(),parsed[0]+" ","",true)!="/afk" and !p.is_admin()==false)
{
send_reliable(p,"You can't chat while you are away",2);
return;
}
if(chatting==0)
{
string message;
message="Sorry, server chats are currently disabled.";
if(p.is_admin()) message+=" If you want to turn them back on, type /varset chatting 1";
send_reliable(p,message,2);
return;
}
p.chats+=1;
log(p.name+"_chats","local chat from "+p.name+": "+string_replace(get_event_message(),parsed[0]+" ","",true),true,true);
string mensagem;
if(p.title!="") mensagem+=p.title+" ";
if(p.teamname!="") mensagem+=p.teamname+" ";
if(p.awaytitle!="") mensagem+=p.awaytitle+" ";
if(p.prisontitle!="") mensagem+=p.prisontitle+" ";
if(p.newbtitle!="") mensagem+=p.newbtitle+" ";
if(p.afktitle!="") mensagem+=p.afktitle+" ";
if(p.pvptitle!="") mensagem+=p.pvptitle+" ";
if(p.jobtitle!="") mensagem+=p.jobtitle+" ";
mensagem+=""+p.ptitle+" "+p.nickname+" said in the lcm chat: "+string_replace(get_event_message(), parsed[0]+" ", "", false);
for(uint i=0;i<players.length();i++)
{
if(players[i].is_lcm())
{
send_reliable(players[i], "play_s notify_google1.ogg", 6);
send_reliable(players[i], "lcmchat "+mensagem, 0);
}
}
}
else if(parsed[0]=="adm" and parsed.length()>1)
{
if(p.ds.find("chat")>-1)
{
send_reliable(p,"your chats have been disabled",0);
return;
}
if(p.away==true and string_replace(get_event_message(),parsed[0]+" ","",true)!="/afk" and !p.is_admin()==false)
{
send_reliable(p,"You can't chat while you are away",2);
return;
}
if(chatting==0)
{
string message;
message="Sorry, server chats are currently disabled.";
if(p.is_admin()) message+=" If you want to turn them back on, type /varset chatting 1";
send_reliable(p,message,2);
return;
}
p.chats+=1;
log(p.name+"_chats","local chat from "+p.name+": "+string_replace(get_event_message(),parsed[0]+" ","",true),true,true);
string mensagem;
if(p.title!="") mensagem+=p.title+" ";
if(p.teamname!="") mensagem+=p.teamname+" ";
if(p.awaytitle!="") mensagem+=p.awaytitle+" ";
if(p.prisontitle!="") mensagem+=p.prisontitle+" ";
if(p.newbtitle!="") mensagem+=p.newbtitle+" ";
if(p.afktitle!="") mensagem+=p.afktitle+" ";
if(p.pvptitle!="") mensagem+=p.pvptitle+" ";
if(p.jobtitle!="") mensagem+=p.jobtitle+" ";
mensagem+=""+p.ptitle+" "+p.nickname+" said in the admin chat: "+string_replace(get_event_message(), parsed[0]+" ", "", false);
for(uint i=0;i<players.length();i++)
{
if(players[i].is_admin())
{
send_reliable(players[i], "play_s notifybleep.ogg", 6);
send_reliable(players[i], "adminchat "+mensagem, 0);
}
}
}
else if(parsed[0]=="manager" and parsed.length()>1)
{
if(p.ds.find("chat")>-1)
{
send_reliable(p,"your chats have been disabled",0);
return;
}
if(p.away==true and string_replace(get_event_message(),parsed[0]+" ","",true)!="/afk" and !p.is_admin()==false)
{
send_reliable(p,"You can't chat while you are away",2);
return;
}
if(chatting==0)
{
string message;
message="Sorry, server chats are currently disabled.";
if(p.is_admin()) message+=" If you want to turn them back on, type /varset chatting 1";
send_reliable(p,message,2);
return;
}
p.chats+=1;
log(p.name+"_chats","local chat from "+p.name+": "+string_replace(get_event_message(),parsed[0]+" ","",true),true,true);
string mensagem;
if(p.title!="") mensagem+=p.title+" ";
if(p.teamname!="") mensagem+=p.teamname+" ";
if(p.awaytitle!="") mensagem+=p.awaytitle+" ";
if(p.prisontitle!="") mensagem+=p.prisontitle+" ";
if(p.newbtitle!="") mensagem+=p.newbtitle+" ";
if(p.afktitle!="") mensagem+=p.afktitle+" ";
if(p.pvptitle!="") mensagem+=p.pvptitle+" ";
if(p.jobtitle!="") mensagem+=p.jobtitle+" ";
mensagem+=""+p.ptitle+" "+p.nickname+" said in the manager chat: "+string_replace(get_event_message(), parsed[0]+" ", "", false);
for(uint i=0;i<players.length();i++)
{
if(players[i].is_manager())
{
send_reliable(players[i], "play_s notify7.ogg", 6);
send_reliable(players[i], "managerchat "+mensagem, 0);
}
}
}
else if(parsed[0]=="partnerchat")
{
if(p.partner!="" and p.ex_partner=="")
{
send_reliable(p,"ispartnerchat",0);
}
}
else if(parsed[0]=="partnerchat2" and parsed.length()>1)
{
if(p.ds.find("chat")>-1)
{
send_reliable(p,"your chats have been disabled",0);
return;
}
if(p.away==true and string_replace(get_event_message(),parsed[0]+" ","",true)!="/afk" and !p.is_admin()==false)
{
send_reliable(p,"You can't chat while you are away",2);
return;
}
if(chatting==0)
{
string message;
message="Sorry, server chats are currently disabled.";
if(p.is_admin()) message+=" If you want to turn them back on, type /varset chatting 1";
send_reliable(p,message,2);
return;
}
p.chats+=1;
log(p.name+"_chats","local chat from "+p.name+": "+string_replace(get_event_message(),parsed[0]+" ","",true),true,true);
string mensagem;
if(p.title!="") mensagem+=p.title+" ";
if(p.teamname!="") mensagem+=p.teamname+" ";
if(p.awaytitle!="") mensagem+=p.awaytitle+" ";
if(p.prisontitle!="") mensagem+=p.prisontitle+" ";
if(p.newbtitle!="") mensagem+=p.newbtitle+" ";
if(p.afktitle!="") mensagem+=p.afktitle+" ";
if(p.pvptitle!="") mensagem+=p.pvptitle+" ";
if(p.jobtitle!="") mensagem+=p.jobtitle+" ";
mensagem=""+p.ptitle+" "+p.nickname+" said in the partner chat: "+string_replace(get_event_message(), parsed[0]+" ", "", false);
int ind=get_player_index_from(p.partner);
if(ind>-1)
{
send_reliable(p, "play_s notify_google2.ogg", 6);
send_reliable(p, "partnerchat "+mensagem, 0);
send_reliable(players[ind], "play_s notify_google2.ogg", 6);
send_reliable(players[ind], "partnerchat "+mensagem, 0);
}
}
else if(parsed[0]=="voice" and parsed.length()>2)
{
send_packet(0,get_event_message(), p.x,p.y,p.z,maps[get_map_index(p.map)]);
}
else if(parsed[0]=="getmapnames")
{
string[] mapnames=find_files("maps/*");
string output;
for(uint i=0; i<mapnames.length(); i++)
{
output+=mapnames[i]+" ";
}
send_reliable(p,"mapnamesare "+output,0);
}
else if(parsed[0]=="getmap")
{
f.open("maps/"+parsed[1],"rb");
send_reliable(p,"mapcontents "+f.read(),0);
f.close();
}
else if(parsed[0]=="lchannel")
{
server_menu menu;
menu.intro="Select a new language channel";
menu.initial_packet="lchannelset";
for(uint i=0; i<language_channels.length(); i+=1)
{
menu.add(language_channels[i],language_channels[i]);
}
menu.add("password protected channels","ppc");
menu.send(e.peer_id);
}
else if(parsed[0]=="lchannelset" and parsed.length()>1)
{
if(parsed[1]=="back")
{
p.sendpacket("canceled", 0);
return;
}
if(parsed[1]=="ppc")
{
file f;
f.open("password_protected_language_channels.svr","rb");
string[] lines=string_split(f.read(),"\r\n",false);
f.close();
if(lines.length()<1)
{
send_reliable(p,"error",2);
return;
}
server_menu2 menu;
menu.intro="Select a new password protected language channel";
menu.initial_packet="ppchannels";
for(uint i=0; i<lines.length(); i++)
{
string[] ld=string_split(lines[i],":",false);
menu.add(ld[0],ld[0]);
}
menu.send(e.peer_id);
}
else if(parsed[1]=="disable_chat")
{
p.langchan=parsed[1];
p.sendpacket("done",0);
}
else
{
for(uint i=0; i<players.length(); i+=1)
{
if(players[i].langchan==p.langchan and players[i].name!=p.name)
{
send_reliable(players[i],"channelexit "+p.name+" went out of this channel",0);
}
}
p.langchan=parsed[1];
p.sendpacket("Using "+p.langchan+" as the new language channel",0);
for(uint i=0; i<players.length(); i+=1)
{
if(players[i].langchan==p.langchan and players[i].name!=p.name)
{
send_reliable(players[i],"channelenter "+p.name+" entered this channel",0);
}
}
}
}
else if(parsed[0]=="ppchannels" and parsed.length()>1)
{
if(parsed[1]=="back")
{
p.sendpacket("canceled", 0);
return;
}
send_serverbox(p.peer_id,0,-1,-1,-1,"channelpass/"+parsed[1],"Enter password");
}
else if(string_left(parsed[0],12)=="channelpass/" and parsed.length>1)
{
if(parsed[1]=="[cncel]") return;
file f;
f.open("password_protected_language_channels.svr","rb");
string[] lines=string_split(f.read(),"\r\n",false);
f.close();
if(lines.length()<1)
{
send_reliable(p,"error",2);
return;
}
string pass=parsed[1];
parsed=string_split(parsed[0],"/",false);
for(uint i=0; i<lines.length(); i++)
{
if(parsed[1]+":"+pass==lines[i])
{
for(uint i=0; i<players.length(); i+=1)
{
if(players[i].langchan==p.langchan and players[i].name!=p.name)
{
send_reliable(players[i],"channelexit "+p.name+" went out of this channel",0);
}
}
string[] ld=string_split(lines[i],":",false);
p.langchan=ld[0];
p.sendpacket("done",0);
for(uint i=0; i<players.length(); i+=1)
{
if(players[i].langchan==p.langchan and players[i].name!=p.name)
{
send_reliable(players[i],"channelenter "+p.name+" entered this channel",0);
}
}
}
}
}
else if(parsed[0]=="lchannelset2" and parsed.length()>1)
{
if(parsed[1]=="back")
{
p.sendpacket("canceled", 0);
if(p.smartphoneon==0)
{
send_reliable(p, "your phone is off", 0);
return;
}
server_menu m;
m.intro="one UI home";
m.initial_packet="smartphoneenter";
if(p.langchan=="" or p.age==0 or p.country=="" or p.day==0 or p.month==0 or p.year==0) m.add("complete your profile","yourprofile");
else
{
m.add("check battery level","charge");
m.add("phone","phone");
m.add("messages","msg");
m.add("apps","apps");
m.add("properties menu","properties");
}
m.send(p.peer_id);
}
else if(parsed[1]=="ppc")
{
file f;
f.open("password_protected_language_channels.svr","rb");
string[] lines=string_split(f.read(),"\r\n",false);
f.close();
if(lines.length()<1)
{
send_reliable(p,"error",2);
return;
}
server_menu menu;
menu.intro="Select a new password protected language channel";
menu.initial_packet="ppchannels2";
for(uint i=0; i<lines.length(); i++)
{
string[] ld=string_split(lines[i],":",false);
menu.add(ld[0],ld[0]);
}
menu.send(e.peer_id);
}
else
{
p.langchan=parsed[1];
p.sendpacket("Using "+p.langchan+" as the new language channel",0);
if(p.smartphoneon==0)
{
send_reliable(p, "your phone is off", 0);
return;
}
server_menu m;
m.intro="one UI home";
m.initial_packet="smartphoneenter";
if(p.langchan=="" or p.age==0 or p.country=="" or p.day==0 or p.month==0 or p.year==0) m.add("complete your profile","yourprofile");
else
{
m.add("check battery level","charge");
m.add("phone","phone");
m.add("messages","msg");
m.add("apps","apps");
m.add("properties menu","properties");
}
m.send(p.peer_id);
}
}
else if(parsed[0]=="ppchannels" and parsed.length()>1)
{
if(parsed[1]=="back")
{
p.sendpacket("canceled", 0);
return;
}
send_serverbox(p.peer_id,2,-1,-1,-1,"channelpass","Enter password");
}
else if(parsed[0]=="channelpass" and parsed.length>1)
{
if(parsed[1]=="[cncel]")
{
send_reliable(p,"canceled",2);
if(p.smartphoneon==0)
{
send_reliable(p, "your phone is off", 0);
return;
}
server_menu m;
m.intro="one UI home";
m.initial_packet="smartphoneenter";
if(p.langchan=="" or p.age==0 or p.country=="" or p.day==0 or p.month==0 or p.year==0) m.add("complete your profile","yourprofile");
else
{
m.add("check battery level","charge");
m.add("phone","phone");
m.add("messages","msg");
m.add("apps","apps");
m.add("properties menu","properties");
}
m.send(p.peer_id);
}
else
{
string pass=parsed[1];
file f;
f.open("password_protected_language_channels.svr","rb");
string[] lines=string_split(f.read(),"\r\n",false);
f.close();
if(lines.length()<1)
{
send_reliable(p,"error",2);
return;
}
for(uint i=0; i<lines.length(); i++)
{
string[] ld=string_split(lines[i],":",false);
int something=ld.find(pass);
if(something>-1)
{
p.langchan=ld[0];
p.sendpacket("done",0);
if(p.smartphoneon==0)
{
send_reliable(p, "your phone is off", 0);
return;
}
server_menu m;
m.intro="one UI home";
m.initial_packet="smartphoneenter";
if(p.langchan=="" or p.age==0 or p.country=="" or p.day==0 or p.month==0 or p.year==0) m.add("complete your profile","yourprofile");
else
{
m.add("check battery level","charge");
m.add("phone","phone");
m.add("messages","msg");
m.add("apps","apps");
m.add("properties menu","properties");
}
m.send(p.peer_id);
}
}
}
}
else if(parsed[0]=="ageset" and parsed.length()>1)
{
if(parsed[1]=="back")
{
p.sendpacket("canceled", 0);
if(p.smartphoneon==0)
{
send_reliable(p, "your phone is off", 0);
return;
}
server_menu m;
m.intro="one UI home";
m.initial_packet="smartphoneenter";
if(p.langchan=="" or p.age==0 or p.country=="" or p.day==0 or p.month==0 or p.year==0) m.add("complete your profile","yourprofile");
else
{
m.add("check battery level","charge");
m.add("phone","phone");
m.add("messages","msg");
m.add("apps","apps");
m.add("properties menu","properties");
}
m.send(p.peer_id);
}
else
{
p.age=string_to_number(parsed[1]);
p.sendpacket("You are "+p.age+" years old!",0);
if(p.smartphoneon==0)
{
send_reliable(p, "your phone is off", 0);
return;
}
server_menu m;
m.intro="one UI home";
m.initial_packet="smartphoneenter";
if(p.langchan=="" or p.age==0 or p.country=="" or p.day==0 or p.month==0 or p.year==0) m.add("complete your profile","yourprofile");
else
{
m.add("check battery level","charge");
m.add("phone","phone");
m.add("messages","msg");
m.add("apps","apps");
m.add("properties menu","properties");
}
m.send(p.peer_id);
}
}
else if(parsed[0]=="dayset" and parsed.length()>1)
{
if(parsed[1]=="back")
{
p.sendpacket("canceled", 0);
if(p.smartphoneon==0)
{
send_reliable(p, "your phone is off", 0);
return;
}
server_menu m;
m.intro="one UI home";
m.initial_packet="smartphoneenter";
if(p.langchan=="" or p.age==0 or p.country=="" or p.day==0 or p.month==0 or p.year==0) m.add("complete your profile","yourprofile");
else
{
m.add("check battery level","charge");
m.add("phone","phone");
m.add("messages","msg");
m.add("apps","apps");
m.add("properties menu","properties");
}
m.send(p.peer_id);
}
else
{
p.day=string_to_number(parsed[1]);
p.sendpacket("done, go and set your month of birth now",0);
if(p.smartphoneon==0)
{
send_reliable(p, "your phone is off", 0);
return;
}
server_menu m;
m.intro="one UI home";
m.initial_packet="smartphoneenter";
if(p.langchan=="" or p.age==0 or p.country=="" or p.day==0 or p.month==0 or p.year==0) m.add("complete your profile","yourprofile");
else
{
m.add("check battery level","charge");
m.add("phone","phone");
m.add("messages","msg");
m.add("apps","apps");
m.add("properties menu","properties");
}
m.send(p.peer_id);
}
}
else if(parsed[0]=="monthset" and parsed.length()>1)
{
if(parsed[1]=="back")
{
p.sendpacket("canceled", 0);
if(p.smartphoneon==0)
{
send_reliable(p, "your phone is off", 0);
return;
}
server_menu m;
m.intro="one UI home";
m.initial_packet="smartphoneenter";
if(p.langchan=="" or p.age==0 or p.country=="" or p.day==0 or p.month==0 or p.year==0) m.add("complete your profile","yourprofile");
else
{
m.add("check battery level","charge");
m.add("phone","phone");
m.add("messages","msg");
m.add("apps","apps");
m.add("properties menu","properties");
}
m.send(p.peer_id);
}
else
{
p.month=string_to_number(parsed[1]);
p.sendpacket("done, go and set your year of birth now",0);
if(p.smartphoneon==0)
{
send_reliable(p, "your phone is off", 0);
return;
}
server_menu m;
m.intro="one UI home";
m.initial_packet="smartphoneenter";
if(p.langchan=="" or p.age==0 or p.country=="" or p.day==0 or p.month==0 or p.year==0) m.add("complete your profile","yourprofile");
else
{
m.add("check battery level","charge");
m.add("phone","phone");
m.add("messages","msg");
m.add("apps","apps");
m.add("properties menu","properties");
}
m.send(p.peer_id);
}
}
else if(parsed[0]=="yearset" and parsed.length()>1)
{
if(parsed[1]=="back")
{
p.sendpacket("canceled", 0);
if(p.smartphoneon==0)
{
send_reliable(p, "your phone is off", 0);
return;
}
server_menu m;
m.intro="one UI home";
m.initial_packet="smartphoneenter";
if(p.langchan=="" or p.age==0 or p.country=="" or p.day==0 or p.month==0 or p.year==0) m.add("complete your profile","yourprofile");
else
{
m.add("check battery level","charge");
m.add("phone","phone");
m.add("messages","msg");
m.add("apps","apps");
m.add("properties menu","properties");
}
m.send(p.peer_id);
}
else
{
p.year=string_to_number(parsed[1]);
p.sendpacket("You are borned on "+p.year+"!",0);
if(p.smartphoneon==0)
{
send_reliable(p, "your phone is off", 0);
return;
}
server_menu m;
m.intro="one UI home";
m.initial_packet="smartphoneenter";
if(p.langchan=="" or p.age==0 or p.country=="" or p.day==0 or p.month==0 or p.year==0) m.add("complete your profile","yourprofile");
else
{
m.add("check battery level","charge");
m.add("phone","phone");
m.add("messages","msg");
m.add("apps","apps");
m.add("properties menu","properties");
}
m.send(p.peer_id);
}
}
else if(parsed[0]=="countryset" and parsed.length()>1)
{
if(parsed[1]=="back")
{
p.sendpacket("canceled", 0);
if(p.smartphoneon==0)
{
send_reliable(p, "your phone is off", 0);
return;
}
server_menu m;
m.intro="one UI home";
m.initial_packet="smartphoneenter";
if(p.langchan=="" or p.age==0 or p.country=="" or p.day==0 or p.month==0 or p.year==0) m.add("complete your profile","yourprofile");
else
{
m.add("check battery level","charge");
m.add("phone","phone");
m.add("messages","msg");
m.add("apps","apps");
m.add("properties menu","properties");
}
m.send(p.peer_id);
}
else
{
p.country=parsed[1];
p.sendpacket("You are from "+p.country+"!",0);
if(p.smartphoneon==0)
{
send_reliable(p, "your phone is off", 0);
return;
}
server_menu m;
m.intro="one UI home";
m.initial_packet="smartphoneenter";
if(p.langchan=="" or p.age==0 or p.country=="" or p.day==0 or p.month==0 or p.year==0) m.add("complete your profile","yourprofile");
else
{
m.add("check battery level","charge");
m.add("phone","phone");
m.add("messages","msg");
m.add("apps","apps");
m.add("properties menu","properties");
}
m.send(p.peer_id);
}
}
else if(parsed[0]=="playermapmenu")
{
int x;
int y;
int z;
string finaltext="playermapmenu ";
int ind=get_player_index(e.peer_id);
string n="";
if(ind>-1)
{
n=players[ind].name;
x=players[ind].x;
y=players[ind].y;
z=players[ind].z;
string[] playernames=nearest_player_sorted_array(players[ind]);
finaltext+=linear(playernames);
if(finaltext=="playermapmenu ")
{
finaltext="Just you are in this map";
}
send_reliable(p, finaltext, 0);
}
}
else if(parsed[0]=="playermenu")
{
int x;
int y;
int z;
string finaltext="playermenu ";
int ind=get_player_index(e.peer_id);
string n="";
if(ind>-1)
{
n=players[ind].name;
x=players[ind].x;
y=players[ind].y;
z=players[ind].z;
string[] playernames=nearest_player_sorted_arrayto(players[ind]);
finaltext+=linear(playernames);
send_reliable(p, finaltext, 0);
}
}
else if(parsed[0]=="copy")
{
string text=string_replace(get_event_message(), "copy ", "", false);
if(text=="" or text=="back")
{
send_reliable(p,"canceled",0);
return;
}
p.sendpacket("copyed to clipboard",0);
send_reliable(p, "clip "+text, 0);
}
else if(parsed[0]=="createAI" and parsed.length>1)
{
string[] colon=string_split(parsed[1],":",false);
if(file_exists("ais/"+colon[0]+".ai")==true)
{
send_reliable(p,"this name already exists",2);
return;
}
file f;
f.open("ais/"+colon[0]+".ai","wb");
f.write("name="+colon[0]+"\r\nnickname="+colon[1]+"\r\nhealth="+colon[2]+"\r\nrange="+colon[3]+"\r\ndamage="+colon[4]+"\r\nshoottime="+colon[5]+"\r\nspeed="+colon[6]+"\r\nxp="+colon[7]+"\r\nstepsound="+colon[8]+"\r\nstepsoundpitch="+colon[9]+"\r\nstepsoundvolume="+colon[10]+"\r\npainsound="+colon[11]+"\r\npainsoundpitch="+colon[12]+"\r\npainsoundvolume="+colon[13]+"\r\nkillsound="+colon[14]+"\r\nkillsoundpitch="+colon[15]+"\r\nkillsoundvolume="+colon[16]+"\r\nshootsound="+colon[17]+"\r\nshootsoundpitch="+colon[18]+"\r\nshootsoundvolume="+colon[19]+"\r\nhitsound="+colon[20]+"\r\nhitsoundpitch="+colon[21]+"\r\nhitsoundvolume="+colon[22]+"\r\nvoice="+colon[23]+"\r\nvoicepitch="+colon[24]+"\r\nvoicevolume="+colon[25]+"\r\nvoicetime="+colon[26]+"\r\nitem="+colon[27]+"\r\namount="+colon[28]+"\r\nrapidvoice="+colon[29]+"\r\ntreeclimb="+colon[30]+"\r\nmaddable="+colon[31]+"\r\nneedwater="+colon[32]+"\r\nfall="+colon[33]+"\r\nfallsoundpitch="+colon[34]+"\r\nfallsoundvolume="+colon[35]+"\r\nnuclearbomb="+colon[36]+"\r\nmine="+colon[37]+"\r\ndescription="+colon[38]+"");
f.close();
for(uint i2=0;i2<ais.length();i2++)
{
if (ais[i2].voice!="" and ais[i2].rapidvoice==true) destroy_moving_sound(ais[i2].voice);
ais.remove_at(i2);
continue;
}
load_ais();
send_reliable(p,"done",2);
}
else if(parsed[0]=="createfad" and parsed.length>1)
{
string[] colon=string_split(parsed[1],":",false);
if(file_exists("foods_and_drinks/"+colon[0]+".fad")==true)
{
send_reliable(p,"this name already exists",2);
return;
}
file f;
f.open("foods_and_drinks/"+colon[0]+".fad","wb");
f.write(""+colon[1]+":"+colon[2]+":"+colon[3]+":"+colon[4]+":"+colon[5]+"");
f.close();
send_reliable(p,"done",2);
}
else if(parsed[0]=="createdrawsounds" and parsed.length>1)
{
string[] colon=string_split(parsed[1],"=",false);
file_put_contents("drawsounds.svr",""+colon[0]+"="+colon[1]+"\r\n",255);
send_reliable(p,"done",2);
}
else if(parsed[0]=="createitemusagelimit" and parsed.length>1)
{
file_put_contents("notadg.svr",""+parsed[1]+"\r\n",255);
send_reliable(p,"done",2);
}
else if(parsed[0]=="buildobj" and parsed.length>1)
{
int mapindex=get_map_index(p.map);
if(mapindex>-1)
{
for(uint i=0; i<maps[mapindex].owners.length(); i++)
{
if(maps[mapindex].owners.find(p.name)>-1 or maps[mapindex].owners.find(p.partner)>-1 or p.is_admin())
{
string what=parsed[1];
if(what=="tile")
{
send_reliable(p,"buildtile",0);
}
else if(what=="zone")
{
send_reliable(p,"buildzone",0);
}
else if(what=="safezone")
{
send_reliable(p,"buildsafezone",0);
}
else if(what=="bed")
{
send_reliable(p,"buildbed",0);
}
else if(what=="clock")
{
send_reliable(p,"buildclock",0);
}
else if(what=="calendar")
{
send_reliable(p,"buildcalendar",0);
}
else if(what=="oven")
{
send_reliable(p,"buildoven",0);
}
else if(what=="src")
{
send_reliable(p,"buildsrc",0);
}
else if(what=="music")
{
send_reliable(p,"buildmusic",0);
}
else if(what=="txt")
{
send_reliable(p,"buildtxt",0);
}
else if(what=="dialog")
{
send_reliable(p,"builddialog",0);
}
else if(what=="automatic_dialog")
{
send_reliable(p,"buildautomatic_dialog",0);
}
else if(what=="timedtext")
{
send_reliable(p,"buildtimedtext",0);
}
else if(what=="timedsound")
{
send_reliable(p,"buildtimedsound",0);
}
else if(what=="timedmusic")
{
send_reliable(p,"buildtimedmusic",0);
}
else if(what=="timedamb")
{
send_reliable(p,"buildtimedamb",0);
}
else if(what=="item")
{
send_reliable(p,"builditem",0);
}
else if(what=="item_usage_restriction")
{
send_reliable(p,"builditem_usage_restriction",0);
}
else if(what=="AI")
{
if(p.is_admin())
{
send_menu(p.peer_id,"ai menu","bAI","create AI:createAI[]edit AI:editAI[]remove AI:removeAI[]remove AI line:removeAIline[]spawn AI:spawnAI");
}
}
else if(what=="drawsounds")
{
if(p.is_admin())
{
send_menu(p.peer_id,"draw sounds menu","bdrawsounds","new draw sound:createdrawsound[]edit draw sound:editdrawsound[]remove draw sound:removedrawsoundline");
}
}
else if(what=="itemusagelimit")
{
if(p.is_admin())
{
send_menu(p.peer_id,"item usage limits menu","bitemusagelimit","new item usage limit:createitemusagelimit[]edit item usage limit:edititemusagelimit[]remove item usage limit:removeitemusagelimitline");
}
}
else if(what=="fad")
{
if(p.is_admin())
{
send_menu(p.peer_id,"foods and drinks menu","bfad","create food or drink:fad[]edit food or drink:editfad[]remove food or drink:removefad");
}
}
else if(what=="amb")
{
send_reliable(p,"buildamb",0);
}
else if(what=="newmap")
{
send_reliable(p,"buildnewmap",0);
}
else if(what=="deletemap")
{
string m="yes:yes[]no:no";
send_menu(p.peer_id,"are you sure you'd like to delete this map?","delmap",m);
}
else if(what=="sign")
{
send_reliable(p,"buildsign",0);
}
else if(what=="url")
{
send_reliable(p,"buildurl",0);
}
else if(what=="vanishing_platform")
{
send_reliable(p,"buildvanishing_platform",0);
}
else if(what=="hazard")
{
send_reliable(p,"buildhazard",0);
}
else if(what=="teleporter")
{
send_reliable(p,"buildteleporter",0);
}
else if(what=="forcefield")
{
send_reliable(p,"buildforcefield",0);
}
else if(what=="opening_hours")
{
send_reliable(p,"buildopening_hours",0);
}
else if(what=="level")
{
send_reliable(p,"buildlevel",0);
}
else if(what=="reinforcement")
{
send_reliable(p,"buildreinforcement",0);
}
else if(what=="door")
{
if(p.is_admin())
{
send_menu(p.peer_id,"Door menu","bdoor","door:door[]password protected door:pdoor[]item checker door:icdoor[]item taker door:itdoor[]item giver door:igdoor");
}
else
{
send_menu(p.peer_id,"Door menu","bdoor","door:door[]password protected door:pdoor[]item checker door:icdoor[]item taker door:itdoor");
}
}
else if(what=="automover")
{
if(p.is_admin())
{
send_menu(p.peer_id,"automover menu","bautomover","automover:automover[]password protected automover:pautomover[]item checker automover:icautomover[]item taker automover:itautomover[]item giver automover:igautomover");
}
else
{
send_menu(p.peer_id,"automover menu","bautomover","automover:automover[]password protected automover:pautomover[]item checker automover:icautomover[]item taker automover:itautomover");
}
}
else if(what=="travelpoint")
{
if(p.is_admin())
{
send_menu(p.peer_id,"travelpoint menu","btravelpoint","automatic_travelpoint:automatic_travelpoint[]password protected automatic_travelpoint:pautomatic_travelpoint[]item checker automatic_travelpoint:icautomatic_travelpoint[]item taker automatic_travelpoint:itautomatic_travelpoint[]item giver automatic_travelpoint:igautomatic_travelpoint[]travelpoint:travelpoint[]password protected travelpoint:ptravelpoint[]item checker travelpoint:ictravelpoint[]item taker travelpoint:ittravelpoint[]item giver travelpoint:igtravelpoint");
}
else
{
send_menu(p.peer_id,"automatic_travelpoint menu","btravelpoint","automatic_travelpoint:automatic_travelpoint[]password protected automatic_travelpoint:pautomatic_travelpoint[]item checker automatic_travelpoint:icautomatic_travelpoint[]item taker automatic_travelpoint:itautomatic_travelpoint[]travelpoint:travelpoint[]password protected travelpoint:ptravelpoint[]item checker travelpoint:ictravelpoint[]item taker travelpoint:ittravelpoint");
}
}
else if(what=="tf")
{
if(p.is_admin())
{
send_menu(p.peer_id,"togglable features menu","btf","enable 2dsupport:e2dsupport[]disable 2dsupport:d2dsupport[]enable coordinates:ecoordinates[]disable coordinates:dcoordinates[]camera options:cameraoptions[]enable jumping:ejump[]disable jumping:djump[]spyglass options:spyglassoptions[]enable local chat:elocalchat[]disable local chat:dlocalchat[]enable voice chat:evoicechat[]disable voice chat:dvoicechat[]enable tts chat:ettschat[]disable tts chat:dttschat[]enable tracking players:etracking[]disable tracking players:dtracking[]enable disaster spawning:edisasters[]disable disaster spawning:ddisasters[]disable rain:drain[]disable wind:dwind[]disable night sounds:dnight");
}
else
{
send_menu(p.peer_id,"togglable features menu","btf","enable 2dsupport:e2dsupport[]disable 2dsupport:d2dsupport[]enable coordinates:ecoordinates[]disable coordinates:dcoordinates[]camera options:cameraoptions[]enable jumping:ejump[]disable jumping:djump[]spyglass options:spyglassoptions[]enable local chat:elocalchat[]disable local chat:dlocalchat[]enable voice chat:evoicechat[]disable voice chat:dvoicechat[]enable tts chat:ettschat[]disable tts chat:dttschat[]enable tracking players:etracking[]disable tracking players:dtracking[]disable rain:drain[]disable wind:dwind[]disable night sounds:dnight");
}
}
else if(what=="fishingcoordinate")
{
send_reliable(p,"buildfishing_coordinate",0);
}
else if(what=="vending_machine")
{
send_reliable(p,"buildvending_machine",0);
}
else if(what=="checkpoint")
{
send_reliable(p,"buildcheckpoint",0);
}
else if(what=="washbasin")
{
send_reliable(p,"buildwashbasin",0);
}
else if(what=="firemap")
{
send_reliable(p,"buildfiremap",0);
}
else if(what=="challenge_status")
{
send_reliable(p,"buildchallenge_status",0);
}
else if(what=="shower")
{
send_reliable(p,"buildshower",0);
}
else if(what=="toilet")
{
send_reliable(p,"buildtoilet",0);
}
else if(what=="trashcan")
{
send_reliable(p,"buildtrashcan",0);
}
else if(what=="starting_point")
{
send_reliable(p,"buildstarting_point",0);
}
else if(what=="deathpoint")
{
send_reliable(p,"builddeathpoint",0);
}
else if(what=="gmd")
{
send_reliable(p,"buildgmd",0);
}
else if(what=="public")
{
f.open("pbmaps.svr","rb");
string mdata=f.read();
f.close();
string[] mapdata=string_split(mdata, "\r\n",false);
int something=mapdata.find(p.map);
if(something>-1)
{
send_reliable(p,"error: you can't public you're already published map",2);
return;
}
else
{
file_put_contents("pbmaps.svr",""+p.map+"\r\n",255);
send_reliable(p,"Your map has been published!",2);
int mi=get_map_index(p.map);
if((mi>-1))
{
string s="";
string s2;
if(maps[mi].owners.length>1)
{
for(uint i=0; i<maps[mi].owners.length(); i++)
{
if(i==(maps[mi].owners.length-1)) s+="and "+maps[mi].owners[i]+".";
else s+=maps[mi].owners[i]+", ";
}
}
else
for(uint i=0; i<maps[mi].owners.length(); i++){
s=maps[mi].owners[i]+".";}
if(maps[mi].owners.length()>1) s2=" "+maps[mi].owners.length()+" owners: ";
else s2=" "+maps[mi].owners.length()+" owner: ";
send_reliable(0,""+p.name+"'s "+maps[mi].name+" map has been added to the public maps! "+s2+" "+s+". You can visit it from the safezone menu that is located in the safe zone map",2);
}
return;
}
}
else if(what=="private")
{
f.open("pbmaps.svr","rb");
string mdata=f.read();
f.close();
string[] mapdata=string_split(mdata, "\r\n",false);
int something=mapdata.find(p.map);
if(something>-1)
{
f.open("maps/"+p.map+".map","rb");
string[] lines=string_split(f.read(),"\r\n",false);
f.close();
for(uint i=0; i<lines.length(); i++)
{
string[] ld=string_split(lines[i],":",false);
if(ld[0]=="ai" and p.is_admin()==false)
{
send_reliable(p,"you can't make this map private",2);
return;
}
else if(ld[0]=="item" and p.is_admin()==false)
{
send_reliable(p,"you can't make this map private",2);
return;
}
else if(ld[0]=="challenge_status" and p.is_admin()==false)
{
send_reliable(p,"you can't make this map private",2);
return;
}
else if(ld[0]=="vending_machine" and p.is_admin()==false)
{
send_reliable(p,"you can't make this map private",2);
return;
}
else if(ld[0]=="fishing_coordinate" and p.is_admin()==false)
{
send_reliable(p,"you can't make this map private",2);
return;
}
}
mapdata.remove_at(something);
file_put_contents("pbmaps.svr", linear(mapdata),250);
send_reliable(p,"your map is now private",2);
send_reliable(0,""+p.name+"'s "+p.map+" map is now private",2);
return;
}
else
{
send_reliable(p,"This map is already private",2);
return;
}
}
else if(what=="challenge")
{
f.open("chmaps.svr","rb");
string mdata=f.read();
f.close();
string[] mapdata=string_split(mdata, "\r\n",false);
int something=mapdata.find(p.map);
if(something>-1)
{
send_reliable(p,"error: you can't put you're already added map to the challenge maps",2);
return;
}
else
{
file_put_contents("chmaps.svr",""+p.map+"\r\n",255);
send_reliable(p,""+p.map+" has been added to the challenge maps!",2);
int mi=get_map_index(p.map);
if((mi>-1))
{
string s="";
string s2;
if(maps[mi].owners.length>1)
{
for(uint i=0; i<maps[mi].owners.length(); i++)
{
if(i==(maps[mi].owners.length-1)) s+="and "+maps[mi].owners[i]+".";
else s+=maps[mi].owners[i]+", ";
}
}
else
for(uint i=0; i<maps[mi].owners.length(); i++){
s=maps[mi].owners[i]+".";}
if(maps[mi].owners.length()>1) s2=" "+maps[mi].owners.length()+" owners: ";
else s2=" "+maps[mi].owners.length()+" owner: ";
send_reliable(0,""+maps[mi].name+" map has been added to the challenge maps! Reward: "+maps[mi].finishamount+" "+maps[mi].finishitem+": "+s2+" "+s+". You can visit it from the safezone menu that is located in the safe zone map",2);
}
return;
}
}
else if(what=="notchallenge")
{
f.open("chmaps.svr","rb");
string mdata=f.read();
f.close();
string[] mapdata=string_split(mdata, "\r\n",false);
int something=mapdata.find(p.map);
if(something>-1)
{
mapdata.remove_at(something);
file_put_contents("chmaps.svr", linear(mapdata),250);
send_reliable(p,""+p.map+" has been removed from the challenge maps",2);
send_reliable(0,""+p.map+" map is not in challenge maps from now on",2);
return;
}
else
{
send_reliable(p,"This map is not in challenge maps",2);
return;
}
}
else if(what=="litem")
{
send_reliable(p,"buildlitem",0);
}
else if(what=="safe_card")
{
send_reliable(p,"buildsafe_card",0);
}
else if(what=="description")
{
send_reliable(p,"builddescription",0);
}
else if(what=="pvp")
{
send_reliable(p,"buildpvp",0);
}
else if(what=="owner")
{
send_reliable(p,"buildowner",0);
}
else if(what=="backupmap")
{
string maptext=get_map_text(maps[get_map_index(p.map)]);
send_reliable(p,"buildwritemap "+p.map+" "+maptext,0);
}
else if(what=="restorebackup")
{
f.open("maps/"+p.map+".map","rb");
string[] lines=string_split(f.read(),"\r\n",false);
f.close();
for(uint i=0; i<lines.length(); i++)
{
string[] ld=string_split(lines[i],":",false);
if(ld[0]=="ai" and p.is_admin()==false)
{
send_reliable(p,"can't get data of this map",2);
return;
}
else if(ld[0]=="item" and p.is_admin()==false)
{
send_reliable(p,"can't get data of this map",2);
return;
}
else if(ld[0]=="challenge_status" and p.is_admin()==false)
{
send_reliable(p,"can't get data of this map",2);
return;
}
else if(ld[0]=="vending_machine" and p.is_admin()==false)
{
send_reliable(p,"can't get data of this map",2);
return;
}
else if(ld[0]=="fishing_coordinate" and p.is_admin()==false)
{
send_reliable(p,"can't get data of this map",2);
return;
}
send_reliable(p,"buildrestorebackup "+p.map+"",0);
return;
}
}
else if(what=="mapstats")
{
f.open("maps/"+p.map+".map", "rb");
string[] things=string_split(f.read(), "\r\n",false);
f.close();
send_reliable(p,"this map has "+things.length()+" lines and is "+get_file_size("maps/"+p.map+".map")+"",2);
}
else if(what=="addline")
{
send_reliable(p,"buildaddline",0);
}
else if(what=="editline")
{
server_menu2 m;
m.intro="Select the line that you'd like to edit";
m.initial_packet="editline";
int ind=get_map_index(p.map);
if(ind>-1)
{
string[] lines=string_split(maps[ind].rawdata,"\r\n",true);
for(uint i=0; i<lines.length(); i++)
{
if(string_contains(lines[i],":",1)<0)
{
send_reliable(p,"error: all map commands take at least one argument, got "+lines[i]+"",2);
return;
}
string[] ld=string_split(lines[i],":",false);
if(ld[0]=="mapname" and p.is_admin()==false) continue;
if(ld[0]=="ai" and p.is_admin()==false)
{
m.add("unlabled",lines[i]);
}
else if(ld[0]=="item" and p.is_admin()==false)
{
m.add("unlabled",lines[i]);
}
else if(ld[0]=="challenge_status" and p.is_admin()==false)
{
m.add("unlabled",lines[i]);
}
else if(ld[0]=="vending_machine" and p.is_admin()==false)
{
m.add("unlabled",lines[i]);
}
else if(ld[0]=="fishing_coordinate" and p.is_admin()==false)
{
m.add("unlabled",lines[i]);
}
else
{
m.add(lines[i],lines[i]);
}
}
}
m.send(p.peer_id);
}
else if(what=="removeline")
{
server_menu2 m;
m.intro="Select the line that you'd like to remove";
m.initial_packet="removeline";
int ind=get_map_index(p.map);
if(ind>-1)
{
string[] lines=string_split(maps[ind].rawdata,"\r\n",true);
for(uint i=0; i<lines.length(); i++)
{
if(string_contains(lines[i],":",1)<0)
{
send_reliable(p,"error: all map commands take at least one argument, got "+lines[i]+"",2);
return;
}
string[] ld=string_split(lines[i],":",false);
if(ld[0]=="mapname" and p.is_admin()==false) continue;
if(ld[0]=="ai" and p.is_admin()==false)
{
m.add("unlabled",lines[i]);
}
else if(ld[0]=="item" and p.is_admin()==false)
{
m.add("unlabled",lines[i]);
}
else if(ld[0]=="challenge_status" and p.is_admin()==false)
{
m.add("unlabled",lines[i]);
}
else if(ld[0]=="vending_machine" and p.is_admin()==false)
{
m.add("unlabled",lines[i]);
}
else if(ld[0]=="fishing_coordinate" and p.is_admin()==false)
{
m.add("unlabled",lines[i]);
}
else
{
m.add(lines[i],lines[i]);
}
}
}
m.send(p.peer_id);
}
else if(what=="removeowner")
{
server_menu2 m;
m.intro="who would you like to remove";
m.initial_packet="removeowner";
int ind=get_map_index(p.map);
if(ind>-1)
{
string[] lines=string_split(maps[ind].rawdata,"\r\n",true);
for(uint i=0;i<lines.length();i++)
{
if(string_contains(lines[i],":",1)<0)
{
send_reliable(p,"error: all map commands take at least one argument, got "+lines[i]+"",2);
return;
}
if(string_contains(lines[i],"owner:",1)>-1)
{
string[] ar=string_split(lines[i],":",false);
m.add(ar[1],lines[i]);
}
}
}
m.send(p.peer_id);
}
else if(what=="pmd")
{
send_reliable(p,"buildpmd",0);
}
else if(what=="specified_air_temperature")
{
send_reliable(p,"buildspecified_air_temperature",0);
}
}
return;
}
}
}
else if(parsed[0]=="build")
{
if(p.is_admin())
{
send_menu(p.peer_id,"Builder menu","buildobj","tile:tile[]zone:zone[]sound source:src[]music:music[]timed sound:timedsound[]timed music:timedmusic[]automover:automover[]door:door[]travelpoint:travelpoint[]safe zone:safezone[]fishing coordinate:fishingcoordinate[]starting_point:starting_point[]deathpoint:deathpoint[]sign:sign[]txt:txt[]timed text:timedtext[]dialog:dialog[]automatic dialog:automatic_dialog[]checkpoint:checkpoint[]forcefield:forcefield[]hazard:hazard[]specified air temperature:specified_air_temperature[]teleporter:teleporter[]vanishing platform:vanishing_platform[]vending machine:vending_machine[]AI:AI[]foods and drinks:fad[]draw sounds:drawsounds[]item usage limit:itemusagelimit[]item:item[]item usage restriction:item_usage_restriction[]fire:firemap[]challenge status:challenge_status[]level:level[]opening hours:opening_hours[]pvp:pvp[]reinforcement:reinforcement[]toilet:toilet[]washbasin:washbasin[]shower:shower[]trashcan:trashcan[]bed:bed[]clock:clock[]calendar:calendar[]oven:oven[]url:url[]togglable features:tf[]toggle losing items after death:litem[]toggle moving to the safe zone map after losing safe card:safe_card[]description:description[]add owner:owner[]remove owner:removeowner[]add line:addline[]edit line:editline[]remove line:removeline[]make map public:public[]make map private:private[]add this map to the challenge maps:challenge[]remove this map from challenge maps:notchallenge[]back up this map:backupmap[]restore backup:restorebackup[]view map stats:mapstats[]get map data:gmd[]put map data:pmd[]new map:newmap[]delete this map:deletemap");
}
else
{
if(in_house(p)>-1)
{
int mapindex=get_map_index(p.map);
if(mapindex>-1)
{
for(uint i=0; i<maps[mapindex].owners.length(); i++)
{
if(maps[mapindex].owners.find(p.name)>-1 or maps[mapindex].owners.find(p.partner)>-1 or p.is_admin())
{
send_menu(p.peer_id,"Builder menu","buildobj","tile:tile[]zone:zone[]sound source:src[]music:music[]timed sound:timedsound[]timed music:timedmusic[]automover:automover[]door:door[]travelpoint:travelpoint[]safe zone:safezone[]starting_point:starting_point[]deathpoint:deathpoint[]sign:sign[]txt:txt[]timed text:timedtext[]dialog:dialog[]automatic dialog:automatic_dialog[]checkpoint:checkpoint[]forcefield:forcefield[]hazard:hazard[]specified air temperature:specified_air_temperature[]teleporter:teleporter[]vanishing platform:vanishing_platform[]item usage restriction:item_usage_restriction[]fire:firemap[]level:level[]opening hours:opening_hours[]pvp:pvp[]reinforcement:reinforcement[]toilet:toilet[]washbasin:washbasin[]shower:shower[]trashcan:trashcan[]bed:bed[]clock:clock[]calendar:calendar[]oven:oven[]url:url[]togglable features:tf[]toggle losing items after death:litem[]toggle moving to the safe zone map after losing safe card:safe_card[]add owner:owner[]remove owner:removeowner[]add line:addline[]edit line:editline[]remove line:removeline[]back up this map:backupmap[]restore backup:restorebackup[]view map stats:mapstats[]get map data:gmd[]put map data:pmd");
}
}
}
}
else
{
int mapindex=get_map_index(p.map);
if(mapindex>-1)
{
for(uint i=0; i<maps[mapindex].owners.length(); i++)
{
if(maps[mapindex].owners.find(p.name)>-1 or maps[mapindex].owners.find(p.partner)>-1 or p.is_admin())
{
string[] a=string_split(file_get_contents("chmaps.svr"),"\r\n",false);
int something=a.find(p.map);
if(something>-1)
{
send_reliable(p,"you can't do this in a challenge map",2);
return;
}
send_menu(p.peer_id,"Builder menu","buildobj","tile:tile[]zone:zone[]sound source:src[]music:music[]timed sound:timedsound[]timed music:timedmusic[]automover:automover[]door:door[]travelpoint:travelpoint[]safe zone:safezone[]starting_point:starting_point[]deathpoint:deathpoint[]sign:sign[]txt:txt[]timed text:timedtext[]dialog:dialog[]automatic dialog:automatic_dialog[]checkpoint:checkpoint[]forcefield:forcefield[]hazard:hazard[]specified air temperature:specified_air_temperature[]teleporter:teleporter[]vanishing platform:vanishing_platform[]item usage restriction:item_usage_restriction[]fire:firemap[]level:level[]opening hours:opening_hours[]pvp:pvp[]reinforcement:reinforcement[]toilet:toilet[]washbasin:washbasin[]shower:shower[]trashcan:trashcan[]bed:bed[]clock:clock[]calendar:calendar[]oven:oven[]url:url[]togglable features:tf[]toggle losing items after death:litem[]toggle moving to the safe zone map after losing safe card:safe_card[]description:description[]add owner:owner[]remove owner:removeowner[]add line:addline[]edit line:editline[]remove line:removeline[]make map public:public[]make map private:private[]back up this map:backupmap[]restore backup:restorebackup[]view map stats:mapstats[]get map data:gmd[]put map data:pmd[]delete this map:deletemap");
}
return;
}
}
}
}
}
else if(parsed[0]=="bAI" and parsed.length>1)
{
int mapindex=get_map_index(p.map);
if(mapindex>-1)
{
for(uint i=0; i<maps[mapindex].owners.length(); i++)
{
if(maps[mapindex].owners.find(p.name)>-1 or maps[mapindex].owners.find(p.partner)>-1 or p.is_admin())
{
string what=parsed[1];
if(what=="AI")
{
send_reliable(p,"buildAI",0);
}
else if(what=="createAI")
{
send_reliable(p,"createAI",0);
}
else if(what=="editAI")
{
server_menu2 m;
m.intro="choose an option";
m.initial_packet="editai";
string[] a=find_files("ais/*.ai");
for (uint i=0; i<a.length(); i++)
{
m.add(string_replace(a[i],".ai","",true),a[i]);
}
m.send(p.peer_id);
}
else if(what=="removeAI")
{
server_menu2 m;
m.intro="choose an option";
m.initial_packet="removeai";
string[] a=find_files("ais/*.ai");
for (uint i=0; i<a.length(); i++)
{
m.add(string_replace(a[i],".ai","",true),a[i]);
}
m.send(p.peer_id);
}
else if(what=="removeAIline")
{
server_menu2 m;
m.intro="choose an option";
m.initial_packet="removeailine";
string[] a=find_files("ais/*.ai");
for (uint i=0; i<a.length(); i++)
{
m.add(string_replace(a[i],".ai","",true),a[i]);
}
m.send(p.peer_id);
}
else if(what=="spawnAI")
{
send_reliable(p,"buildAI",0);
}
}
return;
}
}
}
else if(parsed[0]=="bdrawsounds" and parsed.length>1)
{
int mapindex=get_map_index(p.map);
if(mapindex>-1)
{
for(uint i=0; i<maps[mapindex].owners.length(); i++)
{
if(maps[mapindex].owners.find(p.name)>-1 or maps[mapindex].owners.find(p.partner)>-1 or p.is_admin())
{
string what=parsed[1];
if(what=="createdrawsound")
{
send_reliable(p,"createdrawsound",0);
}
else if(what=="editdrawsound")
{
server_menu m;
m.intro="Select the line that you'd like to edit";
m.initial_packet="drawsoundseditlinetext";
file f;
f.open("drawsounds.svr","rb");
string[] lines=string_split(f.read(),"\r\n",true);
f.close();
for(uint i=0; i<lines.length(); i++)
{
if(string_contains(lines[i],"=",1)<0)
{
send_reliable(p,"error: all draw sounds take at least one argument, got "+lines[i]+"",2);
return;
}
m.add(lines[i],lines[i]);
}
m.send(p.peer_id);
}
else if(what=="removedrawsoundline")
{
server_menu m;
m.intro="Select the line that you'd like to remove";
m.initial_packet="drawsoundsremovelinetext";
file f;
f.open("drawsounds.svr","rb");
string[] lines=string_split(f.read(),"\r\n",true);
f.close();
for(uint i=0; i<lines.length(); i++)
{
if(string_contains(lines[i],"=",1)<0)
{
send_reliable(p,"error: all draw sounds take at least one argument, got "+lines[i]+"",2);
return;
}
m.add(lines[i],lines[i]);
}
m.send(p.peer_id);
}
}
return;
}
}
}
else if(parsed[0]=="bitemusagelimit" and parsed.length>1)
{
int mapindex=get_map_index(p.map);
if(mapindex>-1)
{
for(uint i=0; i<maps[mapindex].owners.length(); i++)
{
if(maps[mapindex].owners.find(p.name)>-1 or maps[mapindex].owners.find(p.partner)>-1 or p.is_admin())
{
string what=parsed[1];
if(what=="createitemusagelimit")
{
send_reliable(p,"createitemusagelimit",0);
}
else if(what=="edititemusagelimit")
{
server_menu m;
m.intro="Select the line that you'd like to edit";
m.initial_packet="itemusagelimiteditlinetext";
file f;
f.open("notadg.svr","rb");
string[] lines=string_split(f.read(),"\r\n",true);
f.close();
for(uint i=0; i<lines.length(); i++)
{
if(string_contains(lines[i],"=",1)<0)
{
send_reliable(p,"error: all draw sounds take at least one argument, got "+lines[i]+"",2);
return;
}
m.add(lines[i],lines[i]);
}
m.send(p.peer_id);
}
else if(what=="removeitemusagelimitline")
{
server_menu m;
m.intro="Select the line that you'd like to remove";
m.initial_packet="itemusagelimitremovelinetext";
file f;
f.open("notadg.svr","rb");
string[] lines=string_split(f.read(),"\r\n",true);
f.close();
for(uint i=0; i<lines.length(); i++)
{
if(string_contains(lines[i],"=",1)<0)
{
send_reliable(p,"error: all draw sounds take at least one argument, got "+lines[i]+"",2);
return;
}
m.add(lines[i],lines[i]);
}
m.send(p.peer_id);
}
}
return;
}
}
}
else if(parsed[0]=="bfad" and parsed.length>1)
{
int mapindex=get_map_index(p.map);
if(mapindex>-1)
{
for(uint i=0; i<maps[mapindex].owners.length(); i++)
{
if(maps[mapindex].owners.find(p.name)>-1 or maps[mapindex].owners.find(p.partner)>-1 or p.is_admin())
{
string what=parsed[1];
if(what=="fad")
{
send_reliable(p,"buildfad",0);
}
else if(what=="createfad")
{
send_reliable(p,"createfad",0);
}
else if(what=="editfad")
{
server_menu2 m;
m.intro="choose an option";
m.initial_packet="fadeditlinetext";
string[] a=find_files("foods_and_drinks/*.fad");
for (uint i=0; i<a.length(); i++)
{
m.add(string_replace(a[i],".fad","",true),a[i]);
}
m.send(p.peer_id);
}
else if(what=="removefad")
{
server_menu2 m;
m.intro="choose an option";
m.initial_packet="removefad";
string[] a=find_files("foods_and_drinks/*.fad");
for (uint i=0; i<a.length(); i++)
{
m.add(string_replace(a[i],".fad","",true),a[i]);
}
m.send(p.peer_id);
}
}
return;
}
}
}
else if(parsed[0]=="bdoor" and parsed.length>1)
{
int mapindex=get_map_index(p.map);
if(mapindex>-1)
{
for(uint i=0; i<maps[mapindex].owners.length(); i++)
{
if(maps[mapindex].owners.find(p.name)>-1 or maps[mapindex].owners.find(p.partner)>-1 or p.is_admin())
{
string what=parsed[1];
if(what=="door")
{
send_reliable(p,"builddoor",0);
}
else if(what=="pdoor")
{
send_reliable(p,"buildpdoor",0);
}
else if(what=="icdoor")
{
send_reliable(p,"buildicdoor",0);
}
else if(what=="itdoor")
{
send_reliable(p,"builditdoor",0);
}
else if(what=="igdoor")
{
send_reliable(p,"buildigdoor",0);
}
}
return;
}
}
}
else if(parsed[0]=="bautomover" and parsed.length>1)
{
int mapindex=get_map_index(p.map);
if(mapindex>-1)
{
for(uint i=0; i<maps[mapindex].owners.length(); i++)
{
if(maps[mapindex].owners.find(p.name)>-1 or maps[mapindex].owners.find(p.partner)>-1 or p.is_admin())
{
string what=parsed[1];
if(what=="automover")
{
send_reliable(p,"buildautomover",0);
}
else if(what=="pautomover")
{
send_reliable(p,"buildpautomover",0);
}
else if(what=="icautomover")
{
send_reliable(p,"buildicautomover",0);
}
else if(what=="itautomover")
{
send_reliable(p,"builditautomover",0);
}
else if(what=="igautomover")
{
send_reliable(p,"buildigautomover",0);
}
}
return;
}
}
}
else if(parsed[0]=="btravelpoint" and parsed.length>1)
{
int mapindex=get_map_index(p.map);
if(mapindex>-1)
{
for(uint i=0; i<maps[mapindex].owners.length(); i++)
{
if(maps[mapindex].owners.find(p.name)>-1 or maps[mapindex].owners.find(p.partner)>-1 or p.is_admin())
{
string what=parsed[1];
if(what=="automatic_travelpoint")
{
send_reliable(p,"buildautomatic_travelpoint",0);
}
else if(what=="pautomatic_travelpoint")
{
send_reliable(p,"buildpautomatic_travelpoint",0);
}
else if(what=="icautomatic_travelpoint")
{
send_reliable(p,"buildicautomatic_travelpoint",0);
}
else if(what=="itautomatic_travelpoint")
{
send_reliable(p,"builditautomatic_travelpoint",0);
}
else if(what=="igautomatic_travelpoint")
{
send_reliable(p,"buildigautomatic_travelpoint",0);
}
else if(what=="travelpoint")
{
send_reliable(p,"buildtravelpoint",0);
}
else if(what=="ptravelpoint")
{
send_reliable(p,"buildptravelpoint",0);
}
else if(what=="ictravelpoint")
{
send_reliable(p,"buildictravelpoint",0);
}
else if(what=="ittravelpoint")
{
send_reliable(p,"buildittravelpoint",0);
}
else if(what=="igtravelpoint")
{
send_reliable(p,"buildigtravelpoint",0);
}
}
return;
}
}
}
else if(parsed[0]=="btf" and parsed.length>1)
{
int mapindex=get_map_index(p.map);
if(mapindex>-1)
{
for(uint i=0; i<maps[mapindex].owners.length(); i++)
{
if(maps[mapindex].owners.find(p.name)>-1 or maps[mapindex].owners.find(p.partner)>-1 or p.is_admin())
{
string what=parsed[1];
if(what=="elocalchat")
{
send_reliable(p,"buildelocalchat",0);
}
else if(what=="evoicechat")
{
send_reliable(p,"buildevoicechat",0);
}
else if(what=="ettschat")
{
send_reliable(p,"buildettschat",0);
}
else if(what=="etracking")
{
send_reliable(p,"buildetracking",0);
}
else if(what=="edisasters")
{
send_reliable(p,"buildedisasters",0);
}
else if(what=="ecoordinates")
{
send_reliable(p,"buildecoordinates",0);
}
else if(what=="cameraoptions")
{
if(p.is_admin())
{
send_menu(p.peer_id,"camera options menu","bcmr","enable camera:ecamera[]disable camera:dcamera[]enable passing camera through walls:ecamerawall[]disable passing camera through walls:dcamerawall[]enable mfwc:emfwc[]disable mfwc:mfwc[]enable camera seeing players:ecameraplayer[]disable camera seeing players:dcameraplayer[]enable camera seeing items:ecameraitem[]disable camera seeing items:dcameraitem[]enable camera seeing doors:ecameradoor[]disable camera seeing doors:dcameradoor[]enable camera seeing password protected doors:ecamerapdoor[]disable camera seeing password protected doors:dcamerapdoor[]enable camera seeing item checker doors:ecameraicdoor[]disable camera seeing item checker doors:dcameraicdoor[]enable camera seeing item taker doors:ecameraitdoor[]disable camera seeing item taker doors:dcameraitdoor[]enable camera seeing item giver doors:ecameraigdoor[]disable camera seeing item giver doors:dcameraigdoor[]enable camera seeing automovers:ecameraautomover[]disable camera seeing automovers:dcameraautomover[]enable camera seeing password protected automovers:ecamerapautomover[]disable camera seeing password protected automovers:dcamerapautomover[]enable camera seeing item checker automovers:ecameraicautomover[]disable camera seeing item checker automovers:dcameraicautomover[]enable camera seeing item taker automovers:ecameraitautomover[]disable camera seeing item taker automovers:dcameraitautomover[]enable camera seeing item giver automovers:ecameraigautomover[]disable camera seeing item giver automovers:dcameraigautomover[]enable camera seeing automatic_travelpoints:ecameraautomatic_travelpoint[]disable camera seeing automatic_travelpoints:dcameraautomatic_travelpoint[]enable camera seeing password protected automatic_travelpoints:ecamerapautomatic_travelpoint[]disable camera seeing password protected automatic_travelpoints:dcamerapautomatic_travelpoint[]enable camera seeing item checker automatic_travelpoints:ecameraicautomatic_travelpoint[]disable camera seeing item checker automatic_travelpoints:dcameraicautomatic_travelpoint[]enable camera seeing item taker automatic_travelpoints:ecameraitautomatic_travelpoint[]disable camera seeing item taker automatic_travelpoints:dcameraitautomatic_travelpoint[]enable camera seeing item giver automatic_travelpoints:ecameraigautomatic_travelpoint[]disable camera seeing item giver automatic_travelpoints:dcameraigautomatic_travelpoint[]enable camera seeing travelpoints:ecameratravelpoint[]disable camera seeing travelpoints:dcameratravelpoint[]enable camera seeing password protected travelpoints:ecameraptravelpoint[]disable camera seeing password protected travelpoints:dcameraptravelpoint[]enable camera seeing item checker travelpoints:ecameraictravelpoint[]disable camera seeing item checker travelpoints:dcameraictravelpoint[]enable camera seeing item taker travelpoints:ecameraittravelpoint[]disable camera seeing item taker travelpoints:dcameraittravelpoint[]enable camera seeing item giver travelpoints:ecameraigtravelpoint[]disable camera seeing item giver travelpoints:dcameraigtravelpoint[]enable camera seeing forcefields:ecameraff[]disable camera seeing forcefields:dcameraff[]enable camera seeing hazards:ecamerah[]disable camera seeing hazards:dcamerah[]enable camera seeing teleporters:ecameratp[]disable camera seeing teleporters:dcameratp[]enable camera seeing vanishing platforms:ecameravp[]disable camera seeing vanishing platforms:dcameravp[]enable camera seeing signs:ecamerasign[]disable camera seeing signs:dcamerasign[]enable camera seeing txts:ecameratxt[]disable camera seeing txts:dcameratxt");
}
else
{
send_menu(p.peer_id,"camera options menu","bcmr","enable camera:ecamera[]disable camera:dcamera[]enable passing camera through walls:ecamerawall[]disable passing camera through walls:dcamerawall[]enable mfwc:emfwc[]disable mfwc:mfwc[]enable camera seeing players:ecameraplayer[]disable camera seeing players:dcameraplayer[]enable camera seeing items:ecameraitem[]disable camera seeing items:dcameraitem[]enable camera seeing doors:ecameradoor[]disable camera seeing doors:dcameradoor[]enable camera seeing password protected doors:ecamerapdoor[]disable camera seeing password protected doors:dcamerapdoor[]enable camera seeing item checker doors:ecameraicdoor[]disable camera seeing item checker doors:dcameraicdoor[]enable camera seeing item taker doors:ecameraitdoor[]disable camera seeing item taker doors:dcameraitdoor[]enable camera seeing automovers:ecameraautomover[]disable camera seeing automovers:dcameraautomover[]enable camera seeing password protected automovers:ecamerapautomover[]disable camera seeing password protected automovers:dcamerapautomover[]enable camera seeing item checker automovers:ecameraicautomover[]disable camera seeing item checker automovers:dcameraicautomover[]enable camera seeing item taker automovers:ecameraitautomover[]disable camera seeing item taker automovers:dcameraitautomover[]enable camera seeing automatic_travelpoints:ecameraautomatic_travelpoint[]disable camera seeing automatic_travelpoints:dcameraautomatic_travelpoint[]enable camera seeing password protected automatic_travelpoints:ecamerapautomatic_travelpoint[]disable camera seeing password protected automatic_travelpoints:dcamerapautomatic_travelpoint[]enable camera seeing item checker automatic_travelpoints:ecameraicautomatic_travelpoint[]disable camera seeing item checker automatic_travelpoints:dcameraicautomatic_travelpoint[]enable camera seeing item taker automatic_travelpoints:ecameraitautomatic_travelpoint[]disable camera seeing item taker automatic_travelpoints:dcameraitautomatic_travelpoint[]enable camera seeing travelpoints:ecameratravelpoint[]disable camera seeing travelpoints:dcameratravelpoint[]enable camera seeing password protected travelpoints:ecameraptravelpoint[]disable camera seeing password protected travelpoints:dcameraptravelpoint[]enable camera seeing item checker travelpoints:ecameraictravelpoint[]disable camera seeing item checker travelpoints:dcameraictravelpoint[]enable camera seeing item taker travelpoints:ecameraittravelpoint[]disable camera seeing item taker travelpoints:dcameraittravelpoint[]enable camera seeing forcefields:ecameravp[]disable camera seeing forcefields:dcameravp[]enable camera seeing hazards:ecamerah[]disable camera seeing hazards:dcamerah[]enable camera seeing teleporters:ecameratp[]disable camera seeing teleporters:dcameratp[]enable camera seeing vanishing platforms:ecameravp[]disable camera seeing vanishing platforms:dcameravp[]enable camera seeing signs:ecamerasign[]disable camera seeing signs:dcamerasign[]enable camera seeing txts:ecameratxt[]disable camera seeing txts:dcameratxt");
}
}
else if(what=="e2dsupport")
{
send_reliable(p,"builde2dsupport",0);
}
else if(what=="ejump")
{
send_reliable(p,"buildejump",0);
}
else if(what=="spyglassoptions")
{
if(p.is_admin())
{
send_menu(p.peer_id,"spyglass options menu","bspg","enable spyglass:espy[]disable spyglass:dspy[]enable spyglass seeing players:espyplayer[]disable spyglass seeing players:dspyplayer[]enable spyglass seeing items:espyitem[]disable spyglass seeing items:dspyitem[]enable spyglass seeing doors:espydoor[]disable spyglass seeing doors:dspydoor[]enable spyglass seeing password protected doors:espypdoor[]disable spyglass seeing password protected doors:dspypdoor[]enable spyglass seeing item checker doors:espyicdoor[]disable spyglass seeing item checker doors:dspyicdoor[]enable spyglass seeing item taker doors:espyitdoor[]disable spyglass seeing item taker doors:dspyitdoor[]enable spyglass seeing item giver doors:espyigdoor[]disable spyglass seeing item giver doors:dspyigdoor[]enable spyglass seeing automovers:espyautomover[]disable spyglass seeing automovers:dspyautomover[]enable spyglass seeing password protected automovers:espypautomover[]disable spyglass seeing password protected automovers:dspypautomover[]enable spyglass seeing item checker automovers:espyicautomover[]disable spyglass seeing item checker automovers:dspyicautomover[]enable spyglass seeing item taker automovers:espyitautomover[]disable spyglass seeing item taker automovers:dspyitautomover[]enable spyglass seeing item giver automovers:espyigautomover[]disable spyglass seeing item giver automovers:dspyigautomover[]enable spyglass seeing automatic_travelpoints:espyautomatic_travelpoint[]disable spyglass seeing automatic_travelpoints:dspyautomatic_travelpoint[]enable spyglass seeing password protected automatic_travelpoints:espypautomatic_travelpoint[]disable spyglass seeing password protected automatic_travelpoints:dspypautomatic_travelpoint[]enable spyglass seeing item checker automatic_travelpoints:espyicautomatic_travelpoint[]disable spyglass seeing item checker automatic_travelpoints:dspyicautomatic_travelpoint[]enable spyglass seeing item taker automatic_travelpoints:espyitautomatic_travelpoint[]disable spyglass seeing item taker automatic_travelpoints:dspyitautomatic_travelpoint[]enable spyglass seeing item giver automatic_travelpoints:espyigautomatic_travelpoint[]disable spyglass seeing item giver automatic_travelpoints:dspyigautomatic_travelpoint[]enable spyglass seeing travelpoints:espytravelpoint[]disable spyglass seeing travelpoints:dspytravelpoint[]enable spyglass seeing password protected travelpoints:espyptravelpoint[]disable spyglass seeing password protected travelpoints:dspyptravelpoint[]enable spyglass seeing item checker travelpoints:espyictravelpoint[]disable spyglass seeing item checker travelpoints:dspyictravelpoint[]enable spyglass seeing item taker travelpoints:espyittravelpoint[]disable spyglass seeing item taker travelpoints:dspyittravelpoint[]enable spyglass seeing item giver travelpoints:espyigtravelpoint[]disable spyglass seeing item giver travelpoints:dspyigtravelpoint[]enable spyglass seeing forcefields:espyff[]disable spyglass seeing forcefields:dspyff[]enable spyglass seeing hazards:espyh[]disable spyglass seeing hazards:dspyh[]enable spyglass seeing teleporters:espytp[]disable spyglass seeing teleporters:dspytp[]enable spyglass seeing vanishing platforms:espyvp[]disable spyglass seeing vanishing platforms:dspyvp[]enable spyglass seeing signs:espysign[]disable spyglass seeing signs:dspysign[]enable spyglass seeing txts:espytxt[]disable spyglass seeing txts:dspytxt");
}
else
{
send_menu(p.peer_id,"spyglass options menu","bspg","enable spyglass:espy[]disable spyglass:dspy[]enable spyglass seeing players:espyplayer[]disable spyglass seeing players:dspyplayer[]enable spyglass seeing items:espyitem[]disable spyglass seeing items:dspyitem[]enable spyglass seeing doors:espydoor[]disable spyglass seeing doors:dspydoor[]enable spyglass seeing password protected doors:espypdoor[]disable spyglass seeing password protected doors:dspypdoor[]enable spyglass seeing item checker doors:espyicdoor[]disable spyglass seeing item checker doors:dspyicdoor[]enable spyglass seeing item taker doors:espyitdoor[]disable spyglass seeing item taker doors:dspyitdoor[]enable spyglass seeing automovers:espyautomover[]disable spyglass seeing automovers:dspyautomover[]enable spyglass seeing password protected automovers:espypautomover[]disable spyglass seeing password protected automovers:dspypautomover[]enable spyglass seeing item checker automovers:espyicautomover[]disable spyglass seeing item checker automovers:dspyicautomover[]enable spyglass seeing item taker automovers:espyitautomover[]disable spyglass seeing item taker automovers:dspyitautomover[]enable spyglass seeing automatic_travelpoints:espyautomatic_travelpoint[]disable spyglass seeing automatic_travelpoints:dspyautomatic_travelpoint[]enable spyglass seeing password protected automatic_travelpoints:espypautomatic_travelpoint[]disable spyglass seeing password protected automatic_travelpoints:dspypautomatic_travelpoint[]enable spyglass seeing item checker automatic_travelpoints:espyicautomatic_travelpoint[]disable spyglass seeing item checker automatic_travelpoints:dspyicautomatic_travelpoint[]enable spyglass seeing item taker automatic_travelpoints:espyitautomatic_travelpoint[]disable spyglass seeing item taker automatic_travelpoints:dspyitautomatic_travelpoint[]enable spyglass seeing travelpoints:espytravelpoint[]disable spyglass seeing travelpoints:dspytravelpoint[]enable spyglass seeing password protected travelpoints:espyptravelpoint[]disable spyglass seeing password protected travelpoints:dspyptravelpoint[]enable spyglass seeing item checker travelpoints:espyictravelpoint[]disable spyglass seeing item checker travelpoints:dspyictravelpoint[]enable spyglass seeing item taker travelpoints:espyittravelpoint[]disable spyglass seeing item taker travelpoints:dspyittravelpoint[]enable spyglass seeing forcefields:espyff[]disable spyglass seeing forcefields:dspyff[]enable spyglass seeing hazards:espyh[]disable spyglass seeing hazards:dspyh[]enable spyglass seeing teleporters:espytp[]disable spyglass seeing teleporters:dspytp[]enable spyglass seeing vanishing platforms:espyvp[]disable spyglass seeing vanishing platforms:dspyvp[]enable spyglass seeing signs:espysign[]disable spyglass seeing signs:dspysign[]enable spyglass seeing txts:espytxt[]disable spyglass seeing txts:dspytxt");
}
}
else if(what=="dlocalchat")
{
send_reliable(p,"builddlocalchat",0);
}
else if(what=="dvoicechat")
{
send_reliable(p,"builddvoicechat",0);
}
else if(what=="dttschat")
{
send_reliable(p,"builddttschat",0);
}
else if(what=="dtracking")
{
send_reliable(p,"builddtracking",0);
}
else if(what=="ddisasters")
{
send_reliable(p,"buildddisasters",0);
}
else if(what=="dcoordinates")
{
send_reliable(p,"builddcoordinates",0);
}
else if(what=="d2dsupport")
{
send_reliable(p,"buildd2dsupport",0);
}
else if(what=="djump")
{
send_reliable(p,"builddjump",0);
}
else if(what=="drain")
{
send_reliable(p,"builddrain",0);
}
else if(what=="dwind")
{
send_reliable(p,"builddwind",0);
}
else if(what=="dnight")
{
send_reliable(p,"builddnight",0);
}
}
return;
}
}
}
else if(parsed[0]=="bcmr" and parsed.length>1)
{
int mapindex=get_map_index(p.map);
if(mapindex>-1)
{
for(uint i=0; i<maps[mapindex].owners.length(); i++)
{
if(maps[mapindex].owners.find(p.name)>-1 or maps[mapindex].owners.find(p.partner)>-1 or p.is_admin())
{
string what=parsed[1];
if(what=="ecamera")
{
send_reliable(p,"buildecamera",0);
}
else if(what=="ecamerawall")
{
send_reliable(p,"buildecamerawall",0);
}
else if(what=="emfwc")
{
send_reliable(p,"buildemfwc",0);
}
else if(what=="dcamera")
{
send_reliable(p,"builddcamera",0);
}
else if(what=="dcamerawall")
{
send_reliable(p,"builddcamerawall",0);
}
else if(what=="dmfwc")
{
send_reliable(p,"builddmfwc",0);
}
else if(what=="ecameraplayer")
{
send_reliable(p,"buildecameraplayer",0);
}
else if(what=="dcameraplayer")
{
send_reliable(p,"builddcameraplayer",0);
}
else if(what=="ecameraitem")
{
send_reliable(p,"buildecameraitem",0);
}
else if(what=="dcameraitem")
{
send_reliable(p,"builddcameraitem",0);
}
else if(what=="ecameradoor")
{
send_reliable(p,"buildecameradoor",0);
}
else if(what=="dcameradoor")
{
send_reliable(p,"builddcameradoor",0);
}
else if(what=="ecamerapdoor")
{
send_reliable(p,"buildecamerapdoor",0);
}
else if(what=="dcamerapdoor")
{
send_reliable(p,"builddcamerapdoor",0);
}
else if(what=="ecameraicdoor")
{
send_reliable(p,"buildecameraicdoor",0);
}
else if(what=="dcameraicdoor")
{
send_reliable(p,"builddcameraicdoor",0);
}
else if(what=="ecameraitdoor")
{
send_reliable(p,"buildecameraitdoor",0);
}
else if(what=="dcameraitdoor")
{
send_reliable(p,"builddcameraitdoor",0);
}
else if(what=="ecameraigdoor")
{
send_reliable(p,"buildecameraigdoor",0);
}
else if(what=="dcameraigdoor")
{
send_reliable(p,"builddcameraigdoor",0);
}
else if(what=="ecameraautomover")
{
send_reliable(p,"buildecameraautomover",0);
}
else if(what=="dcameraautomover")
{
send_reliable(p,"builddcameraautomover",0);
}
else if(what=="ecamerapautomover")
{
send_reliable(p,"buildecamerapautomover",0);
}
else if(what=="dcamerapautomover")
{
send_reliable(p,"builddcamerapautomover",0);
}
else if(what=="ecameraicautomover")
{
send_reliable(p,"buildecameraicautomover",0);
}
else if(what=="dcameraicautomover")
{
send_reliable(p,"builddcameraicautomover",0);
}
else if(what=="ecameraitautomover")
{
send_reliable(p,"buildecameraitautomover",0);
}
else if(what=="dcameraitautomover")
{
send_reliable(p,"builddcameraitautomover ",0);
}
else if(what=="ecameraigautomover")
{
send_reliable(p,"buildecameraigautomover",0);
}
else if(what=="dcameraigautomover")
{
send_reliable(p,"builddcameraigautomover",0);
}
else if(what=="ecameraautomatic_travelpoint")
{
send_reliable(p,"buildecameraautomatic_travelpoint",0);
}
else if(what=="dcameraautomatic_travelpoint")
{
send_reliable(p,"builddcameraautomatic_travelpoint",0);
}
else if(what=="ecamerapautomatic_travelpoint")
{
send_reliable(p,"buildecamerapautomatic_travelpoint",0);
}
else if(what=="dcamerapautomatic_travelpoint")
{
send_reliable(p,"builddcamerapautomatic_travelpoint",0);
}
else if(what=="ecameraicautomatic_travelpoint")
{
send_reliable(p,"buildecameraicautomatic_travelpoint",0);
}
else if(what=="dcameraicautomatic_travelpoint")
{
send_reliable(p,"builddcameraicautomatic_travelpoint",0);
}
else if(what=="ecameraitautomatic_travelpoint")
{
send_reliable(p,"buildecameraitautomatic_travelpoint",0);
}
else if(what=="dcameraitautomatic_travelpoint")
{
send_reliable(p,"builddcameraitautomatic_travelpoint ",0);
}
else if(what=="ecameraigautomatic_travelpoint")
{
send_reliable(p,"buildecameraigautomatic_travelpoint",0);
}
else if(what=="dcameraigautomatic_travelpoint")
{
send_reliable(p,"builddcameraigautomatic_travelpoint",0);
}
else if(what=="ecameratravelpoint")
{
send_reliable(p,"buildecameratravelpoint",0);
}
else if(what=="dcameratravelpoint")
{
send_reliable(p,"builddcameratravelpoint",0);
}
else if(what=="ecameraptravelpoint")
{
send_reliable(p,"buildecameraptravelpoint",0);
}
else if(what=="dcameraptravelpoint")
{
send_reliable(p,"builddcameraptravelpoint",0);
}
else if(what=="ecameraictravelpoint")
{
send_reliable(p,"buildecameraictravelpoint",0);
}
else if(what=="dcameraictravelpoint")
{
send_reliable(p,"builddcameraictravelpoint",0);
}
else if(what=="ecameraittravelpoint")
{
send_reliable(p,"buildecameraittravelpoint",0);
}
else if(what=="dcameraittravelpoint")
{
send_reliable(p,"builddcameraittravelpoint ",0);
}
else if(what=="ecameraigtravelpoint")
{
send_reliable(p,"buildecameraigtravelpoint",0);
}
else if(what=="dcameraigtravelpoint")
{
send_reliable(p,"builddcameraigtravelpoint",0);
}
else if(what=="ecameravp")
{
send_reliable(p,"buildecameravp",0);
}
else if(what=="dcameravp")
{
send_reliable(p,"builddcameravp",0);
}
else if(what=="ecamerasign")
{
send_reliable(p,"buildecamerasign",0);
}
else if(what=="dcamerasign")
{
send_reliable(p,"builddcamerasign",0);
}
else if(what=="ecameratxt")
{
send_reliable(p,"buildecameratxt",0);
}
else if(what=="dcameratxt")
{
send_reliable(p,"builddcameratxt",0);
}
}
return;
}
}
}
else if(parsed[0]=="bspg" and parsed.length>1)
{
int mapindex=get_map_index(p.map);
if(mapindex>-1)
{
for(uint i=0; i<maps[mapindex].owners.length(); i++)
{
if(maps[mapindex].owners.find(p.name)>-1 or maps[mapindex].owners.find(p.partner)>-1 or p.is_admin())
{
string what=parsed[1];
if(what=="espy")
{
send_reliable(p,"buildespy",0);
}
else if(what=="dspy")
{
send_reliable(p,"builddspy",0);
}
else if(what=="espyplayer")
{
send_reliable(p,"buildespyplayer",0);
}
else if(what=="dspyplayer")
{
send_reliable(p,"builddspyplayer",0);
}
else if(what=="espyitem")
{
send_reliable(p,"buildespyitem",0);
}
else if(what=="dspyitem")
{
send_reliable(p,"builddspyitem",0);
}
else if(what=="espydoor")
{
send_reliable(p,"buildespydoor",0);
}
else if(what=="dspydoor")
{
send_reliable(p,"builddspydoor",0);
}
else if(what=="espypdoor")
{
send_reliable(p,"buildespypdoor",0);
}
else if(what=="dspypdoor")
{
send_reliable(p,"builddspypdoor",0);
}
else if(what=="espyicdoor")
{
send_reliable(p,"buildespyicdoor",0);
}
else if(what=="dspyicdoor")
{
send_reliable(p,"builddspyicdoor",0);
}
else if(what=="espyitdoor")
{
send_reliable(p,"buildespyitdoor",0);
}
else if(what=="dspyitdoor")
{
send_reliable(p,"builddspyitdoor",0);
}
else if(what=="espyigdoor")
{
send_reliable(p,"buildespyigdoor",0);
}
else if(what=="dspyigdoor")
{
send_reliable(p,"builddspyigdoor",0);
}
else if(what=="espyautomover")
{
send_reliable(p,"buildespyautomover",0);
}
else if(what=="dspyautomover")
{
send_reliable(p,"builddspyautomover",0);
}
else if(what=="espypautomover")
{
send_reliable(p,"buildespypautomover",0);
}
else if(what=="dspypautomover")
{
send_reliable(p,"builddspypautomover",0);
}
else if(what=="espyicautomover")
{
send_reliable(p,"buildespyicautomover",0);
}
else if(what=="dspyicautomover")
{
send_reliable(p,"builddspyicautomover",0);
}
else if(what=="espyitautomover")
{
send_reliable(p,"buildespyitautomover",0);
}
else if(what=="dspyitautomover")
{
send_reliable(p,"builddspyitautomover ",0);
}
else if(what=="espyigautomover")
{
send_reliable(p,"buildespyigautomover",0);
}
else if(what=="dspyigautomover")
{
send_reliable(p,"builddspyigautomover",0);
}
else if(what=="espyautomatic_travelpoint")
{
send_reliable(p,"buildespyautomatic_travelpoint",0);
}
else if(what=="dspyautomatic_travelpoint")
{
send_reliable(p,"builddspyautomatic_travelpoint",0);
}
else if(what=="espypautomatic_travelpoint")
{
send_reliable(p,"buildespypautomatic_travelpoint",0);
}
else if(what=="dspypautomatic_travelpoint")
{
send_reliable(p,"builddspypautomatic_travelpoint",0);
}
else if(what=="espyicautomatic_travelpoint")
{
send_reliable(p,"buildespyicautomatic_travelpoint",0);
}
else if(what=="dspyicautomatic_travelpoint")
{
send_reliable(p,"builddspyicautomatic_travelpoint",0);
}
else if(what=="espyitautomatic_travelpoint")
{
send_reliable(p,"buildespyitautomatic_travelpoint",0);
}
else if(what=="dspyitautomatic_travelpoint")
{
send_reliable(p,"builddspyitautomatic_travelpoint ",0);
}
else if(what=="espyigautomatic_travelpoint")
{
send_reliable(p,"buildespyigautomatic_travelpoint",0);
}
else if(what=="dspyigautomatic_travelpoint")
{
send_reliable(p,"builddspyigautomatic_travelpoint",0);
}
else if(what=="espytravelpoint")
{
send_reliable(p,"buildespytravelpoint",0);
}
else if(what=="dspytravelpoint")
{
send_reliable(p,"builddspytravelpoint",0);
}
else if(what=="espyptravelpoint")
{
send_reliable(p,"buildespyptravelpoint",0);
}
else if(what=="dspyptravelpoint")
{
send_reliable(p,"builddspyptravelpoint",0);
}
else if(what=="espyictravelpoint")
{
send_reliable(p,"buildespyictravelpoint",0);
}
else if(what=="dspyictravelpoint")
{
send_reliable(p,"builddspyictravelpoint",0);
}
else if(what=="espyittravelpoint")
{
send_reliable(p,"buildespyittravelpoint",0);
}
else if(what=="dspyittravelpoint")
{
send_reliable(p,"builddspyittravelpoint ",0);
}
else if(what=="espyigtravelpoint")
{
send_reliable(p,"buildespyigtravelpoint",0);
}
else if(what=="dspyigtravelpoint")
{
send_reliable(p,"builddspyigtravelpoint",0);
}
else if(what=="espyvp")
{
send_reliable(p,"buildespyvp",0);
}
else if(what=="dspyvp")
{
send_reliable(p,"builddspyvp",0);
}
else if(what=="espysign")
{
send_reliable(p,"buildespysign",0);
}
else if(what=="dspysign")
{
send_reliable(p,"builddspysign",0);
}
else if(what=="espytxt")
{
send_reliable(p,"buildespytxt",0);
}
else if(what=="dspytxt")
{
send_reliable(p,"builddspytxt",0);
}
}
return;
}
}
}
else if(parsed[0]=="editai" and parsed.length()>=1)
{
if(parsed[1]=="back")
{
p.sendpacket("canceled", 0);
return;
}
p.aitoedit=parsed[1];
server_menu m;
m.intro="Select the line that you'd like to edit";
m.initial_packet="aieditlinetext";
file f;
f.open("ais/"+parsed[1],"rb");
string[] lines=string_split(f.read(),"\r\n",true);
f.close();
for(uint i=0; i<lines.length(); i++)
{
if(string_contains(lines[i],"=",1)<0)
{
send_reliable(p,"error: all ai commands take at least one argument, got "+lines[i]+"",2);
return;
}
m.add(lines[i],lines[i]);
}
m.send(p.peer_id);
}
else if(parsed[0]=="aieditline" and parsed.length()>1)
{
if(parsed[1]=="back")
{
p.sendpacket("canceled", 0);
return;
}
string aitext=string_replace(get_event_message(),"aieditline ","",false);
f.open("ais/"+p.aitoedit,"rb");
string aidata=f.read();
f.close();
string[] aisdata=string_split(aidata, "\r\n",false);
int something=aisdata.find(p.aieditline);
if(something>-1)
{
aisdata.remove_at(something);
aisdata.insert_at(something,aitext);
file_put_contents("ais/"+p.aitoedit, linear(aisdata),250);
for(uint i2=0;i2<ais.length();i2++)
{
if (ais[i2].voice!="" and ais[i2].rapidvoice==true) destroy_moving_sound(ais[i2].voice);
ais.remove_at(i2);
continue;
}
load_ais();
send_reliable(p,"done",2);
}
}
else if(parsed[0]=="removeai" and parsed.length()>=1)
{
if(parsed[1]=="back")
{
p.sendpacket("canceled", 0);
return;
}
file_delete("ais/"+parsed[1]+"");
send_reliable(p,"done",2);
}
else if(parsed[0]=="removeailine" and parsed.length()>=1)
{
if(parsed[1]=="back")
{
p.sendpacket("canceled", 0);
return;
}
p.aitoremove=parsed[1];
server_menu m;
m.intro="Select the line that you'd like to remove";
m.initial_packet="airemovelinetext";
file f;
f.open("ais/"+parsed[1],"rb");
string[] lines=string_split(f.read(),"\r\n",true);
f.close();
for(uint i=0; i<lines.length(); i++)
{
if(string_contains(lines[i],"=",1)<0)
{
send_reliable(p,"error: all ai commands take at least one argument, got "+lines[i]+"",2);
return;
}
m.add(lines[i],lines[i]);
}
m.send(p.peer_id);
}
else if(parsed[0]=="airemoveline" and parsed.length()>1)
{
if(parsed[1]=="back")
{
p.sendpacket("canceled", 0);
return;
}
string aitext=string_replace(get_event_message(),"airemoveline ","",false);
f.open("ais/"+p.aitoremove,"rb");
string aidata=f.read();
f.close();
string[] aisdata=string_split(aidata, "\r\n",false);
int something=aisdata.find(p.airemoveline);
if(something>-1)
{
aisdata.remove_at(something);
file_put_contents("ais/"+p.aitoremove, linear(aisdata),250);
for(uint i2=0;i2<ais.length();i2++)
{
if (ais[i2].voice!="" and ais[i2].rapidvoice==true) destroy_moving_sound(ais[i2].voice);
ais.remove_at(i2);
continue;
}
load_ais();
send_reliable(p,"done",2);
}
}
else if(parsed[0]=="drawsoundseditline" and parsed.length()>1)
{
if(parsed[1]=="back")
{
p.sendpacket("canceled", 0);
return;
}
string drawsoundstext=string_replace(get_event_message(),"drawsoundseditline ","",false);
f.open("drawsounds.svr","rb");
string drawsoundsdata=f.read();
f.close();
string[] drawsoundssdata=string_split(drawsoundsdata, "\r\n",false);
int something=drawsoundssdata.find(p.drawsoundseditline);
if(something>-1)
{
drawsoundssdata.remove_at(something);
drawsoundssdata.insert_at(something,drawsoundstext);
file_put_contents("drawsounds.svr", linear(drawsoundssdata),250);
send_reliable(p,"done",2);
}
}
else if(parsed[0]=="drawsoundsremoveline" and parsed.length()>1)
{
if(parsed[1]=="back")
{
p.sendpacket("canceled", 0);
return;
}
string drawsoundstext=string_replace(get_event_message(),"drawsoundsremoveline ","",false);
f.open("drawsounds.svr","rb");
string drawsoundsdata=f.read();
f.close();
string[] drawsoundssdata=string_split(drawsoundsdata, "\r\n",false);
int something=drawsoundssdata.find(p.drawsoundsremoveline);
if(something>-1)
{
drawsoundssdata.remove_at(something);
file_put_contents("drawsounds.svr", linear(drawsoundssdata),250);
send_reliable(p,"done",2);
}
}
else if(parsed[0]=="itemusagelimiteditline" and parsed.length()>1)
{
if(parsed[1]=="back")
{
p.sendpacket("canceled", 0);
return;
}
string itemusagelimittext=string_replace(get_event_message(),"itemusagelimiteditline ","",false);
f.open("notadg.svr","rb");
string itemusagelimitdata=f.read();
f.close();
string[] itemusagelimitsdata=string_split(itemusagelimitdata, "\r\n",false);
int something=itemusagelimitsdata.find(p.itemusagelimiteditline);
if(something>-1)
{
itemusagelimitsdata.remove_at(something);
itemusagelimitsdata.insert_at(something,itemusagelimittext);
file_put_contents("notadg.svr", linear(itemusagelimitsdata),250);
send_reliable(p,"done",2);
}
}
else if(parsed[0]=="itemusagelimitremoveline" and parsed.length()>1)
{
if(parsed[1]=="back")
{
p.sendpacket("canceled", 0);
return;
}
string itemusagelimittext=string_replace(get_event_message(),"itemusagelimitremoveline ","",false);
f.open("notadg.svr","rb");
string itemusagelimitdata=f.read();
f.close();
string[] itemusagelimitsdata=string_split(itemusagelimitdata, "\r\n",false);
int something=itemusagelimitsdata.find(p.itemusagelimitremoveline);
if(something>-1)
{
itemusagelimitsdata.remove_at(something);
file_put_contents("notadg.svr", linear(itemusagelimitsdata),250);
send_reliable(p,"done",2);
}
}
else if(parsed[0]=="editfad" and parsed.length()>=1)
{
if(parsed[1]=="back")
{
p.sendpacket("canceled", 0);
return;
}
file_put_contents("foods_and_drinks/"+p.fadtoedit, string_replace(get_event_message(),parsed[0]+" ","",true),250);
send_reliable(p,"done",2);
}
else if(parsed[0]=="removefad" and parsed.length()>1)
{
if(parsed[1]=="back")
{
p.sendpacket("canceled", 0);
return;
}
file_delete("foods_and_drinks/"+parsed[1]);
send_reliable(p,"done",2);
}
else if(parsed[0]=="getsnow" and parsed.length()>=1)
{
if(p.gettimer.elapsed>=1000)
{
p.gettimer.restart();
send_packet(6,"play getsnow.ogg "+p.x+" "+p.y+" "+p.z, p.x,p.y,p.z,maps[get_map_index(p.map)]);
p.inv_add_item("snow",1);
}
}
else if(parsed[0]=="getgrass" and parsed.length()>=1)
{
if(p.gettimer.elapsed>=1000)
{
p.gettimer.restart();
send_packet(6,"play getgrass.ogg "+p.x+" "+p.y+" "+p.z, p.x,p.y,p.z,maps[get_map_index(p.map)]);
p.inv_add_item("grass",1);
}
}
else if(parsed[0]=="getweed" and parsed.length()>=1)
{
if(p.gettimer.elapsed>=1000)
{
p.gettimer.restart();
send_packet(6,"play getweed.ogg "+p.x+" "+p.y+" "+p.z, p.x,p.y,p.z,maps[get_map_index(p.map)]);
p.inv_add_item("weed",1);
}
}
else if(parsed[0]=="getstone" and parsed.length()>=1)
{
if(p.gettimer.elapsed>=1000)
{
p.gettimer.restart();
send_packet(6,"play getstone.ogg "+p.x+" "+p.y+" "+p.z, p.x,p.y,p.z,maps[get_map_index(p.map)]);
p.inv_add_item("stone",1);
}
}
else if(parsed[0]=="getdirt" and parsed.length()>=1)
{
if(p.gettimer.elapsed>=1000)
{
p.gettimer.restart();
send_packet(6,"play getdirt.ogg "+p.x+" "+p.y+" "+p.z, p.x,p.y,p.z,maps[get_map_index(p.map)]);
p.inv_add_item("dirt",1);
}
}
else if(parsed[0]=="getgravel" and parsed.length()>=1)
{
if(p.gettimer.elapsed>=1000)
{
p.gettimer.restart();
send_packet(6,"play getgravel.ogg "+p.x+" "+p.y+" "+p.z, p.x,p.y,p.z,maps[get_map_index(p.map)]);
p.inv_add_item("gravel",1);
}
}
else if(parsed[0]=="getclay" and parsed.length()>=1)
{
if(p.gettimer.elapsed>=1000)
{
p.gettimer.restart();
send_packet(6,"play getclay.ogg "+p.x+" "+p.y+" "+p.z, p.x,p.y,p.z,maps[get_map_index(p.map)]);
p.inv_add_item("clay",1);
}
}
else if(parsed[0]=="getglass" and parsed.length()>=1)
{
if(p.gettimer.elapsed>=1000)
{
p.gettimer.restart();
send_packet(6,"play getglass.ogg "+p.x+" "+p.y+" "+p.z, p.x,p.y,p.z,maps[get_map_index(p.map)]);
p.inv_add_item("glass",1);
}
}
else if(parsed[0]=="getbranch" and parsed.length()>=1)
{
if(p.gettimer.elapsed>=1000)
{
p.gettimer.restart();
send_packet(6,"play getbranch.ogg "+p.x+" "+p.y+" "+p.z, p.x,p.y,p.z,maps[get_map_index(p.map)]);
p.inv_add_item("branch",1);
}
}
else if(parsed[0]=="getsand" and parsed.length()>=1)
{
if(p.gettimer.elapsed>=1000)
{
p.gettimer.restart();
send_packet(6,"play getsand.ogg "+p.x+" "+p.y+" "+p.z, p.x,p.y,p.z,maps[get_map_index(p.map)]);
p.inv_add_item("sand",1);
}
}
else if(parsed[0]=="getmud" and parsed.length()>=1)
{
if(p.gettimer.elapsed>=1000)
{
p.gettimer.restart();
send_packet(6,"play getmud.ogg "+p.x+" "+p.y+" "+p.z, p.x,p.y,p.z,maps[get_map_index(p.map)]);
p.inv_add_item("mud",1);
}
}
else if(parsed[0]=="getice" and parsed.length()>=1)
{
if(p.gettimer.elapsed>=1000)
{
p.gettimer.restart();
send_packet(6,"play getice.ogg "+p.x+" "+p.y+" "+p.z, p.x,p.y,p.z,maps[get_map_index(p.map)]);
p.inv_add_item("ice",1);
}
}
else if(parsed[0]=="getleaves" and parsed.length()>=1)
{
if(p.gettimer.elapsed>=1000)
{
p.gettimer.restart();
send_packet(6,"play getleaves.ogg "+p.x+" "+p.y+" "+p.z, p.x,p.y,p.z,maps[get_map_index(p.map)]);
p.inv_add_item("leaves",1);
}
}
else if(parsed[0]=="getrocks" and parsed.length()>=1)
{
if(p.gettimer.elapsed>=1000)
{
p.gettimer.restart();
send_packet(6,"play getrocks.ogg "+p.x+" "+p.y+" "+p.z, p.x,p.y,p.z,maps[get_map_index(p.map)]);
p.inv_add_item("rocks",1);
}
}
else if(parsed[0]=="getwood" and parsed.length()>=1)
{
if(p.gettimer.elapsed>=1000)
{
p.gettimer.restart();
send_packet(6,"play getwood.ogg "+p.x+" "+p.y+" "+p.z, p.x,p.y,p.z,maps[get_map_index(p.map)]);
p.inv_add_item("wood",1);
}
}
else if(parsed[0]=="getmetal" and parsed.length()>=1)
{
if(p.gettimer.elapsed>=1000)
{
p.gettimer.restart();
send_packet(6,"play getmedal.ogg "+p.x+" "+p.y+" "+p.z, p.x,p.y,p.z,maps[get_map_index(p.map)]);
p.inv_add_item("metal",1);
}
}
else if(parsed[0]=="burnhand" and parsed.length()>=1)
{
if(is_on_fire(p.x,p.y,p.z,maps[get_map_index(p.map)]) and p.gettimer.elapsed>=1000)
{
p.gettimer.restart();
p.health-=random(20,500);
send_packet(6,"play v"+string_to_number(p.voice)+"hit"+random(1,5)+".ogg "+p.x+" "+p.y+" "+p.z,p.x,p.y,p.z,maps[get_map_index(p.map)]);
send_reliable(p,"oopss, you've burned your hand!",2);
}
}
else if(parsed[0]=="getmmetal" and parsed.length()>=1)
{
if(p.gettimer.elapsed>=1000)
{
p.gettimer.restart();
p.inv_add_item("metal",1);
}
}
else if(parsed[0]=="getwwood" and parsed.length()>=1)
{
if(p.gettimer.elapsed>=1000)
{
p.gettimer.restart();
p.inv_add_item("wood",1);
}
}
else if(parsed[0]=="turretclip" and parsed.length()>=1)
{
for(uint i=0; i<turrets.length(); i++)
{
if(p.x==turrets[i].x and p.y==turrets[i].y and p.z==turrets[i].z and p.map==turrets[i].map.name)
{
if(turrets[i].clipsize>=1)
{
send_reliable(p, "this turret is already loaded.", 0);
}
else
{
send_packet(6,"play turretreload.ogg "+p.x+" "+p.y+" "+p.z, p.x,p.y,p.z,maps[get_map_index(p.map)]);
turrets[i].clipsize+=100;
p.inv_add_item("turret_cartridge",-1);
}
}
}
}
else if(parsed[0]=="turretbattery" and parsed.length()>=1)
{
for(uint i=0; i<turrets.length(); i++)
{
if(p.x==turrets[i].x and p.y==turrets[i].y and p.z==turrets[i].z and p.map==turrets[i].map.name)
{
if(turrets[i].chargelevel>=500)
{
send_reliable(p, "this turret is fully charged.", 0);
}
else
{
send_packet(6,"play turretbattery.ogg "+p.x+" "+p.y+" "+p.z, p.x,p.y,p.z,maps[get_map_index(p.map)]);
turrets[i].chargelevel+=30;
p.inv_add_item("turret_battery",-1);
}
}
}
}
else if(parsed[0]=="turret" and parsed.length()>=1)
{
send_packet(6,"play turretplace.ogg "+p.x+" "+p.y+" "+p.z, p.x,p.y,p.z,maps[get_map_index(p.map)]);
send_reliable(p, "stopmoving", 0);
p.turrettimer.restart();
p.turretspawning=true;
p.inv_add_item("turret",-1);
}
else if(parsed[0]=="drinkwater" and parsed.length()>=1)
{
if(p.gettimer.elapsed>=750)
{
p.gettimer.restart();
if(p.nthirst>=2000)
{
p.nthirst=2000;
send_reliable(p,"you are full!",2);
}
else
{
send_packet(6,"play drink"+random(1,3)+".ogg "+p.x+" "+p.y+" "+p.z, p.x,p.y,p.z,maps[get_map_index(p.map)]);
p.thirst-=random(2,10);
p.nthirst+=5;
p.sick+=random(0,1);
}
}
}
else if(parsed[0]=="ammocheck")
{
int ind=get_player_index_from(p.looking);
if(ind>-1)
{
if(players[ind].weapon_copasity<1) send_reliable(p,players[ind].weapon_name+" doesn't need ammo",0);
else send_reliable(p,players[ind].weapon_ammos+" out of "+players[ind].weapon_copasity+" "+players[ind].weapon_ammo_type+" loaded, and "+players[ind].inv_item_number(players[ind].weapon_ammo_type)+" "+players[ind].weapon_ammo_type+" in reserve",0);
}
else
{
if(p.weapon_copasity<1) send_reliable(p,p.weapon_name+" doesn't need ammo",0);
else send_reliable(p,p.weapon_ammos+" out of "+p.weapon_copasity+" "+p.weapon_ammo_type+" loaded, and "+p.inv_item_number(p.weapon_ammo_type)+" "+p.weapon_ammo_type+" in reserve",0);
}
}
else if(parsed[0]=="air")
{
int ind=get_player_index_from(p.looking);
if(ind>-1)
{
if(p.gender==0)p.gender2="him";
else p.gender2="her";
send_reliable(p,""+players[ind].name+" has "+players[ind].air+" air. This should last "+players[ind].gender2+" about "+ms_to_readable_time(players[ind].air*3500),2);
}
else
{
send_reliable(p,"You have "+p.air+" air. This should last you about "+ms_to_readable_time(p.air*3500),2);
}
}
else if(parsed[0]=="sitstand")
{
p.sitting=toggle(p.sitting);
if(p.sitting==1)
{
send_reliable(p, "playfallsound "+p.x+" "+p.y+" "+p.z+" "+p.map, 0);
send_reliable(p,"sitstart",0);
}
else
{
if(p.drunk==true and p.energy<=100)
{
int r=random(-50, 100);
if(r>49)
{
send_reliable(p,"you can't stand up!",0);
send_reliable(p, "playfallsound "+p.x+" "+p.y+" "+p.z+" "+p.map, 0);
}
}
send_packet(6,"play stand"+random(1,2)+".ogg "+p.x+" "+p.y+" "+p.z, p.x,p.y,p.z,maps[get_map_index(p.map)]);
send_reliable(p, "playscuffsound "+p.x+" "+p.y+" "+p.z+" "+p.map, 0);
spawn_timepacket(p.peer_id,"sitstop",0,1000);
}
}
else if(parsed[0]=="packsomething" and parsed.length()>1)
{
if(parsed[1]=="back")
{
send_reliable(p,"Canceled",0);
return;
}
if(string_contains(parsed[1],"coins",1)!=-1 or string_contains(parsed[1],"credit",1)!=-1 or string_contains(parsed[1],"corpse_bomb",1)!=-1 or string_contains(parsed[1],"paid_gift",1)!=-1 or string_contains(parsed[1],"quick_thirst_fix_drug",1)!=-1 or string_contains(parsed[1],"quick_hunger_fix_snack",1)!=-1 or string_contains(parsed[1],"xp_potion",1)>-1 or string_contains(parsed[1],"armor",1)>-1 or string_contains(parsed[1],"safe_card",1)!=-1 or string_contains(parsed[1],"health_box",1)!=-1 or string_contains(parsed[1],"energy_box",1)!=-1 or string_contains(parsed[1],"teleporter",1)!=-1 or string_contains(parsed[1],"nuclear_bomb",1)!=-1 or string_contains(parsed[1],"small_nuclear_bomb",1)>-1 or string_contains(parsed[1],"large_nuclear_bomb",1)>-1)
{
send_reliable(p, "you can't put "+parsed[1]+" in to this pack", 0);
return;
}
string item=parsed[1];
string[] a=string_split(file_get_contents("notadg.svr"),"\r\n",false);
int something=a.find(item);
if(something>-1)
{
send_reliable(p,"You can't put "+item+" in this pack",2);
return;
}
p.inv_add_item(item,-10);
string cid=randomstring(5);
new_corpse(item+"="+10+";",cid);
p.inv_add_item("pack_of_10_"+item+"_"+cid,1);
p.inv_add_item("empty_pack", -1);
send_packet(6,"play giftopen3.ogg "+p.x+" "+p.y+" "+p.z, p.x,p.y,p.z,maps[get_map_index(p.map)]);
send_reliable(p,"You put 10 "+item+" in a pack and close it",2);
}
else if(parsed[0]=="boxsomething" and parsed.length()>1)
{
if(parsed[1]=="back")
{
send_reliable(p,"Canceled",0);
return;
}
send_serverbox(p.peer_id, 2, -1, 1, -1, "boxitems/"+parsed[1],"how much of "+parsed[1]+" would you like to put on this box?");
}
else if(parsed[0]=="skilletsomething" and parsed.length()>1)
{
if(parsed[1]=="back")
{
send_reliable(p,"Canceled",0);
return;
}
string item=parsed[1];
string[] a=string_split(file_get_contents("notadg.svr"),"\r\n",false);
int something=a.find(item);
if(something>-1)
{
send_reliable(p,"You can't put "+item+" in this skillet",2);
return;
}
p.inv_add_item(item,-10);
string cid=randomstring(5);
new_corpse(item+"="+10+";",cid);
p.inv_add_item("skillet_with_10_"+item+"_"+cid,1);
p.inv_add_item("skillet", -1);
send_packet(6,"play getskillet.ogg "+p.x+" "+p.y+" "+p.z, p.x,p.y,p.z,maps[get_map_index(p.map)]);
send_reliable(p,"You put 10 "+item+" in a skillet",2);
}
else if(string_left(parsed[0],9)=="boxitems/" and parsed.length>1)
{
if(parsed[1]=="[cncel]") return;
double amount=string_to_number(parsed[1]);
parsed=string_split(parsed[0],"/",false);
if (p.inv_item_number(parsed[1])>=amount)
{
if(amount<=0)
{
send_reliable(p,"An error has occured",0);
return;
}
string[] a=string_split(file_get_contents("notadg.svr"),"\r\n",false);
int something=a.find(parsed[1]);
if(something>-1)
{
send_reliable(p,"You can't put "+parsed[1]+" in this box",2);
return;
}
p.inv_add_item(parsed[1],-amount);
string cid=randomstring(5);
new_corpse(parsed[1]+"="+amount+";",cid);
p.inv_add_item("box_of_"+amount+"_"+parsed[1]+"_"+cid,1);
p.inv_add_item("box", -1);
send_packet(6,"play giftopen3.ogg "+p.x+" "+p.y+" "+p.z, p.x,p.y,p.z,maps[get_map_index(p.map)]);
send_reliable(p,"You put "+amount+" "+parsed[1]+" in a box and close it",2);
}
}
else if(parsed[0]=="ttlp")
{
string[] a=find_files("maptlps/*.map");
string m;
for(uint i=0;i<a.length();i++)
{
if(i<a.length()) m+=a[i]+"\r\n";
else if(i==a.length()-1) m+=a[i];
}
send_reliable(p, "tlptester "+m, 0);
}
else if(parsed[0]=="serverstats")
{
string received=convert_size(n.bytes_received);
string sent=convert_size(n.bytes_sent);
string totalreceived=convert_size(n.bytes_sent+n.bytes_received);
int peers=n.get_peer_list().length();
string[] chars=find_directories("chars/*");
double finalms=0;
for(uint i=0; i<chars.length(); i++)
{
if(file_exists("chars/"+chars[i]+"/playtime.usr"))
finalms+=string_to_number(get_char_val(chars[i],"playtime"));
}
send_reliable(p,"Server Stats: There are "+peers+" connected peers, with "+received+" received, and "+sent+" sent, Total: "+totalreceived+". Peak: "+peak+". Reached on: "+peakreached+". Everyone's combined playtime is "+ms_to_readable_time(finalms)+". "+connections+" Connections, and "+disconnections+" disconnections",2);
}
else if(parsed[0]=="addsrc")
{
string maptext=string_replace(get_event_message(),"addsrc ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="addopening_hours")
{
string maptext=string_replace(get_event_message(),"addopening_hours ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="addlevel")
{
string maptext=string_replace(get_event_message(),"addlevel ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="addreinforcement")
{
string maptext=string_replace(get_event_message(),"addreinforcement ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="addmusic")
{
string maptext=string_replace(get_event_message(),"addmusic ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="addvending_machine" and p.is_admin())
{
string maptext=string_replace(get_event_message(),"addvending_machine ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="addcheckpoint")
{
string maptext=string_replace(get_event_message(),"addcheckpoint ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="addowner")
{
string maptext=string_replace(get_event_message(),"addowner ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
string maptxt=string_replace(get_event_message(),"addowner owner:","",false);
if(string_contains(p.map,"house_of_",1)<0) file_put_contents("chars/"+maptxt+"/maps.usr",""+p.map+"\r\n",255);
}
else if(parsed[0]=="addline")
{
string maptext=string_replace(get_event_message(),"addline ","",false);
string[] lines=string_split(maptext,"\r\n",false);
for(uint i=0; i<lines.length(); i++)
{
if(string_contains(lines[i],":",1)<0)
{
send_reliable(p,"error: all map commands take at least one argument, got "+lines[i]+"",2);
return;
}
}
string[] ld=string_split(maptext,":",false);
if(ld.length<1)
{
send_reliable(p,"maps update error: all map commands take at least one argument",0);
return;
}
else if(ld[0]=="mapname" and ld[1]!=p.map)
{
send_reliable(p,"maps update error: map names do not match",0);
return;
}
else if(ld[0]=="item" and ld.length<10)
{
send_reliable(p,"maps update error: item spawn declaration has too few arguments. Syntax is item:minx:maxx:miny:maxy:minz:maxz:time:maxobjs:objs:amount, got "+maptext,0);
return;
}
else if(ld[0]=="challenge_status" and ld.length<9)
{
send_reliable(p,"maps update error: challenge status spawn declaration has too few arguments. Syntax is challenge_status:minX:maxX:minY:maxY:minZ:maxZ:item:amount, got "+maptext,0);
return;
}
else if(ld[0]=="pvp" and ld.length<8)
{
send_reliable(p,"maps update error: pvp spawn declaration has too few arguments. Syntax is pvp:minX:maxX:minY:maxY:minZ:maxZ:pvpStatus, got "+maptext,0);
return;
}
else if(ld[0]=="specified_air_temperature" and ld.length<8)
{
send_reliable(p,"maps update error: specified air temperature spawn declaration has too few arguments. Syntax is challenge_status:minX:maxX:minY:maxY:minZ:maxZ:specified_air_temperature, got "+maptext,0);
return;
}

else if(ld[0]=="item_usage_restriction" and ld.length<8)
{
send_reliable(p,"maps update error: item usage restriction spawn declaration has too few arguments. Syntax is item_usage_restriction:minx:maxx:miny:maxy:minz:maxz:items, got "+maptext,0);
return;
}
else if(ld[0]=="fishingcoordinate" and ld.length<6)
{
send_reliable(p,"maps update error: declaration of fishing coordinate has too few arguments. Syntax is fishingcoordinate:minx:maxx:miny:maxy:minz:maxz, got "+maptext,0);
return;
}
else if(ld[0]=="ai" and p.is_admin()==false)
{
return;
}
else if(ld[0]=="item" and p.is_admin()==false)
{
return;
}
else if(ld[0]=="challenge_status" and p.is_admin()==false)
{
return;
}
else if(ld[0]=="vending_machine" and p.is_admin()==false)
{
return;
}
else if(ld[0]=="fishing_coordinate" and p.is_admin()==false)
{
return;
}
else if(ld[0]=="toilet" and ld.length<6)
{
send_reliable(p,"maps update error: declaration of toilet has too few arguments. Syntax is toilet:minx:maxx:miny:maxy:minz:maxz, got "+maptext,0);
return;
}
else if(ld[0]=="trashcan" and ld.length<6)
{
send_reliable(p,"maps update error: declaration of trashcan has too few arguments. Syntax is trashcan:minx:maxx:miny:maxy:minz:maxz, got "+maptext,0);
return;
}
else if(ld[0]=="bed" and ld.length<6)
{
send_reliable(p,"maps update error: declaration of bed has too few arguments. Syntax is bed:minx:maxx:miny:maxy:minz:maxz, got "+maptext,0);
return;
}
else if(ld[0]=="clock" and ld.length<6)
{
send_reliable(p,"maps update error: declaration of clock has too few arguments. Syntax is clock:minx:maxx:miny:maxy:minz:maxz:optional_text, got "+maptext,0);
return;
}
else if(ld[0]=="calendar" and ld.length<6)
{
send_reliable(p,"maps update error: declaration of calendar has too few arguments. Syntax is calendar:minx:maxx:miny:maxy:minz:maxz:optional_text, got "+maptext,0);
return;
}
else if(ld[0]=="oven" and ld.length<6)
{
send_reliable(p,"maps update error: declaration of oven has too few arguments. Syntax is oven:minx:maxx:miny:maxy:minz:maxz, got "+maptext,0);
return;
}
else if(ld[0]=="starting_point" and ld.length<6)
{
send_reliable(p,"maps update error: declaration of starting_point has too few arguments. Syntax is starting_point:minx:maxx:miny:maxy:minz:maxz, got "+maptext,0);
return;
}
else if(ld[0]=="deathpoint" and ld.length<6)
{
send_reliable(p,"maps update error: declaration of deathpoint has too few arguments. Syntax is deathpoint:minx:maxx:miny:maxy:minz:maxz, got "+maptext,0);
return;
}
else if(ld[0]=="washbasin" and ld.length<6)
{
send_reliable(p,"maps update error: declaration of washbasin has too few arguments. Syntax is washbasin:minx:maxx:miny:maxy:minz:maxz, got "+maptext,0);
return;
}
else if(ld[0]=="shower" and ld.length<6)
{
send_reliable(p,"maps update error: declaration of shower has too few arguments. Syntax is shower:minx:maxx:miny:maxy:minz:maxz, got "+maptext,0);
return;
}
else if(ld[0]=="travelpoint" and ld.length<12)
{
send_reliable(p,"maps update error: travelpoint declaration has too few arguments. Syntax is travelpoint:minx:maxx:miny:maxy:minz:maxz:newmap:newx:newy:newz:text:extra_functions, got "+maptext,0);
return;
}
else if(ld[0]=="tile" and ld.length<10)
{
send_reliable(p,"maps update error: declaration of tile has too few arguments. Syntax is tile:minx:maxx:miny:maxy:minz:maxz:volume:pitch:type, got "+maptext,0);
return;
}
else if(ld[0]=="zone" and ld.length<8)
{
send_reliable(p,"maps update error: declaration of zone has too few arguments. Syntax is zone:minx:maxx:miny:maxy:minz:maxz:text[:trackme], got "+maptext,0);
return;
}
else if((string_contains(maptext,"_store",1)>-1 or string_contains(maptext,"bank_service_desk",1)>-1 or string_contains(maptext,"cash_machine",1)>-1 or string_contains(maptext,"cash_miner",1)>-1 or string_contains(maptext,"civil registry office",1)>-1 or string_contains(maptext,"entertainment_center",1)>-1 or string_contains(maptext,"employment_agency",1)>-1 or string_contains(maptext,"cemetery",1)>-1) and p.is_admin()==false)
{
send_reliable(p,"maps update error: zone declaration is not allowed, got "+maptext,0);
return;
}
else if(ld[0]=="safezone" and ld.length<5)
{
send_reliable(p,"maps update error: declaration of safe zone has too few arguments. Syntax is safezone:minx:maxx:miny:maxy:minz:maxz, got "+maptext,0);
return;
}
else if(ld[0]=="txt" and ld.length<6)
{
send_reliable(p,"maps update error: declaration of txt has too few arguments. Syntax is txt:minx:maxx:miny:maxy:minz:maxz:text, got "+maptext,0);
return;
}
else if(ld[0]=="sign" and ld.length<7)
{
send_reliable(p,"maps update error: declaration of sign has too few arguments. Syntax is sign:minx:maxx:miny:maxy:minz:maxz:text:soundname, got "+maptext,0);
return;
}
else if(ld[0]=="timedtext" and ld.length<8)
{
send_reliable(p,"maps update error: declaration of timed text has too few arguments. Syntax is timedtext:minx:maxx:miny:maxy:minz:maxz:time:text, got "+maptext,0);
return;
}
else if(ld[0]=="vanishing_platform" and ld.length<10)
{
send_reliable(p,"maps update error: declaration of vanishing platform has too few arguments. Syntax is vanishing_platform:min_x:max_x:min_y:max_y:min_z:max_z:time:tile:sound, got "+maptext,0);
return;
}
else if(ld[0]=="forcefield" and ld.length<10)
{
send_reliable(p,"maps update error: declaration of forcefield has too few arguments. Syntax is forcefield:min_x:max_x:min_y:max_y:min_z:max_z:time:health:sound, got "+maptext,0);
return;
}
else if(ld[0]=="checkpoint" and ld.length<4)
{
send_reliable(p,"maps update error: declaration of checkpoint has too few arguments. Syntax is checkpoint:x:y:z, got "+maptext,0);
return;
}
else if(ld[0]=="hazard" and ld.length<7)
{
send_reliable(p,"maps update error: declaration of hazard has too few arguments. Syntax is hazard:min_x:max_x:min_y:max_y:min_z:max_z, got "+maptext,0);
return;
}
else if(ld[0]=="teleporter" and ld.length<7)
{
send_reliable(p,"maps update error: declaration of teleporter has too few arguments. Syntax is teleporter:min_x:max_x:min_y:max_y:min_z:max_z, got "+maptext,0);
return;
}
else if(ld[0]=="door" and ld.length<16)
{
send_reliable(p,"maps update error: declaration of door has too few arguments. Syntax is door:min_x:max_x:min_y:max_y:min_z:max_z:finish_x:finish_y:finish_z:text:speed:loop:moveloop:opensound:closesound, got "+maptext,0);
return;
}
else if(ld[0]=="pdoor" and ld.length<17)
{
send_reliable(p,"maps update error: declaration of password protected door has too few arguments. Syntax is door:min_x:max_x:min_y:max_y:min_z:max_z:finish_x:finish_y:finish_z:text_when_player_wants_to_enter_the_password:password:speed:loop:moveloop:opensound:closesound, got "+maptext,0);
return;
}
else if(ld[0]=="icdoor" and ld.length<18)
{
send_reliable(p,"maps update error: declaration of item checker door has too few arguments. Syntax is door:min_x:max_x:min_y:max_y:min_z:max_z:finish_x:finish_y:finish_z:text_when_player_wants_to_enter_the_password:item:amount:speed:loop:moveloop:opensound:closesound, got "+maptext,0);
return;
}
else if(ld[0]=="itdoor" and ld.length<18)
{
send_reliable(p,"maps update error: declaration of item taker door has too few arguments. Syntax is door:min_x:max_x:min_y:max_y:min_z:max_z:finish_x:finish_y:finish_z:text_when_player_wants_to_enter_the_password:item:amount:speed:loop:moveloop:opensound:closesound, got "+maptext,0);
return;
}
else if(ld[0]=="igdoor" and ld.length<18)
{
send_reliable(p,"maps update error: declaration of item giver door has too few arguments. Syntax is door:min_x:max_x:min_y:max_y:min_z:max_z:finish_x:finish_y:finish_z:text_when_player_wants_to_enter_the_password:item:amount:speed:loop:moveloop:opensound:closesound, got "+maptext,0);
return;
}
else if(ld[0]=="igdoor" and p.is_admin()==false)
{
return;
}
else if(ld[0]=="automover" and ld.length<16)
{
send_reliable(p,"maps update error: declaration of automover has too few arguments. Syntax is automover:min_x:max_x:min_y:max_y:min_z:max_z:finish_x:finish_y:finish_z:text:speed:loop:moveloop:opensound:closesound, got "+maptext,0);
return;
}
else if(ld[0]=="pautomover" and ld.length<17)
{
send_reliable(p,"maps update error: declaration of password protected automover has too few arguments. Syntax is automover:min_x:max_x:min_y:max_y:min_z:max_z:finish_x:finish_y:finish_z:text_when_player_wants_to_enter_the_password:password:speed:loop:moveloop:opensound:closesound, got "+maptext,0);
return;
}
else if(ld[0]=="icautomover" and ld.length<18)
{
send_reliable(p,"maps update error: declaration of item checker automover has too few arguments. Syntax is automover:min_x:max_x:min_y:max_y:min_z:max_z:finish_x:finish_y:finish_z:text_when_player_wants_to_enter_the_password:item:amount:speed:loop:moveloop:opensound:closesound, got "+maptext,0);
return;
}
else if(ld[0]=="itautomover" and ld.length<18)
{
send_reliable(p,"maps update error: declaration of item taker automover has too few arguments. Syntax is automover:min_x:max_x:min_y:max_y:min_z:max_z:finish_x:finish_y:finish_z:text_when_player_wants_to_enter_the_password:item:amount:speed:loop:moveloop:opensound:closesound, got "+maptext,0);
return;
}
else if(ld[0]=="igautomover" and ld.length<18)
{
send_reliable(p,"maps update error: declaration of item giver automover has too few arguments. Syntax is automover:min_x:max_x:min_y:max_y:min_z:max_z:finish_x:finish_y:finish_z:text_when_player_wants_to_enter_the_password:item:amount:speed:loop:moveloop:opensound:closesound, got "+maptext,0);
return;
}
else if(ld[0]=="igautomover" and p.is_admin()==false)
{
return;
}
else if(ld[0]=="automatic_travelpoint" and ld.length<15)
{
send_reliable(p,"maps update error: declaration of automatic_travelpoint has too few arguments. Syntax is automatic_travelpoint:min_x:max_x:min_y:max_y:min_z:max_z:map:finish_x:finish_y:finish_z:text:loop:opensound:closesound, got "+maptext,0);
return;
}
else if(ld[0]=="pautomatic_travelpoint" and ld.length<16)
{
send_reliable(p,"maps update error: declaration of password protected automatic_travelpoint has too few arguments. Syntax is automatic_travelpoint:min_x:max_x:min_y:max_y:min_z:max_z:map:finish_x:finish_y:finish_z:text_when_player_wants_to_enter_the_password:password:loop:opensound:closesound, got "+maptext,0);
return;
}
else if(ld[0]=="icautomatic_travelpoint" and ld.length<17)
{
send_reliable(p,"maps update error: declaration of item checker automatic_travelpoint has too few arguments. Syntax is automatic_travelpoint:min_x:max_x:min_y:max_y:min_z:max_z:map:finish_x:finish_y:finish_z:text_when_player_wants_to_enter_the_password:item:amount:loop:opensound:closesound, got "+maptext,0);
return;
}
else if(ld[0]=="itautomatic_travelpoint" and ld.length<17)
{
send_reliable(p,"maps update error: declaration of item taker automatic_travelpoint has too few arguments. Syntax is automatic_travelpoint:min_x:max_x:min_y:max_y:min_z:max_z:map:finish_x:finish_y:finish_z:text_when_player_wants_to_enter_the_password:item:amount:loop:opensound:closesound, got "+maptext,0);
return;
}
else if(ld[0]=="igautomatic_travelpoint" and ld.length<17)
{
send_reliable(p,"maps update error: declaration of item giver automatic_travelpoint has too few arguments. Syntax is automatic_travelpoint:min_x:max_x:min_y:max_y:min_z:max_z:map:finish_x:finish_y:finish_z:text_when_player_wants_to_enter_the_password:item:amount:loop:opensound:closesound, got "+maptext,0);
return;
}
else if(ld[0]=="igautomatic_travelpoint" and p.is_admin()==false)
{
return;
}
else if(ld[0]=="travelpoint" and ld.length<15)
{
send_reliable(p,"maps update error: declaration of travelpoint has too few arguments. Syntax is travelpoint:min_x:max_x:min_y:max_y:min_z:max_z:map:finish_x:finish_y:finish_z:text:loop:opensound:closesound, got "+maptext,0);
return;
}
else if(ld[0]=="ptravelpoint" and ld.length<16)
{
send_reliable(p,"maps update error: declaration of password protected travelpoint has too few arguments. Syntax is travelpoint:min_x:max_x:min_y:max_y:min_z:max_z:map:finish_x:finish_y:finish_z:text_when_player_wants_to_enter_the_password:password:loop:opensound:closesound, got "+maptext,0);
return;
}
else if(ld[0]=="ictravelpoint" and ld.length<17)
{
send_reliable(p,"maps update error: declaration of item checker travelpoint has too few arguments. Syntax is travelpoint:min_x:max_x:min_y:max_y:min_z:max_z:map:finish_x:finish_y:finish_z:text_when_player_wants_to_enter_the_password:item:amount:loop:opensound:closesound, got "+maptext,0);
return;
}
else if(ld[0]=="ittravelpoint" and ld.length<17)
{
send_reliable(p,"maps update error: declaration of item taker travelpoint has too few arguments. Syntax is travelpoint:min_x:max_x:min_y:max_y:min_z:max_z:map:finish_x:finish_y:finish_z:text_when_player_wants_to_enter_the_password:item:amount:loop:opensound:closesound, got "+maptext,0);
return;
}
else if(ld[0]=="igtravelpoint" and ld.length<17)
{
send_reliable(p,"maps update error: declaration of item giver travelpoint has too few arguments. Syntax is travelpoint:min_x:max_x:min_y:max_y:min_z:max_z:map:finish_x:finish_y:finish_z:text_when_player_wants_to_enter_the_password:item:amount:loop:opensound:closesound, got "+maptext,0);
return;
}
else if(ld[0]=="igtravelpoint" and p.is_admin()==false)
{
return;
}
else if(ld[0]=="src" and ld.length<10)
{
send_reliable(p,"maps update error: declaration of source has too few arguments. Syntax is src:minx:maxx:miny:maxy:minz:maxz:volume:pitch:loop.ogg[:id], got "+maptext,0);
return;
}
else if(ld[0]=="music" and ld.length<10)
{
send_reliable(p,"maps update error: declaration of music has too few arguments. Syntax is music:minx:maxx:miny:maxy:minz:maxz:volume:pitch:loop.ogg[:id], got "+maptext,0);
return;
}
else if(ld[0]=="timedsound" and ld.length<10)
{
send_reliable(p,"maps update error: declaration of timed sound has too few arguments. Syntax is timedsound:minx:maxx:miny:maxy:minz:maxz:time:volume:pitch:soundname, got "+maptext,0);
return;
}
else if(ld[0]=="timedmusic" and ld.length<10)
{
send_reliable(p,"maps update error: declaration of timed music has too few arguments. Syntax is timedmusic:minx:maxx:miny:maxy:minz:maxz:time:volume:pitch:musicname, got "+maptext,0);
return;
}
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="addeditline")
{
string maptext=string_replace(get_event_message(),"addeditline ","",false);
string[] ld=string_split(maptext,":",false);
if(ld.length<1)
{
send_reliable(p,"maps update error: all map commands take at least one argument",0);
return;
}
else if(ld[0]=="mapname" and ld[1]!=p.map)
{
send_reliable(p,"maps update error: map names do not match",0);
return;
}
else if(ld[0]=="item" and ld.length<10)
{
send_reliable(p,"maps update error: item spawn declaration has too few arguments. Syntax is item:minx:maxx:miny:maxy:minz:maxz:time:maxobjs:objs:amount, got "+maptext,0);
return;
}
else if(ld[0]=="challenge_status" and ld.length<9)
{
send_reliable(p,"maps update error: challenge status spawn declaration has too few arguments. Syntax is challenge_status:minX:maxX:minY:maxY:minZ:maxZ:item:amount, got "+maptext,0);
return;
}
else if(ld[0]=="pvp" and ld.length<8)
{
send_reliable(p,"maps update error: pvp spawn declaration has too few arguments. Syntax is pvp:minX:maxX:minY:maxY:minZ:maxZ:pvpStatus, got "+maptext,0);
return;
}
else if(ld[0]=="specified_air_temperature" and ld.length<8)
{
send_reliable(p,"maps update error: specified air temperature spawn declaration has too few arguments. Syntax is challenge_status:minX:maxX:minY:maxY:minZ:maxZ:specified_air_temperature, got "+maptext,0);
return;
}
else if(ld[0]=="item_usage_restriction" and ld.length<8)
{
send_reliable(p,"maps update error: item usage restriction spawn declaration has too few arguments. Syntax is item_usage_restriction:minx:maxx:miny:maxy:minz:maxz:items, got "+maptext,0);
return;
}
else if(ld[0]=="fishingcoordinate" and ld.length<6)
{
send_reliable(p,"maps update error: declaration of fishing coordinate has too few arguments. Syntax is fishingcoordinate:minx:maxx:miny:maxy:minz:maxz, got "+maptext,0);
return;
}
else if(ld[0]=="ai" and p.is_admin()==false)
{
return;
}
else if(ld[0]=="item" and p.is_admin()==false)
{
return;
}
else if(ld[0]=="challenge_status" and p.is_admin()==false)
{
return;
}
else if(ld[0]=="vending_machine" and p.is_admin()==false)
{
return;
}
else if(ld[0]=="fishing_coordinate" and p.is_admin()==false)
{
return;
}
else if(ld[0]=="toilet" and ld.length<6)
{
send_reliable(p,"maps update error: declaration of toilet has too few arguments. Syntax is toilet:minx:maxx:miny:maxy:minz:maxz, got "+maptext,0);
return;
}
else if(ld[0]=="trashcan" and ld.length<6)
{
send_reliable(p,"maps update error: declaration of trashcan has too few arguments. Syntax is trashcan:minx:maxx:miny:maxy:minz:maxz, got "+maptext,0);
return;
}
else if(ld[0]=="bed" and ld.length<6)
{
send_reliable(p,"maps update error: declaration of bed has too few arguments. Syntax is bed:minx:maxx:miny:maxy:minz:maxz, got "+maptext,0);
return;
}
else if(ld[0]=="clock" and ld.length<6)
{
send_reliable(p,"maps update error: declaration of clock has too few arguments. Syntax is clock:minx:maxx:miny:maxy:minz:maxz:optional_text, got "+maptext,0);
return;
}
else if(ld[0]=="calendar" and ld.length<6)
{
send_reliable(p,"maps update error: declaration of calendar has too few arguments. Syntax is calendar:minx:maxx:miny:maxy:minz:maxz:optional_text, got "+maptext,0);
return;
}
else if(ld[0]=="oven" and ld.length<6)
{
send_reliable(p,"maps update error: declaration of oven has too few arguments. Syntax is oven:minx:maxx:miny:maxy:minz:maxz, got "+maptext,0);
return;
}
else if(ld[0]=="starting_point" and ld.length<6)
{
send_reliable(p,"maps update error: declaration of starting_point has too few arguments. Syntax is starting_point:minx:maxx:miny:maxy:minz:maxz, got "+maptext,0);
return;
}
else if(ld[0]=="deathpoint" and ld.length<6)
{
send_reliable(p,"maps update error: declaration of deathpoint has too few arguments. Syntax is deathpoint:minx:maxx:miny:maxy:minz:maxz, got "+maptext,0);
return;
}
else if(ld[0]=="washbasin" and ld.length<6)
{
send_reliable(p,"maps update error: declaration of washbasin has too few arguments. Syntax is washbasin:minx:maxx:miny:maxy:minz:maxz, got "+maptext,0);
return;
}
else if(ld[0]=="shower" and ld.length<6)
{
send_reliable(p,"maps update error: declaration of shower has too few arguments. Syntax is shower:minx:maxx:miny:maxy:minz:maxz, got "+maptext,0);
return;
}
else if(ld[0]=="travelpoint" and ld.length<12)
{
send_reliable(p,"maps update error: travelpoint declaration has too few arguments. Syntax is travelpoint:minx:maxx:miny:maxy:minz:maxz:newmap:newx:newy:newz:text:extra_functions, got "+maptext,0);
return;
}
else if(ld[0]=="tile" and ld.length<10)
{
send_reliable(p,"maps update error: declaration of tile has too few arguments. Syntax is tile:minx:maxx:miny:maxy:minz:maxz:volume:pitch:type, got "+maptext,0);
return;
}
else if(ld[0]=="zone" and ld.length<8)
{
send_reliable(p,"maps update error: declaration of zone has too few arguments. Syntax is zone:minx:maxx:miny:maxy:minz:maxz:text[:trackme], got "+maptext,0);
return;
}
else if((string_contains(maptext,"_store",1)>-1 or string_contains(maptext,"bank_service_desk",1)>-1 or string_contains(maptext,"cash_machine",1)>-1 or string_contains(maptext,"cash_miner",1)>-1 or string_contains(maptext,"civil registry office",1)>-1 or string_contains(maptext,"entertainment_center",1)>-1 or string_contains(maptext,"employment_agency",1)>-1 or string_contains(maptext,"cemetery",1)>-1) and p.is_admin()==false)
{
send_reliable(p,"maps update error: zone declaration is not allowed, got "+maptext,0);
return;
}
else if(ld[0]=="safezone" and ld.length<5)
{
send_reliable(p,"maps update error: declaration of safe zone has too few arguments. Syntax is safezone:minx:maxx:miny:maxy:minz:maxz, got "+maptext,0);
return;
}
else if(ld[0]=="txt" and ld.length<6)
{
send_reliable(p,"maps update error: declaration of txt has too few arguments. Syntax is txt:minx:maxx:miny:maxy:minz:maxz:text, got "+maptext,0);
return;
}
else if(ld[0]=="sign" and ld.length<7)
{
send_reliable(p,"maps update error: declaration of sign has too few arguments. Syntax is sign:minx:maxx:miny:maxy:minz:maxz:text:soundname, got "+maptext,0);
return;
}
else if(ld[0]=="timedtext" and ld.length<8)
{
send_reliable(p,"maps update error: declaration of timed text has too few arguments. Syntax is timedtext:minx:maxx:miny:maxy:minz:maxz:time:text, got "+maptext,0);
return;
}
else if(ld[0]=="vanishing_platform" and ld.length<10)
{
send_reliable(p,"maps update error: declaration of vanishing platform has too few arguments. Syntax is vanishing_platform:min_x:max_x:min_y:max_y:min_z:max_z:time:tile:sound, got "+maptext,0);
return;
}
else if(ld[0]=="forcefield" and ld.length<10)
{
send_reliable(p,"maps update error: declaration of forcefield has too few arguments. Syntax is forcefield:min_x:max_x:min_y:max_y:min_z:max_z:time:health:sound, got "+maptext,0);
return;
}
else if(ld[0]=="checkpoint" and ld.length<4)
{
send_reliable(p,"maps update error: declaration of checkpoint has too few arguments. Syntax is checkpoint:x:y:z, got "+maptext,0);
return;
}
else if(ld[0]=="hazard" and ld.length<7)
{
send_reliable(p,"maps update error: declaration of hazard has too few arguments. Syntax is hazard:min_x:max_x:min_y:max_y:min_z:max_z, got "+maptext,0);
return;
}
else if(ld[0]=="teleporter" and ld.length<7)
{
send_reliable(p,"maps update error: declaration of teleporter has too few arguments. Syntax is teleporter:min_x:max_x:min_y:max_y:min_z:max_z, got "+maptext,0);
return;
}
else if(ld[0]=="door" and ld.length<16)
{
send_reliable(p,"maps update error: declaration of door has too few arguments. Syntax is door:min_x:max_x:min_y:max_y:min_z:max_z:finish_x:finish_y:finish_z:text:speed:loop:moveloop:opensound:closesound, got "+maptext,0);
return;
}
else if(ld[0]=="pdoor" and ld.length<17)
{
send_reliable(p,"maps update error: declaration of password protected door has too few arguments. Syntax is door:min_x:max_x:min_y:max_y:min_z:max_z:finish_x:finish_y:finish_z:text_when_player_wants_to_enter_the_password:password:speed:loop:moveloop:opensound:closesound, got "+maptext,0);
return;
}
else if(ld[0]=="icdoor" and ld.length<18)
{
send_reliable(p,"maps update error: declaration of item checker door has too few arguments. Syntax is door:min_x:max_x:min_y:max_y:min_z:max_z:finish_x:finish_y:finish_z:text_when_player_wants_to_enter_the_password:item:amount:speed:loop:moveloop:opensound:closesound, got "+maptext,0);
return;
}
else if(ld[0]=="itdoor" and ld.length<18)
{
send_reliable(p,"maps update error: declaration of item taker door has too few arguments. Syntax is door:min_x:max_x:min_y:max_y:min_z:max_z:finish_x:finish_y:finish_z:text_when_player_wants_to_enter_the_password:item:amount:speed:loop:moveloop:opensound:closesound, got "+maptext,0);
return;
}
else if(ld[0]=="igdoor" and ld.length<18)
{
send_reliable(p,"maps update error: declaration of item giver door has too few arguments. Syntax is door:min_x:max_x:min_y:max_y:min_z:max_z:finish_x:finish_y:finish_z:text_when_player_wants_to_enter_the_password:item:amount:speed:loop:moveloop:opensound:closesound, got "+maptext,0);
return;
}
else if(ld[0]=="igdoor" and p.is_admin()==false)
{
return;
}
else if(ld[0]=="automover" and ld.length<16)
{
send_reliable(p,"maps update error: declaration of automover has too few arguments. Syntax is automover:min_x:max_x:min_y:max_y:min_z:max_z:finish_x:finish_y:finish_z:text:speed:loop:moveloop:opensound:closesound, got "+maptext,0);
return;
}
else if(ld[0]=="pautomover" and ld.length<17)
{
send_reliable(p,"maps update error: declaration of password protected automover has too few arguments. Syntax is automover:min_x:max_x:min_y:max_y:min_z:max_z:finish_x:finish_y:finish_z:text_when_player_wants_to_enter_the_password:password:speed:loop:moveloop:opensound:closesound, got "+maptext,0);
return;
}
else if(ld[0]=="icautomover" and ld.length<18)
{
send_reliable(p,"maps update error: declaration of item checker automover has too few arguments. Syntax is automover:min_x:max_x:min_y:max_y:min_z:max_z:finish_x:finish_y:finish_z:text_when_player_wants_to_enter_the_password:item:amount:speed:loop:moveloop:opensound:closesound, got "+maptext,0);
return;
}
else if(ld[0]=="itautomover" and ld.length<18)
{
send_reliable(p,"maps update error: declaration of item taker automover has too few arguments. Syntax is automover:min_x:max_x:min_y:max_y:min_z:max_z:finish_x:finish_y:finish_z:text_when_player_wants_to_enter_the_password:item:amount:speed:loop:moveloop:opensound:closesound, got "+maptext,0);
return;
}
else if(ld[0]=="igautomover" and ld.length<18)
{
send_reliable(p,"maps update error: declaration of item giver automover has too few arguments. Syntax is automover:min_x:max_x:min_y:max_y:min_z:max_z:finish_x:finish_y:finish_z:text_when_player_wants_to_enter_the_password:item:amount:speed:loop:moveloop:opensound:closesound, got "+maptext,0);
return;
}
else if(ld[0]=="igautomover" and p.is_admin()==false)
{
return;
}
else if(ld[0]=="automatic_travelpoint" and ld.length<15)
{
send_reliable(p,"maps update error: declaration of automatic_travelpoint has too few arguments. Syntax is automatic_travelpoint:min_x:max_x:min_y:max_y:min_z:max_z:map:finish_x:finish_y:finish_z:text:loop:opensound:closesound, got "+maptext,0);
return;
}
else if(ld[0]=="pautomatic_travelpoint" and ld.length<16)
{
send_reliable(p,"maps update error: declaration of password protected automatic_travelpoint has too few arguments. Syntax is automatic_travelpoint:min_x:max_x:min_y:max_y:min_z:max_z:map:finish_x:finish_y:finish_z:text_when_player_wants_to_enter_the_password:password:loop:opensound:closesound, got "+maptext,0);
return;
}
else if(ld[0]=="icautomatic_travelpoint" and ld.length<17)
{
send_reliable(p,"maps update error: declaration of item checker automatic_travelpoint has too few arguments. Syntax is automatic_travelpoint:min_x:max_x:min_y:max_y:min_z:max_z:map:finish_x:finish_y:finish_z:text_when_player_wants_to_enter_the_password:item:amount:loop:opensound:closesound, got "+maptext,0);
return;
}
else if(ld[0]=="itautomatic_travelpoint" and ld.length<17)
{
send_reliable(p,"maps update error: declaration of item taker automatic_travelpoint has too few arguments. Syntax is automatic_travelpoint:min_x:max_x:min_y:max_y:min_z:max_z:map:finish_x:finish_y:finish_z:text_when_player_wants_to_enter_the_password:item:amount:loop:opensound:closesound, got "+maptext,0);
return;
}
else if(ld[0]=="igautomatic_travelpoint" and ld.length<17)
{
send_reliable(p,"maps update error: declaration of item giver automatic_travelpoint has too few arguments. Syntax is automatic_travelpoint:min_x:max_x:min_y:max_y:min_z:max_z:map:finish_x:finish_y:finish_z:text_when_player_wants_to_enter_the_password:item:amount:loop:opensound:closesound, got "+maptext,0);
return;
}
else if(ld[0]=="igautomatic_travelpoint" and p.is_admin()==false)
{
return;
}
else if(ld[0]=="travelpoint" and ld.length<15)
{
send_reliable(p,"maps update error: declaration of travelpoint has too few arguments. Syntax is travelpoint:min_x:max_x:min_y:max_y:min_z:max_z:map:finish_x:finish_y:finish_z:text:loop:opensound:closesound, got "+maptext,0);
return;
}
else if(ld[0]=="ptravelpoint" and ld.length<16)
{
send_reliable(p,"maps update error: declaration of password protected travelpoint has too few arguments. Syntax is travelpoint:min_x:max_x:min_y:max_y:min_z:max_z:map:finish_x:finish_y:finish_z:text_when_player_wants_to_enter_the_password:password:loop:opensound:closesound, got "+maptext,0);
return;
}
else if(ld[0]=="ictravelpoint" and ld.length<17)
{
send_reliable(p,"maps update error: declaration of item checker travelpoint has too few arguments. Syntax is travelpoint:min_x:max_x:min_y:max_y:min_z:max_z:map:finish_x:finish_y:finish_z:text_when_player_wants_to_enter_the_password:item:amount:loop:opensound:closesound, got "+maptext,0);
return;
}
else if(ld[0]=="ittravelpoint" and ld.length<17)
{
send_reliable(p,"maps update error: declaration of item taker travelpoint has too few arguments. Syntax is travelpoint:min_x:max_x:min_y:max_y:min_z:max_z:map:finish_x:finish_y:finish_z:text_when_player_wants_to_enter_the_password:item:amount:loop:opensound:closesound, got "+maptext,0);
return;
}
else if(ld[0]=="igtravelpoint" and ld.length<17)
{
send_reliable(p,"maps update error: declaration of item giver travelpoint has too few arguments. Syntax is travelpoint:min_x:max_x:min_y:max_y:min_z:max_z:map:finish_x:finish_y:finish_z:text_when_player_wants_to_enter_the_password:item:amount:loop:opensound:closesound, got "+maptext,0);
return;
}
else if(ld[0]=="igtravelpoint" and p.is_admin()==false)
{
return;
}
else if(ld[0]=="src" and ld.length<10)
{
send_reliable(p,"maps update error: declaration of source has too few arguments. Syntax is src:minx:maxx:miny:maxy:minz:maxz:volume:pitch:loop.ogg[:id], got "+maptext,0);
return;
}
else if(ld[0]=="music" and ld.length<10)
{
send_reliable(p,"maps update error: declaration of music has too few arguments. Syntax is music:minx:maxx:miny:maxy:minz:maxz:volume:pitch:loop.ogg[:id], got "+maptext,0);
return;
}
else if(ld[0]=="timedsound" and ld.length<10)
{
send_reliable(p,"maps update error: declaration of timed sound has too few arguments. Syntax is timedsound:minx:maxx:miny:maxy:minz:maxz:time:volume:pitch:soundname, got "+maptext,0);
return;
}
else if(ld[0]=="timedmusic" and ld.length<10)
{
send_reliable(p,"maps update error: declaration of timed music has too few arguments. Syntax is timedmusic:minx:maxx:miny:maxy:minz:maxz:time:volume:pitch:musicname, got "+maptext,0);
return;
}
f.open("maps/"+p.map+".map","rb");
string mdata=f.read();
f.close();
string[] mapdata=string_split(mdata, "\r\n",false);
int something=mapdata.find(p.editline);
if(something>-1)
{
mapdata.remove_at(something);
mapdata.insert_at(something,maptext);
file_put_contents("maps/"+p.map+".map", linear(mapdata),250);
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
}
else if(parsed[0]=="addremoveline" and parsed.length()>1)
{
string maptext=string_replace(get_event_message(),"addremoveline ","",false);
if(string_contains(maptext,"owner",1)>-1)
{
string[] ar=string_split(maptext,":",false);
int index2=get_player_index_from(ar[1]);
if(index2 > -1)
{
if(players[index2].map!=p.map)
{
f.open("maps/"+p.map+".map","rb");
string mdata=f.read();
f.close();
string[] mapdata=string_split(mdata, "\r\n",false);
int something=mapdata.find(p.removeline);
if(something>-1)
{
mapdata.remove_at(something);
file_put_contents("maps/"+p.map+".map", linear(mapdata),250);
send_reliable(p,"Map updated",0);
mapupdate(p.map);
f.open("chars/"+players[index2].name+"/maps.usr","rb");
mdata=f.read();
f.close();
mapdata=string_split(mdata, "\r\n",false);
something=mapdata.find(p.removeowner);
if(something>-1)
{
mapdata.remove_at(something);
file_put_contents("chars/"+players[index2].name+"/maps.usr", linear(mapdata),250);
}
}
}
}
string maptxt=string_replace(get_event_message(),"addremoveline owner:","",false);
f.open("chars/"+maptxt+"/maps.usr","rb");
string mdata=f.read();
f.close();
string[] mapdata=string_split(mdata, "\r\n",false);
int something=mapdata.find(p.removeline);
if(something>-1)
{
mapdata.remove_at(something);
file_put_contents("chars/"+maptxt+"/maps.usr", linear(mapdata),250);
}
}
else
{
f.open("maps/"+p.map+".map","rb");
string mdata=f.read();
f.close();
string[] mapdata=string_split(mdata, "\r\n",false);
int something=mapdata.find(p.removeline);
if(something>-1)
{
mapdata.remove_at(something);
file_put_contents("maps/"+p.map+".map", linear(mapdata),250);
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
}
}
else if(parsed[0]=="addremoveowner" and parsed.length()>1)
{
string maptext=string_replace(get_event_message(),"addremoveowner ","",false);
f.open("maps/"+p.map+".map","rb");
string mdata=f.read();
f.close();
string[] mapdata=string_split(mdata, "\r\n",false);
int something=mapdata.find(p.removeowner);
if(something>-1)
{
mapdata.remove_at(something);
file_put_contents("maps/"+p.map+".map", linear(mapdata),250);
send_reliable(p,"Map updated",0);
mapupdate(p.map);
string maptxt=string_replace(get_event_message(),"addremoveowner owner:","",false);
f.open("chars/"+maptxt+"/maps.usr","rb");
mdata=f.read();
f.close();
mapdata=string_split(mdata, "\r\n",false);
something=mapdata.find(p.removeowner);
if(something>-1)
{
mapdata.remove_at(something);
file_put_contents("chars/"+maptxt+"/maps.usr", linear(mapdata),250);
}
}
}
else if(parsed[0]=="addlitem")
{
string maptext=string_replace(get_event_message(),"addlitem ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="addsafe_card")
{
string maptext=string_replace(get_event_message(),"addsafe_card ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="adddescription")
{
string maptext=string_replace(get_event_message(),"adddescription ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="addpvp")
{
string maptext=string_replace(get_event_message(),"addpvp ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="addtoilet")
{
string maptext=string_replace(get_event_message(),"addtoilet ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="addtrashcan")
{
string maptext=string_replace(get_event_message(),"addtrashcan ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="addstarting_point")
{
string maptext=string_replace(get_event_message(),"addstarting_point ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="adddeathpoint")
{
string maptext=string_replace(get_event_message(),"adddeathpoint ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="addwashbasin")
{
string maptext=string_replace(get_event_message(),"addwashbasin ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="addfiremap")
{
string maptext=string_replace(get_event_message(),"addfiremap ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="addchallenge_status")
{
string maptext=string_replace(get_event_message(),"addchallenge_status ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="addshower")
{
string maptext=string_replace(get_event_message(),"addshower ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="addtxt")
{
string maptext=string_replace(get_event_message(),"addtxt ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="adddialog")
{
string maptext=string_replace(get_event_message(),"adddialog ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="addautomatic_dialog")
{
string maptext=string_replace(get_event_message(),"addautomatic_dialog ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="addtimedtext")
{
string maptext=string_replace(get_event_message(),"addtimedtext ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="addtimedsound")
{
string maptext=string_replace(get_event_message(),"addtimedsound ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="addtimedmusic")
{
string maptext=string_replace(get_event_message(),"addtimedmusic ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="additem" and p.is_admin())
{
string maptext=string_replace(get_event_message(),"additem ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="additem_usage_restriction")
{
string maptext=string_replace(get_event_message(),"additem_usage_restriction ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="addAI" and p.is_admin())
{
string maptext=string_replace(get_event_message(),"addAI ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="addsign")
{
string maptext=string_replace(get_event_message(),"addsign ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="addurl")
{
string maptext=string_replace(get_event_message(),"addurl ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="addvanishing_platform")
{
string maptext=string_replace(get_event_message(),"addvanishing_platform ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="addforcefield")
{
string maptext=string_replace(get_event_message(),"addforcefield ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="addhazard")
{
string maptext=string_replace(get_event_message(),"addhazard ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="addteleporter")
{
string maptext=string_replace(get_event_message(),"addteleporter ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="addspecified_air_temperature")
{
string maptext=string_replace(get_event_message(),"addspecified_air_temperature ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="adddoor")
{
string maptext=string_replace(get_event_message(),"adddoor ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="addpdoor")
{
string maptext=string_replace(get_event_message(),"addpdoor ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="addicdoor")
{
string maptext=string_replace(get_event_message(),"addicdoor ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="additdoor")
{
string maptext=string_replace(get_event_message(),"additdoor ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="addigdoor")
{
string maptext=string_replace(get_event_message(),"addigdoor ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="addautomover")
{
string maptext=string_replace(get_event_message(),"addautomover ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="addpautomover")
{
string maptext=string_replace(get_event_message(),"addpautomover ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="addicautomover")
{
string maptext=string_replace(get_event_message(),"addicautomover ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="additautomover")
{
string maptext=string_replace(get_event_message(),"additautomover ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="addigautomover")
{
string maptext=string_replace(get_event_message(),"addigautomover ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="addautomatic_travelpoint")
{
string maptext=string_replace(get_event_message(),"addautomatic_travelpoint ","",false);
if(p.is_admin()==false)
{
string[] a=string_split(file_get_contents("chars/"+p.name+"/maps.usr"),"\r\n",false);
for(uint i=0;i<a.length();i++)
{
if(string_contains(maptext,a[i],1)>-1)
{
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
}
}
else
{
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
}
else if(parsed[0]=="addpautomatic_travelpoint")
{
string maptext=string_replace(get_event_message(),"addpautomatic_travelpoint ","",false);
if(p.is_admin()==false)
{
string[] a=string_split(file_get_contents("chars/"+p.name+"/maps.usr"),"\r\n",false);
for(uint i=0;i<a.length();i++)
{
if(string_contains(maptext,a[i],1)>-1)
{
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
}
}
else
{
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
}
else if(parsed[0]=="addicautomatic_travelpoint")
{
string maptext=string_replace(get_event_message(),"addicautomatic_travelpoint ","",false);
if(p.is_admin()==false)
{
string[] a=string_split(file_get_contents("chars/"+p.name+"/maps.usr"),"\r\n",false);
for(uint i=0;i<a.length();i++)
{
if(string_contains(maptext,a[i],1)>-1)
{
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
}
}
else
{
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
}
else if(parsed[0]=="additautomatic_travelpoint")
{
string maptext=string_replace(get_event_message(),"additautomatic_travelpoint ","",false);
if(p.is_admin()==false)
{
string[] a=string_split(file_get_contents("chars/"+p.name+"/maps.usr"),"\r\n",false);
for(uint i=0;i<a.length();i++)
{
if(string_contains(maptext,a[i],1)>-1)
{
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
}
}
else
{
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
}
else if(parsed[0]=="addigautomatic_travelpoint")
{
string maptext=string_replace(get_event_message(),"addigautomatic_travelpoint ","",false);
if(p.is_admin()==false)
{
string[] a=string_split(file_get_contents("chars/"+p.name+"/maps.usr"),"\r\n",false);
for(uint i=0;i<a.length();i++)
{
if(string_contains(maptext,a[i],1)>-1)
{
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
}
}
else
{
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
}
else if(parsed[0]=="addtravelpoint")
{
string maptext=string_replace(get_event_message(),"addtravelpoint ","",false);
if(p.is_admin()==false)
{
string[] a=string_split(file_get_contents("chars/"+p.name+"/maps.usr"),"\r\n",false);
for(uint i=0;i<a.length();i++)
{
if(string_contains(maptext,a[i],1)>-1)
{
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
}
}
else
{
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
}
else if(parsed[0]=="addptravelpoint")
{
string maptext=string_replace(get_event_message(),"addptravelpoint ","",false);
if(p.is_admin()==false)
{
string[] a=string_split(file_get_contents("chars/"+p.name+"/maps.usr"),"\r\n",false);
for(uint i=0;i<a.length();i++)
{
if(string_contains(maptext,a[i],1)>-1)
{
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
}
}
else
{
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
}
else if(parsed[0]=="addictravelpoint")
{
string maptext=string_replace(get_event_message(),"addictravelpoint ","",false);
if(p.is_admin()==false)
{
string[] a=string_split(file_get_contents("chars/"+p.name+"/maps.usr"),"\r\n",false);
for(uint i=0;i<a.length();i++)
{
if(string_contains(maptext,a[i],1)>-1)
{
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
}
}
else
{
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
}
else if(parsed[0]=="addittravelpoint")
{
string maptext=string_replace(get_event_message(),"addittravelpoint ","",false);
if(p.is_admin()==false)
{
string[] a=string_split(file_get_contents("chars/"+p.name+"/maps.usr"),"\r\n",false);
for(uint i=0;i<a.length();i++)
{
if(string_contains(maptext,a[i],1)>-1)
{
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
}
}
else
{
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
}
else if(parsed[0]=="addigtravelpoint")
{
string maptext=string_replace(get_event_message(),"addigtravelpoint ","",false);
if(p.is_admin()==false)
{
string[] a=string_split(file_get_contents("chars/"+p.name+"/maps.usr"),"\r\n",false);
for(uint i=0;i<a.length();i++)
{
if(string_contains(maptext,a[i],1)>-1)
{
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
}
}
else
{
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
}
else if(parsed[0]=="adddcoordinates")
{
string maptext=string_replace(get_event_message(),"adddcoordinates ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="adddcamera")
{
string maptext=string_replace(get_event_message(),"adddcamera ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="adddcamerawall")
{
string maptext=string_replace(get_event_message(),"adddcamerawall ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="adddmfwc")
{
string maptext=string_replace(get_event_message(),"adddmfwc ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="addecameraplayer")
{
string maptext=string_replace(get_event_message(),"addecameraplayer ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="adddcameraplayer")
{
string maptext=string_replace(get_event_message(),"adddcameraplayer ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="addecameraitem")
{
string maptext=string_replace(get_event_message(),"addecameraitem ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="adddcameraitem")
{
string maptext=string_replace(get_event_message(),"adddcameraitem ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="addecameradoor")
{
string maptext=string_replace(get_event_message(),"addecameradoor ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="adddcameradoor")
{
string maptext=string_replace(get_event_message(),"adddcameradoor ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="addecamerapdoor")
{
string maptext=string_replace(get_event_message(),"addecamerapdoor ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="adddcamerapdoor")
{
string maptext=string_replace(get_event_message(),"adddcamerapdoor ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="addecameraicdoor")
{
string maptext=string_replace(get_event_message(),"addecameraicdoor ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="adddcameraicdoor")
{
string maptext=string_replace(get_event_message(),"adddcameraicdoor ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="addecameraitdoor")
{
string maptext=string_replace(get_event_message(),"addecameraitdoor ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="adddcameraitdoor")
{
string maptext=string_replace(get_event_message(),"adddcameraitdoor ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="addecameraigdoor")
{
string maptext=string_replace(get_event_message(),"addecameraigdoor ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="adddcameraigdoor")
{
string maptext=string_replace(get_event_message(),"adddcameraigdoor ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="addecameraautomover")
{
string maptext=string_replace(get_event_message(),"addecameraautomover ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="adddcameraautomover")
{
string maptext=string_replace(get_event_message(),"adddcameraautomover ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="addecamerapautomover")
{
string maptext=string_replace(get_event_message(),"addecamerapautomover ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="adddcamerapautomover")
{
string maptext=string_replace(get_event_message(),"adddcamerapautomover ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="addecameraicautomover")
{
string maptext=string_replace(get_event_message(),"addecameraicautomover ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="adddcameraicautomover")
{
string maptext=string_replace(get_event_message(),"adddcameraicautomover ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="addecameraitautomover")
{
string maptext=string_replace(get_event_message(),"addecameraitautomover ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="adddcameraitautomover")
{
string maptext=string_replace(get_event_message(),"adddcameraitautomover ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="addecameraigautomover")
{
string maptext=string_replace(get_event_message(),"addecameraigautomover ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="adddcameraigautomover")
{
string maptext=string_replace(get_event_message(),"adddcameraigautomover ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="addecameraautomatic_travelpoint")
{
string maptext=string_replace(get_event_message(),"addecameraautomatic_travelpoint ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="adddcameraautomatic_travelpoint")
{
string maptext=string_replace(get_event_message(),"adddcameraautomatic_travelpoint ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="addecamerapautomatic_travelpoint")
{
string maptext=string_replace(get_event_message(),"addecamerapautomatic_travelpoint ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="adddcamerapautomatic_travelpoint")
{
string maptext=string_replace(get_event_message(),"adddcamerapautomatic_travelpoint ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="addecameraicautomatic_travelpoint")
{
string maptext=string_replace(get_event_message(),"addecameraicautomatic_travelpoint ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="adddcameraicautomatic_travelpoint")
{
string maptext=string_replace(get_event_message(),"adddcameraicautomatic_travelpoint ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="addecameraitautomatic_travelpoint")
{
string maptext=string_replace(get_event_message(),"addecameraitautomatic_travelpoint ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="adddcameraitautomatic_travelpoint")
{
string maptext=string_replace(get_event_message(),"adddcameraitautomatic_travelpoint ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="addecameraigautomatic_travelpoint")
{
string maptext=string_replace(get_event_message(),"addecameraigautomatic_travelpoint ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="adddcameraigautomatic_travelpoint")
{
string maptext=string_replace(get_event_message(),"adddcameraigautomatic_travelpoint ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="addecameratravelpoint")
{
string maptext=string_replace(get_event_message(),"addecameratravelpoint ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="adddcameratravelpoint")
{
string maptext=string_replace(get_event_message(),"adddcameratravelpoint ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="addecameraptravelpoint")
{
string maptext=string_replace(get_event_message(),"addecameraptravelpoint ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="adddcameraptravelpoint")
{
string maptext=string_replace(get_event_message(),"adddcameraptravelpoint ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="addecameraictravelpoint")
{
string maptext=string_replace(get_event_message(),"addecameraictravelpoint ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="adddcameraictravelpoint")
{
string maptext=string_replace(get_event_message(),"adddcameraictravelpoint ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="addecameraittravelpoint")
{
string maptext=string_replace(get_event_message(),"addecameraittravelpoint ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="adddcameraittravelpoint")
{
string maptext=string_replace(get_event_message(),"adddcameraittravelpoint ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="addecameraigtravelpoint")
{
string maptext=string_replace(get_event_message(),"addecameraigtravelpoint ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="adddcameraigtravelpoint")
{
string maptext=string_replace(get_event_message(),"adddcameraigtravelpoint ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="addecameravp")
{
string maptext=string_replace(get_event_message(),"addecameravp ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="adddcameravp")
{
string maptext=string_replace(get_event_message(),"adddcameravp ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="addecamerasign")
{
string maptext=string_replace(get_event_message(),"addecamerasign ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="adddcamerasign")
{
string maptext=string_replace(get_event_message(),"adddcamerasign ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="addecameratxt")
{
string maptext=string_replace(get_event_message(),"addecameratxt ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="adddcameratxt")
{
string maptext=string_replace(get_event_message(),"adddcameratxt ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="addd2dsupport")
{
string maptext=string_replace(get_event_message(),"addd2dsupport ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="adddjump")
{
string maptext=string_replace(get_event_message(),"adddjump ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="adddspy")
{
string maptext=string_replace(get_event_message(),"adddspy ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="addecoordinates")
{
string maptext=string_replace(get_event_message(),"addecoordinates ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="addecamera")
{
string maptext=string_replace(get_event_message(),"addecamera ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="addecamerawall")
{
string maptext=string_replace(get_event_message(),"addecamerawall ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="addemfwc")
{
string maptext=string_replace(get_event_message(),"addemfwc ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="addejump")
{
string maptext=string_replace(get_event_message(),"addejump ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="addespy")
{
string maptext=string_replace(get_event_message(),"addespy ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="adde2dsupport")
{
string maptext=string_replace(get_event_message(),"adde2dsupport ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="adddlocalchat")
{
string maptext=string_replace(get_event_message(),"adddlocalchat ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="addelocalchat")
{
string maptext=string_replace(get_event_message(),"addelocalchat ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="adddvoicechat")
{
string maptext=string_replace(get_event_message(),"adddvoicechat ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="addevoicechat")
{
string maptext=string_replace(get_event_message(),"addevoicechat ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="adddttschat")
{
string maptext=string_replace(get_event_message(),"adddttschat ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="addettschat")
{
string maptext=string_replace(get_event_message(),"addettschat ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="adddtracking")
{
string maptext=string_replace(get_event_message(),"adddtracking ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="addetracking")
{
string maptext=string_replace(get_event_message(),"addetracking ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="addddisasters")
{
f.open("maps/"+p.map+".map","rb");
string mdata=f.read();
f.close();
string[] mapdata=string_split(mdata, "\r\n",false);
int something=mapdata.find("enable:disasters");
if(something>-1)
{
mapdata.remove_at(something);
file_put_contents("maps/"+p.map+".map", linear(mapdata),250);
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
}
else if(parsed[0]=="addedisasters")
{
string maptext=string_replace(get_event_message(),"addedisasters ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="adddrain")
{
string maptext=string_replace(get_event_message(),"adddrain ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="adddwind")
{
string maptext=string_replace(get_event_message(),"adddwind ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="adddnight")
{
string maptext=string_replace(get_event_message(),"adddnight ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="addespyplayer")
{
string maptext=string_replace(get_event_message(),"addespyplayer ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="adddspyplayer")
{
string maptext=string_replace(get_event_message(),"adddspyplayer ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="addespyitem")
{
string maptext=string_replace(get_event_message(),"addespyitem ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="adddspyitem")
{
string maptext=string_replace(get_event_message(),"adddspyitem ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="addespydoor")
{
string maptext=string_replace(get_event_message(),"addespydoor ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="adddspydoor")
{
string maptext=string_replace(get_event_message(),"adddspydoor ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="addespypdoor")
{
string maptext=string_replace(get_event_message(),"addespypdoor ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="adddspypdoor")
{
string maptext=string_replace(get_event_message(),"adddspypdoor ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="addespyicdoor")
{
string maptext=string_replace(get_event_message(),"addespyicdoor ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="adddspyicdoor")
{
string maptext=string_replace(get_event_message(),"adddspyicdoor ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="addespyitdoor")
{
string maptext=string_replace(get_event_message(),"addespyitdoor ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="adddspyitdoor")
{
string maptext=string_replace(get_event_message(),"adddspyitdoor ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="addespyigdoor")
{
string maptext=string_replace(get_event_message(),"addespyigdoor ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="adddspyigdoor")
{
string maptext=string_replace(get_event_message(),"adddspyigdoor ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="addespyautomover")
{
string maptext=string_replace(get_event_message(),"addespyautomover ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="adddspyautomover")
{
string maptext=string_replace(get_event_message(),"adddspyautomover ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="addespypautomover")
{
string maptext=string_replace(get_event_message(),"addespypautomover ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="adddspypautomover")
{
string maptext=string_replace(get_event_message(),"adddspypautomover ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="addespyicautomover")
{
string maptext=string_replace(get_event_message(),"addespyicautomover ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="adddspyicautomover")
{
string maptext=string_replace(get_event_message(),"adddspyicautomover ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="addespyitautomover")
{
string maptext=string_replace(get_event_message(),"addespyitautomover ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="adddspyitautomover")
{
string maptext=string_replace(get_event_message(),"adddspyitautomover ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="addespyigautomover")
{
string maptext=string_replace(get_event_message(),"addespyigautomover ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="adddspyigautomover")
{
string maptext=string_replace(get_event_message(),"adddspyigautomover ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="addespyautomatic_travelpoint")
{
string maptext=string_replace(get_event_message(),"addespyautomatic_travelpoint ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="adddspyautomatic_travelpoint")
{
string maptext=string_replace(get_event_message(),"adddspyautomatic_travelpoint ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="addespypautomatic_travelpoint")
{
string maptext=string_replace(get_event_message(),"addespypautomatic_travelpoint ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="adddspypautomatic_travelpoint")
{
string maptext=string_replace(get_event_message(),"adddspypautomatic_travelpoint ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="addespyicautomatic_travelpoint")
{
string maptext=string_replace(get_event_message(),"addespyicautomatic_travelpoint ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="adddspyicautomatic_travelpoint")
{
string maptext=string_replace(get_event_message(),"adddspyicautomatic_travelpoint ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="addespyitautomatic_travelpoint")
{
string maptext=string_replace(get_event_message(),"addespyitautomatic_travelpoint ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="adddspyitautomatic_travelpoint")
{
string maptext=string_replace(get_event_message(),"adddspyitautomatic_travelpoint ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="addespyigautomatic_travelpoint")
{
string maptext=string_replace(get_event_message(),"addespyigautomatic_travelpoint ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="adddspyigautomatic_travelpoint")
{
string maptext=string_replace(get_event_message(),"adddspyigautomatic_travelpoint ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="addespytravelpoint")
{
string maptext=string_replace(get_event_message(),"addespytravelpoint ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="adddspytravelpoint")
{
string maptext=string_replace(get_event_message(),"adddspytravelpoint ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="addespyptravelpoint")
{
string maptext=string_replace(get_event_message(),"addespyptravelpoint ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="adddspyptravelpoint")
{
string maptext=string_replace(get_event_message(),"adddspyptravelpoint ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="addespyictravelpoint")
{
string maptext=string_replace(get_event_message(),"addespyictravelpoint ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="adddspyictravelpoint")
{
string maptext=string_replace(get_event_message(),"adddspyictravelpoint ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="addespyittravelpoint")
{
string maptext=string_replace(get_event_message(),"addespyittravelpoint ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="adddspyittravelpoint")
{
string maptext=string_replace(get_event_message(),"adddspyittravelpoint ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="addespyigtravelpoint")
{
string maptext=string_replace(get_event_message(),"addespyigtravelpoint ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="adddspyigtravelpoint")
{
string maptext=string_replace(get_event_message(),"adddspyigtravelpoint ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="addespyvp")
{
string maptext=string_replace(get_event_message(),"addespyvp ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="adddspyvp")
{
string maptext=string_replace(get_event_message(),"adddspyvp ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="addespysign")
{
string maptext=string_replace(get_event_message(),"addespysign ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="adddspysign")
{
string maptext=string_replace(get_event_message(),"adddspysign ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="addespytxt")
{
string maptext=string_replace(get_event_message(),"addespytxt ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="adddspytxt")
{
string maptext=string_replace(get_event_message(),"adddspytxt ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="addfishingcoordinate")
{
string maptext=string_replace(get_event_message(),"addfishingcoordinate ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="addzone")
{
string maptext=string_replace(get_event_message(),"addzone ","",false);
if(p.is_admin()==false)
{
if(string_contains(maptext,"_store",1)>-1 or string_contains(maptext,"bank_service_desk",1)>-1 or string_contains(maptext,"cash_machine",1)>-1 or string_contains(maptext,"cash_miner",1)>-1 or string_contains(maptext,"civil registry office",1)>-1 or string_contains(maptext,"entertainment_center",1)>-1 or string_contains(maptext,"employment_agency",1)>-1 or string_contains(maptext,"cemetery",1)>-1)
{
send_reliable(p,"this zone text is not allowed",2);
return;
}
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else
{
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
}
else if(parsed[0]=="addsafezone")
{
string maptext=string_replace(get_event_message(),"addsafezone ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="addbed")
{
string maptext=string_replace(get_event_message(),"addbed ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="addclock")
{
string maptext=string_replace(get_event_message(),"addclock ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="addcalendar")
{
string maptext=string_replace(get_event_message(),"addcalendar ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="addoven")
{
string maptext=string_replace(get_event_message(),"addoven ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="addtile")
{
string maptext=string_replace(get_event_message(),"addtile ","",false);
f.open("maps/"+p.map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+p.map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(p,"Map updated",0);
mapupdate(p.map);
}
else if(parsed[0]=="coinadd")
{
int vending=get_vending_index(p.x,p.y,p.z,p.map);
if(vending>-1)
{
send_serverbox(p.peer_id, 2, -1, 1, -1, "insertamount", "how many coins do you want to insert into this vending machine?");
}
}
else if(parsed[0]=="usepack" and parsed.length()>1)
{
string draw;
string s=string_trim_left(draw,8);
string[] pp=string_split(s,"_",false);
p.inv_add_item(string_replace(s,pp[0]+"_","",false),string_to_number(pp[0]));
send_packet(6,"play openpack.ogg "+p.x+" "+p.y+" "+p.z, p.x,p.y,p.z,maps[get_map_index(p.map)]);
p.inv_add_item("empty_pack",1);
}
else if(parsed[0]=="insertamount" and parsed.length()>1)
{
if(parsed[1]=="[cncel]")
{
send_reliable(p, "canceled", 0);
return;
}
int v=get_vending_index(p.x,p.y,p.z,p.map);
double amount=string_to_number(parsed[1]);
if(amount>0)
{
if(p.inv_item_number("coins")<=amount)
{
send_reliable(p, "not enough money", 0);
return;
}
if(v>-1)
{
vending_machines[v].vplay("insert");
vending_machines[v].coins+=amount;
p.inv_add_item("coins", -amount);
}
}
}
else if(parsed[0]=="insertdonations" and parsed.length()>1)
{
if(parsed[1]=="[cncel]")
{
send_reliable(p,"canceled",0);
return;
}
double amount=string_to_number(parsed[1]);
if(amount>0)
{
if(p.inv_item_number("coins")<=amount)
{
send_reliable(p, "not enough money", 0);
return;
}
p.inv_add_item("coins", -amount);
servermoney+=amount;
send_reliable(p,"donations thanks for donating "+amount+" coins in to the donation chest",0);
send_reliable(0,"donations "+p.name+" donated "+amount+" coins to the donation chest!",0);
}
}
else if(parsed[0]=="command" and parsed.length>1)
{
int vi=in_vehicle(p);
if(vi>-1 ) 
{
if(parsed[1]=="firegun")
{
int mapindex=get_map_index(p.map);
if(mapindex>-1)
{
if(maps[mapindex].szminx<=p.x and maps[mapindex].szmaxx>=p.x and maps[mapindex].szminy<=p.y and maps[mapindex].szmaxy>=p.y and maps[mapindex].szminz<=p.z and maps[mapindex].szmaxz>=p.z)
{
send_reliable(p,"You can't fire in safe places",2);
return;
}
}
}
vs[vi].command(parsed[1],false,vi);
}
}
else if(parsed[0]=="mocommand" and parsed.length>1)
{
int vi=in_motor(p);
if(vi>-1 ) 
{
mos[vi].mocommand(parsed[1],false,vi);
}
}
else if(parsed[0]=="enter")
{
for(uint i=0; i<ais.length(); i++)
{
if(p.map==ais[i].map.name and get_3d_distance(p.x, p.y, p.z, ais[i].x, ais[i].y, ais[i].z)<=1)
{
send_reliable(p,(ais[i].description!=""?"+ais[i].description+":" "),2);
}
}
for (uint i=0; i<microwaves.length(); i++)
{
if(p.map==microwaves[i].map and get_3d_distance(p.x, p.y, p.z, microwaves[i].x, microwaves[i].y, microwaves[i].z)<=1)
{
if(microwaves[i].readytotake==0)
{
if(microwaves[i].battery<=0)
{
send_reliable(p,"this microwave is out of battery",2);
}
else
{
if(microwaves[i].on==0 and microwaves[i].foodtype!="")
{
microwaves[i].midsound=spawn_moving_sound("microwave.ogg",microwaves[i].x,microwaves[i].y,microwaves[i].z,microwaves[i].map);
microwaves[i].on=1;
microwaves[i].waitingtimer.force(0);
}
else if(microwaves[i].on==1)
{
destroy_moving_sound(microwaves[i].midsound);
microwaves[i].midsound="";
send_packet(6,"play get"+get_draw_and_get_sound(microwaves[i].foodtype)+".ogg "+p.x+" "+p.y+" "+p.z, p.x,p.y,p.z,maps[get_map_index(p.map)]);
p.inv_add_item(microwaves[i].foodtype,1);
microwaves[i].on=0;
microwaves[i].foodonit=0;
microwaves[i].foodtype="";
microwaves[i].waitingtimer.restart();
}
}
}
else
{
string s;
if(string_left(microwaves[i].foodtype,7)=="gutted_") s=string_trim_left(microwaves[i].foodtype,7);
send_packet(6,"play get"+get_draw_and_get_sound(s)+".ogg "+p.x+" "+p.y+" "+p.z, p.x,p.y,p.z,maps[get_map_index(p.map)]);
p.inv_add_item("cooked_"+s,1);
microwaves[i].readytotake=0;
microwaves[i].foodonit=0;
microwaves[i].foodtype="";
}
}
}
for(uint i=0; i<air_conditioners.length(); i++)
{
if(p.map==air_conditioners[i].map and get_3d_distance(p.x, p.y, p.z, air_conditioners[i].x, air_conditioners[i].y, air_conditioners[i].z)<=1)
{
air_conditioners[i].on=toggle(air_conditioners[i].on);
if(air_conditioners[i].on==1)
{
send_packet(6,"play elevator_start2.ogg "+p.x+" "+p.y+" "+p.z, p.x,p.y,p.z,maps[get_map_index(p.map)]);
air_conditioners[i].mid=spawn_moving_sound("elevator_running.ogg",air_conditioners[i].x,air_conditioners[i].y,air_conditioners[i].z,air_conditioners[i].map);
send_reliable(p,"on",2);
}
else
{
send_packet(6,"play elevator_stop2.ogg "+p.x+" "+p.y+" "+p.z, p.x,p.y,p.z,maps[get_map_index(p.map)]);
destroy_moving_sound(air_conditioners[i].mid);
send_reliable(p,"off",2);
}
}
}
for(uint i=0; i<steams.length(); i++)
{
if(p.map==steams[i].map and get_3d_distance(p.x, p.y, p.z, steams[i].x, steams[i].y, steams[i].z)<=1)
{
steams[i].on=toggle(steams[i].on);
if(steams[i].on==1)
{
send_packet(6,"play slidestart.ogg "+p.x+" "+p.y+" "+p.z, p.x,p.y,p.z,maps[get_map_index(p.map)]);
steams[i].mid=spawn_moving_sound("slide.ogg",steams[i].x,steams[i].y,steams[i].z,steams[i].map);
send_reliable(p,"on",2);
}
else
{
send_packet(6,"play slidestop.ogg "+p.x+" "+p.y+" "+p.z, p.x,p.y,p.z,maps[get_map_index(p.map)]);
destroy_moving_sound(steams[i].mid);
send_reliable(p,"off",2);
}
}
}
for(uint i=0; i<fans.length(); i++)
{
if(p.map==fans[i].map and get_3d_distance(p.x, p.y, p.z, fans[i].x, fans[i].y, fans[i].z)<=1)
{
fans[i].on=toggle(fans[i].on);
if(fans[i].on==1)
{
send_packet(6,"play base_breaker_on.ogg "+p.x+" "+p.y+" "+p.z, p.x,p.y,p.z,maps[get_map_index(p.map)]);
fans[i].mid=spawn_moving_sound("fan6.ogg",fans[i].x,fans[i].y,fans[i].z,fans[i].map);
send_reliable(p,"on",2);
}
else
{
send_packet(6,"play base_breaker_off.ogg "+p.x+" "+p.y+" "+p.z, p.x,p.y,p.z,maps[get_map_index(p.map)]);
destroy_moving_sound(fans[i].mid);
send_reliable(p,"off",2);
}
}
}
for(uint i=0; i<vvehicles.length(); i++)
{
if(in_vehicle(p)>-1 or in_motor(p)>-1) return;
if(vvehicles[i].map==p.map and get_3d_distance(p.x,p.y,p.z,vvehicles[i].x,vvehicles[i].y,vvehicles[i].z)<1)
{
if(can_use_item_at(p.x,p.y,p.z,maps[get_map_index(p.map)],vvehicles[i].type)==false)
{
send_reliable(p,"you can't ride this "+vvehicles[i].type+" here",2);
return;
}
string currenttile=get_tile_at(p.x,p.y,p.z,maps[get_map_index(p.map)]);
if(currenttile=="" or currenttile=="air")
{
send_reliable(p,"Not in the air!",0);
return;
}
int index=get_player_index(e.peer_id);
spawn_vehicle(vvehicles[i].type,index);
file_delete("vehicles/"+vvehicles[i].id+".vehicle");
@vvehicles[i]=null;
vvehicles.remove_at(i);
continue;
}
}
for(uint i=0; i<mmotors.length(); i++)
{
if(in_vehicle(p)>-1 or in_motor(p)>-1) return;
if(mmotors[i].map==p.map and get_3d_distance(p.x,p.y,p.z,mmotors[i].x,mmotors[i].y,mmotors[i].z)<1)
{
if(can_use_item_at(p.x,p.y,p.z,maps[get_map_index(p.map)],mmotors[i].type)==false)
{
send_reliable(p,"you can't ride this "+mmotors[i].type+" here",2);
return;
}
string currenttile=get_tile_at(p.x,p.y,p.z,maps[get_map_index(p.map)]);
if(currenttile=="" or currenttile=="air")
{
send_reliable(p,"Not in the air!",0);
return;
}
int index=get_player_index(e.peer_id);
spawn_motor(mmotors[i].type,index);
file_delete("vehicles/"+mmotors[i].id+".motor");
@mmotors[i]=null;
mmotors.remove_at(i);
continue;
}
}
for(uint i=0; i<houses.length(); i++)
{
if(houses[i].canbell==1 and houses[i].bellsound!="" and houses[i].map==p.map and houses[i].x==p.x and houses[i].y==p.y and houses[i].z==p.z)
{
if(p.waitingtimer.elapsed>=random(550,790))
{
p.waitingtimer.restart();
send_packet(6,"play "+houses[i].bellsound+".ogg "+houses[i].x+" "+houses[i].y+" "+houses[i].z, houses[i].x,houses[i].y,houses[i].z,maps[get_map_index(houses[i].map)]);
int howner=get_player_index_from(houses[i].owner);
if(howner>-1)
{
if(players[howner].smartphoneon==1)
{
send_packet(6,"play "+houses[i].bellsound+".ogg "+players[howner].x+" "+players[howner].y+" "+players[howner].z, players[howner].x,players[howner].y,players[howner].z,maps[get_map_index(players[howner].map)]);
send_reliable(players[howner], "spnotify attention, "+p.name+" is Ringing your house!", 0);
}
}
}
}
}
for(uint i=0; i<robots.length(); i++)
{
if(robots[i].enterable==true and robots[i].id==p.rid and robots[i].map.name==p.map and robots[i].x==p.x and robots[i].y==p.y and robots[i].z==p.z) robotstart(p.rid);
}
for(uint i=0;i<toilets.length();i++)
{
if(toilets[i].map==p.map and toilets[i].minx<=p.x and toilets[i].maxx>=p.x and toilets[i].miny<=p.y and toilets[i].maxy>=p.y and toilets[i].minz<=p.z and toilets[i].maxz>=p.z)
{
if(p.sitting==0 and p.tmaquina.elapsed>=10000)
{
send_packet(6,"play dando_descarga"+random(1, 2)+".ogg "+p.x+" "+p.y+" "+p.z, p.x,p.y,p.z,maps[get_map_index(p.map)]);
p.tmaquina.restart();
toilets[i].descarga=0;
}
else if(p.sitting==1 and p.tmaquina.elapsed>=2500)
{
if(p.nthirst>0)
{
p.nthirst-=random(80,110);
if(p.nthirst<0)p.nthirst=0;
send_packet(6,"play mijando1.ogg "+p.x+" "+p.y+" "+p.z, p.x,p.y,p.z,maps[get_map_index(p.map)]);
p.dirty+=0.5;
}
if(p.nhunger>0)
{
p.nhunger-=random(80,110);
if(p.nhunger<0)p.nhunger=0;
send_packet(6,"play cagando"+random(1,2)+".ogg "+p.x+" "+p.y+" "+p.z, p.x,p.y,p.z,maps[get_map_index(p.map)]);
p.dirty+=0.5;
}
toilets[i].descarga=1;
}
}
}
for(uint i=0;i<washbasins.length();i++)
{
if(washbasins[i].map==p.map and washbasins[i].aberta==false and washbasins[i].minx<=p.x and washbasins[i].maxx>=p.x and washbasins[i].miny<=p.y and washbasins[i].maxy>=p.y and washbasins[i].minz<=p.z and washbasins[i].maxz>=p.z)
{
send_reliable(p, "stopmoving", 0);
send_packet(6,"play lavando_maos.ogg "+p.x+" "+p.y+" "+p.z, p.x,p.y,p.z,maps[get_map_index(p.map)]);
washbasins[i].fechando.restart();
washbasins[i].fechar.restart();
washbasins[i].aberta=true;
}
}
for(uint i=0;i<showers.length();i++)
{
if(showers[i].map==p.map and showers[i].aberta==false and showers[i].minx<=p.x and showers[i].maxx>=p.x and showers[i].miny<=p.y and showers[i].maxy>=p.y and showers[i].minz<=p.z and showers[i].maxz>=p.z)
{
send_reliable(p, "stopmoving", 0);
send_packet(6,"play shower.ogg "+p.x+" "+p.y+" "+p.z, p.x,p.y,p.z,maps[get_map_index(p.map)]);
showers[i].fechando.restart();
showers[i].fechar.restart();
showers[i].aberta=true;
}
}
for(uint i=0; i<objs.length(); i++)
{
if(p.afk==true or p.away==true or p.is_dead==true) continue;
if(p.map==objs[i].map.name and get_3d_distance(objs[i].x,objs[i].y,objs[i].z,p.x,p.y,p.z)<=1)
{
send_packet(6,"play get"+get_draw_and_get_sound(objs[i].name)+".ogg "+objs[i].x+" "+objs[i].y+" "+objs[i].z, objs[i].x,objs[i].y,objs[i].z,maps[get_map_index(objs[i].map.name)]);
objgrabs++;
send_reliable(p, string_replace(objs[i].name,"_"," ",true), 2);
if(string_contains(objs[i].name,"bag_of_",1)>-1 or string_contains(objs[i].name,"skillet_with_",1)>-1)
{
int c=get_corpses_from(string_right(objs[i].name,5));
if(c<0)
{
string cid=randomstring(5);
new_corpse(objs[i].name+";",cid);
p.inv_add_item(objs[i].name+"_"+cid,1);
}
else
{
p.inv_add_item(objs[i].name,1);
}
}
else if(string_contains(objs[i].name,"pack_of_",1)>-1 or string_contains(objs[i].name,"box_of_",1)>-1)
{
int c=get_corpses_from(string_right(objs[i].name,5));
if(c<0)
{
string cid=randomstring(5);
string[] parsed2=string_split(objs[i].name,"_",false);
new_corpse(""+parsed2[3]+"="+parsed2[2]+";",cid);
p.inv_add_item(objs[i].name+"_"+cid,1);
}
else
{
p.inv_add_item(objs[i].name,1);
}
}
else
{
p.inv_add_item(objs[i].name,objs[i].amount);
}
send_reliable(p,"itemtrackstop",0);
remove_obj(i);
continue;
}
}
for(uint i=0; i<silenceobjs.length(); i++)
{
if(p.afk==true or p.away==true or p.is_dead==true) continue;
if(p.map==silenceobjs[i].map.name and get_3d_distance(silenceobjs[i].x,silenceobjs[i].y,silenceobjs[i].z,p.x,p.y,p.z)<=1)
{
send_packet(6,"play get"+get_draw_and_get_sound(silenceobjs[i].name)+".ogg "+silenceobjs[i].x+" "+silenceobjs[i].y+" "+silenceobjs[i].z, silenceobjs[i].x,silenceobjs[i].y,silenceobjs[i].z,maps[get_map_index(silenceobjs[i].map.name)]);
send_reliable(p, string_replace(silenceobjs[i].name,"_"," ",true), 2);
p.inv_add_item(silenceobjs[i].name,silenceobjs[i].amount);
remove_silenceobj(i);
continue;
}
}
int l=get_locker_at(p.x, p.y, p.z,maps[get_map_index(p.map)]);
if(l>-1)
{
send_serverbox(p.peer_id, 2, 4, 1, -1, "lock_auth", "Enter security code");
}
int f=get_fridge_at(p.x, p.y, p.z,maps[get_map_index(p.map)]);
if(f>-1)
{
send_packet(6,"play base_fridge_open.ogg "+p.x+" "+p.y+" "+p.z, p.x,p.y,p.z,maps[get_map_index(p.map)]);
fridges[f].main_ui(p);
}
for(uint i=0; i<mines.length(); i++)
{
if(mines[i].map.name==p.map and get_3d_distance(mines[i].x, mines[i].y, mines[i].z, p.x, p.y, p.z) <=1)
{
send_packet(6,"play mine_death.ogg "+mines[i].x+" "+mines[i].y+" "+mines[i].z, mines[i].x,mines[i].y,mines[i].z,maps[get_map_index(mines[i].map.name)]);
p.inv_add_item("mine",1);
send_reliable(p,"You have successfully disarmed "+mines[i].owner.name+"'s mine!",2);
mines.remove_at(i);
}
}
if(get_zone_at(p.x,p.y,p.z,maps[get_map_index(p.map)])=="marriage_place" and p.map=="marriage_office" and p.partner=="")
{
if(p.langchan=="" or p.age==0 or p.country=="" or p.day==0 or p.month==0 or p.year==0)
{
send_reliable(p,"You didn't complete your profile yet, please go to your smart phone to complete your profile",2);
return;
}
if(p.age<18)
{
send_reliable(p,"You are still not reached the age of eighteen which is the legal age for getting married",2);
return;
}
server_menu m;
m.intro="who would you like to marry with?";
m.initial_packet="marriage";
for(uint i=0; i<players.length(); i++)
{
if(players[i].name==p.name||players[i].is_dead||p.map!=players[i].map||players[i].gender==0&&p.gender==0||players[i].gender==1&&p.gender==1||players[i].x!=p.x||players[i].y!=p.y||players[i].z!=p.z||players[i].partner!=""||players[i].age<18) continue;
m.add(players[i].name,players[i].name);
}
m.send(p.peer_id);
}
if(get_zone_at(p.x,p.y,p.z,maps[get_map_index(p.map)])=="devorce_place" and p.map=="court" and p.partner!="" and p.ex_partner=="")
{
if(p.langchan=="" or p.age==0 or p.country=="" or p.day==0 or p.month==0 or p.year==0)
{
send_reliable(p,"You didn't complete your profile yet, please go to your smart phone to complete your profile",2);
return;
}
server_menu m;
m.intro="who would you like to devorce from?";
m.initial_packet="devorce";
int ind=get_player_index_from(p.partner);
if(ind>-1 and p.map==players[ind].map||players[ind].x==p.x||players[ind].y==p.y||players[ind].z==p.z)
{
m.add(players[ind].name,players[ind].name);
}
m.send(p.peer_id);
}
if(get_zone_at(p.x,p.y,p.z,maps[get_map_index(p.map)])=="employment_agency")
{
server_menu m;
m.intro="select your job";
m.initial_packet="employ";
if(p.job!="")
{
m.add("quit your current job. Costs 20000 coins","quitjob");
}
else
{
if(p.gender==0) m.add("salesman. Costs 15000 coins","salesman");
else m.add("saleswoman. Costs 15000 coins","saleswoman");
}
m.send(p.peer_id);
}
if(get_zone_at(p.x,p.y,p.z,maps[get_map_index(p.map)])=="cash_miner")
{
if(p.contabancaria==1)
{
if(p.waitingtimer.elapsed>=1500)
{
p.waitingtimer.restart();
send_packet(6,"play getstw_point.ogg "+p.x+" "+p.y+" "+p.z, p.x,p.y,p.z,maps[get_map_index(p.map)]);
send_packet(6,"play drawstw_credit.ogg "+p.x+" "+p.y+" "+p.z, p.x,p.y,p.z,maps[get_map_index(p.map)]);
p.balance+=random(3,7);
}
}
else
{
send_reliable(p,"you should have bank account to use the cash miner",2);
}
}
if(get_zone_at(p.x,p.y,p.z,maps[get_map_index(p.map)])=="server_chest" and p.is_admin())
{
send_reliable(p,"this chest has "+servermoney+" coins",2);
}
if(get_zone_at(p.x,p.y,p.z,maps[get_map_index(p.map)])=="donation_chest")
{
send_serverbox(p.peer_id, 2, -1, -1, -1, "insertdonations", "how many coins do you want to donate?");
}
for(uint i=0; i<candles.length(); i++)
{
if (p.map==candles[i].map.name and get_3d_distance(p.x, p.y, p.z, candles[i].x, candles[i].y, candles[i].z)<=2)
{
if(p.gettimer.elapsed>=1000)
{
p.gettimer.restart();
send_packet(6,"play spiked_iron_mace.ogg "+p.x+" "+p.y+" "+p.z, p.x,p.y,p.z,maps[get_map_index(p.map)]);
candles.remove_at(i);
continue;
}
}
}
if(is_clock(p.x,p.y,p.z,maps[get_map_index(p.map)]))
{
for (uint i=0; i<clocks.length(); i++)
{
if(clocks[i].map==p.map and clocks[i].minx<=p.x and clocks[i].maxx>=p.x and clocks[i].miny<=p.y and clocks[i].maxy>=p.y and clocks[i].minz<=p.z and clocks[i].maxz>=p.z)
{
send_reliable(p,""+(clocks[i].text=="empty"?""+get_time()+"":""+clocks[i].text+" "+get_time()+"")+"",2);
}
}
}
if(is_calendar(p.x,p.y,p.z,maps[get_map_index(p.map)]))
{
for (uint i=0; i<ccalendars.length(); i++)
{
if(ccalendars[i].map==p.map and ccalendars[i].minx<=p.x and ccalendars[i].maxx>=p.x and ccalendars[i].miny<=p.y and ccalendars[i].maxy>=p.y and ccalendars[i].minz<=p.z and ccalendars[i].maxz>=p.z)
{
send_reliable(p,""+(ccalendars[i].text=="empty"?""+get_date()+"":""+ccalendars[i].text+" "+get_date()+"")+"",2);
}
}
}
if(get_zone_at(p.x,p.y,p.z,maps[get_map_index(p.map)])=="credit_purchase_place")
{
send_serverbox(p.peer_id,2,-1,1,-1,"creditpurchase","How much credits would you like to buy?");
}
if(is_bed(p.x,p.y,p.z,maps[get_map_index(p.map)]))
{
if(p.sitting==0)
{
send_reliable(p,"you must be sitting to do this action",2);
}
else
{
send_packet(6,"play hammock.ogg "+p.x+" "+p.y+" "+p.z, p.x,p.y,p.z,maps[get_map_index(p.map)]);
p.sleep("");
}
}
if(get_zone_at(p.x,p.y,p.z,maps[get_map_index(p.map)])=="bank_service_desk")
{
if(p.contabancaria==1)send_reliable(p, "You already have a bank account!", 0);
else if(p.inv_item_number("coins")<50)send_reliable(p, "you must have 50 coins to do this action", 0);
else
{
p.inv_add_item("coins", -50);
p.balance+=50;
send_reliable(p, "stopmoving", 0);
send_packet(6,"play impressora.ogg "+p.x+" "+p.y+" "+p.z, p.x,p.y,p.z,maps[get_map_index(p.map)]);
p.tmaquina.restart();
p.cbank=true;
}
}
if(get_zone_at(p.x,p.y,p.z,maps[get_map_index(p.map)])=="cash_machine")
{
if(p.contabancaria==0)
{
send_reliable(p, "you haven't bank account", 0);
return;
}
string[] add;
add.insert_last("Bank, Here you have more value:int caixa_eletrnico");
add.insert_last("Check your funds:cbalance");
add.insert_last("Withdraw:sac");
add.insert_last("Deposit:dep");
add.insert_last("Deposit in other account:dep2");
send_reliable(p, "mnormal "+linear(add), 0);
}
if(get_zone_at(p.x,p.y,p.z,maps[get_map_index(p.map)])=="safezone_menu" and p.map=="safezone")
{
server_menu m;
m.intro="safe zone menu.";
m.initial_packet="safezonemenu";
m.add("public maps","publicmaps");
m.add("challenge maps","challengemaps");
m.add("your maps","yourmaps");
m.add("make a new map","newmap");
m.add("arena","arena");
m.send(p.peer_id);
}
int v=get_vending_index(p.x,p.y,p.z,p.map);
if(v>-1)
{
send_serverbox(e.peer_id,1,-1,1,1,"vendingpress","Press Space to buy something and get the menu. Press C to see how many coins are in the machine. Press r to return any money inside the machine. Press escape to cancel");
}
for(int i=0; i<stores.length(); i++)
{
if(get_zone_at(p.x,p.y,p.z,maps[get_map_index(p.map)])==stores[i].name)
{
stores[i].send(p.peer_id,false);
}
}
for(int i=0; i<paid_stores.length(); i++)
{
if(get_zone_at(p.x,p.y,p.z,maps[get_map_index(p.map)])==paid_stores[i].name)
{
paid_stores[i].send(p.peer_id,false);
}
}
for(int i=0; i<team_stores.length(); i++)
{
if(get_zone_at(p.x,p.y,p.z,maps[get_map_index(p.map)])==team_stores[i].name)
{
int t=is_in_team(p.name);
if(t<0)
{
send_reliable(p,"You are not in a team",2);
return;
}
if(teams[t].teamleader!=p.name)
{
send_reliable(p,"You are not the team leader to purchase items from this store",2);
return;
}
team_stores[i].send(p.peer_id,false);
}
}
}
else if(parsed[0]=="eenter")
{
for(uint i=0; i<houses.length(); i++)
{
if(houses[i].x==p.x and houses[i].y==p.y and houses[i].z==p.z and houses[i].map==p.map)
{
send_serverbox(p.peer_id, 2, 4, 0, -1, "enterhouse", "enter the house code");
}
}
for(uint i=0; i<beehives.length(); i++)
{
if(beehives[i].map==p.map and beehives[i].x==p.x and beehives[i].y==p.y and beehives[i].z==p.z)
{
int mi=get_map_index(beehives[i].beehivemap);
if((mi>-1))
{
move_player(p,beehives[i].beehivemap,random(maps[mi].spminx,maps[mi].spmaxx),random(maps[mi].spminy,maps[mi].spmaxy),random(maps[mi].spminz,maps[mi].spmaxz),false);
send_reliable(p,"enterplace "+beehives[i].x+" "+beehives[i].y+" "+beehives[i].z+" "+beehives[i].map,0);
}
}
}
for(uint i=0; i<playerstores.length(); i++)
{
if(playerstores[i].x==p.x and playerstores[i].y==p.y and playerstores[i].z==p.z and playerstores[i].map==p.map)
{
int psowner=get_player_index_from(playerstores[i].owner);
if(psowner<0 or players[psowner].gender==0 and players[psowner].job!="salesman" or players[psowner].gender==1 and players[psowner].job!="saleswoman")
{
send_reliable(p,"This store is currently closed",2);
}
int mi=get_map_index(playerstores[i].playerstoremap);
if((mi>-1))
{
move_player(p,playerstores[i].playerstoremap,random(maps[mi].spminx,maps[mi].spmaxx),random(maps[mi].spminy,maps[mi].spmaxy),random(maps[mi].spminz,maps[mi].spmaxz),false);
send_packet(6,"play dooropen32.ogg "+playerstores[i].x+" "+playerstores[i].y+" "+playerstores[i].z, playerstores[i].x,playerstores[i].y,playerstores[i].z,maps[get_map_index(playerstores[i].map)]);
send_packet(6,"play dooropen32.ogg "+0+", "+0+", "+0, playerstores[i].x,playerstores[i].y,playerstores[i].z,maps[get_map_index(playerstores[i].playerstoremap)]);
send_reliable(p,"enterplace "+playerstores[i].x+" "+playerstores[i].y+" "+playerstores[i].z+" "+playerstores[i].map,0);
}
}
}
if(p.x==1 and p.y==1 and p.z==0 and in_house(p)>-1)
{
int stuff=in_house(p);
if(stuff<0) {}
else
{
move_player(p,houses[stuff].map,houses[stuff].x,houses[stuff].y,houses[stuff].z);
send_reliable(p,"exitplace",0);
}
}
if(p.x==0 and p.y==0 and p.z==0 and in_beehive(p)>-1)
{
int stuff=in_beehive(p);
if(stuff<0) {}
else
{
move_player(p,beehives[stuff].map,beehives[stuff].x,beehives[stuff].y,beehives[stuff].z);
send_reliable(p,"exitplace",0);
}
}
if(p.x==0 and p.y==0 and p.z==0 and in_playerstore(p)>-1)
{
int stuff=in_playerstore(p);
if(stuff<0) {}
else
{
int psowner=get_player_index_from(playerstores[stuff].owner);
if(psowner<0 or players[psowner].gender==0 and players[psowner].job!="salesman" or players[psowner].gender==1 and players[psowner].job!="saleswoman")
{
send_reliable(p,"This store is currently closed",2);
}
int mi=get_map_index(playerstores[stuff].playerstoremap);
if((mi>-1))
{
move_player(p,playerstores[stuff].map,playerstores[stuff].x,playerstores[stuff].y,playerstores[stuff].z);
send_packet(6,"play doorclose35.ogg "+playerstores[stuff].x+" "+playerstores[stuff].y+" "+playerstores[stuff].z, playerstores[stuff].x,playerstores[stuff].y,playerstores[stuff].z,maps[get_map_index(playerstores[stuff].map)]);
send_packet(6,"play doorclose35.ogg "+0+", "+0+", "+0, playerstores[stuff].x,playerstores[stuff].y,playerstores[stuff].z,maps[get_map_index(playerstores[stuff].playerstoremap)]);
send_reliable(p,"exitplace",0);
}
}
}
}
else if(parsed[0]=="travelto" and parsed.length()>4)
{
int nx=string_to_number(parsed[1]);
int ny=string_to_number(parsed[2]);
int nz=string_to_number(parsed[3]);
string nmap=parsed[4];
if(map_exists(nmap))
{
int pmapind=get_map_index(p.map);
if(pmapind>-1)
{
if(maps[pmapind].chminx<=p.x and maps[pmapind].chmaxx>=p.x and maps[pmapind].chminy<=p.y and maps[pmapind].chmaxy>=p.y and maps[pmapind].chminz<=p.z and maps[pmapind].chmaxz>=p.z and maps[pmapind].finishitem!="" and maps[pmapind].finishamount>0)
{
if(maps[pmapind].finishitem=="coins" or maps[pmapind].finishitem=="credit")
{
p.inv_add_item(maps[pmapind].finishitem,round(maps[pmapind].finishamount-(p.finishchallengemaptimer.elapsed/10000),0));
send_reliable(p,"as a reward, you've recieved "+round(maps[pmapind].finishamount-(p.finishchallengemaptimer.elapsed/10000),0)+" "+maps[pmapind].finishitem+"",2);
send_reliable(0,"maps "+p.name+" finished "+p.map+" in "+ms_to_readable_time(p.finishchallengemaptimer.elapsed)+" and won "+round(maps[pmapind].finishamount-(p.finishchallengemaptimer.elapsed/10000),0)+" "+maps[pmapind].finishitem+"!",0);
}
else
{
p.inv_add_item(maps[pmapind].finishitem,maps[pmapind].finishamount);
send_reliable(p,"as a reward, you've recieved "+maps[pmapind].finishamount+" "+maps[pmapind].finishitem+"",2);
send_reliable(0,"maps "+p.name+" finished "+p.map+" in "+ms_to_readable_time(p.finishchallengemaptimer.elapsed)+" and won "+maps[pmapind].finishamount+" "+maps[pmapind].finishitem+"!",0);
}
p.finishchallengemaptimer.force(0);
p.finishchallengemaptimer.pause();
}
}
int nind=get_map_index(nmap);
if(nind>-1)
{
if(TIME_HOUR<maps[nind].minhour or TIME_HOUR>maps[nind].maxhour)
{
send_reliable(p,""+maps[nind].name+" is currently closed. Opening hours: "+maps[nind].minhour+" until "+maps[nind].maxhour+"",2);
return;
}
if(p.level<maps[nind].minlevel or p.level>maps[nind].maxlevel)
{
send_reliable(p,""+maps[nind].name+" is only for players with level range of "+maps[nind].minlevel+" until "+maps[nind].maxlevel+"",2);
return;
}
if(p.reinforcement<maps[nind].minreinforcement or p.reinforcement>maps[nind].maxreinforcement)
{
send_reliable(p,""+maps[nind].name+" is only for players with reinforcement range of "+maps[nind].minreinforcement+" until "+maps[nind].maxreinforcement+"",2);
return;
}
string mdata=maps[nind].rawdata;
string[] p1=delinear(mdata);
for(uint i=0; i<p1.length(); i++)
{
string[] parsed=string_split(p1[i], ":", true);
if(parsed[0]=="safezone" and parsed.length()>6 and p.pvp==1)
{
send_reliable(p,"you can't enter this map when you are pvp",2);
return;
}
}
int v=in_vehicle(p);
int m=in_motor(p);
if(v>-1 or m>-1)
{
string mdata=maps[nind].rawdata;
string[] p1=delinear(mdata);
for(uint i=0; i<p1.length(); i++)
{
string[] parsed=string_split(p1[i], ":", true);
if(parsed[0]=="safezone" and parsed.length()>6)
{
send_reliable(p,"you can't enter this map when you are pvp",2);
return;
}
}
}
}
if(in_house(p)>-1)
{
int h=in_house(p);
f.open("maps/"+p.map+".map","rb");
string[] lines=string_split(f.read(),"\r\n",false);
f.close();
for(uint i=0; i<lines.length(); i++)
{
string[] ld=string_split(lines[i],":",false);
if(ld[0]=="owner" and ld[1]==p.name and p.is_admin()==false)
{
f.open("maps/"+nmap+".map","rb");
string[] lines=string_split(f.read(),"\r\n",false);
f.close();
int something=lines.find("owner:"+p.name+"");
if(something<0)
{
string[] a=string_split(file_get_contents("chmaps.svr"),"\r\n",false);
int something=a.find(p.map);
if(something<0)
{
send_reliable(p,"you can't go to a map that you aren't owner of it",2);
return;
}
}
}
}
}
else
{
f.open("maps/"+p.map+".map","rb");
string[] lines=string_split(f.read(),"\r\n",false);
f.close();
for(uint i=0; i<lines.length(); i++)
{
string[] ld=string_split(lines[i],":",false);
if(ld[0]=="owner" and ld[1]==p.name and p.is_admin()==false)
{
f.open("maps/"+nmap+".map","rb");
string[] lines=string_split(f.read(),"\r\n",false);
f.close();
int something=lines.find("owner:"+p.name+"");
if(something<0)
{
string[] a=string_split(file_get_contents("chmaps.svr"),"\r\n",false);
int somethinga=a.find(p.map);
if(somethinga<0)
{
send_reliable(p,"you can't go to a map that you aren't owner of it",2);
return;
}
}
}
}
}
move_player(p,nmap,nx,ny,nz,true);
int v=in_vehicle(p);
if(v>-1)
{
vs[v].x=p.x;
vs[v].y=p.y;
vs[v].z=p.z;
vs[v].map=p.map;
}
int m=in_motor(p);
if(m>-1)
{
mos[m].x=p.x;
mos[m].y=p.y;
mos[m].z=p.z;
mos[m].map=p.map;
}
int mapindex=get_map_index(p.map);
if((mapindex>-1 and maps[mapindex].pvp==1 and maps[mapindex].pvpminx<=p.x and maps[mapindex].pvpmaxx>=p.x and maps[mapindex].pvpminy<=p.y and maps[mapindex].pvpmaxy>=p.y and maps[mapindex].pvpminz<=p.z and maps[mapindex].pvpmaxz>=p.z))
{
if(p.pvp!=1)
{
p.pvp=1;
send_reliable(p,"You are now pvp!",2);
send_reliable(0,"play_s pvpon.ogg",6);
send_reliable(0,""+p.nickname+" is now pvp!",2);
}
}
}
else
{
send_reliable(p,"this map does not exists",2);
return;
}
}
else if(parsed[0]=="enterhouse")
{
int code=string_to_number(parsed[1]);
int h=get_house_index(p.x, p.y, p.z,maps[get_map_index(p.map)]);
if(h>-1)
{
if(houses[h].code==code)
{
int mi=get_map_index(houses[h].housemap);
if((mi>-1))
{
move_player(p,houses[h].housemap,random(maps[mi].spminx,maps[mi].spmaxx),random(maps[mi].spminy,maps[mi].spmaxy),random(maps[mi].spminz,maps[mi].spmaxz),false);
send_reliable(p,"enterplace "+houses[h].x+" "+houses[h].y+" "+houses[h].z+" "+houses[h].map,0);
}
}
else
{
send_reliable(p, "wrong code", 0);
return;
}
}
}
else if(parsed[0]=="creditpurchase" and parsed.length()>1)
{
if(parsed[1]=="back")
{
p.sendpacket("canceled", 0);
return;
}
int amount=string_to_number(parsed[1]);
send_reliable(p,"creditpurchase "+p.name+" "+amount,0);
}
else if(parsed[0]=="playonmap" and parsed.length()>1)
{
int x=p.x;
int y=p.y;
int z=p.z;
string map=p.map;
for(uint i=0; i<players.length(); i++)
{
if(players[i].name!=p.name)
{
send_reliable(players[i],string_replace(parsed[1],".ogg","",true)+" "+x+" "+y+" "+z+" "+map,3);
}
}
}
else if(parsed[0]=="playsnd" and parsed.length()>1)
{
string soundstring=string_replace(parsed[1], ".ogg","",true);
send_packet(6,"play "+soundstring+".ogg "+p.x+" "+p.y+" "+p.z, p.x,p.y,p.z,maps[get_map_index(p.map)]);
}
else if(parsed[0]=="apacket" and cid!=-1)
{
send_reliable(cid,string_trim_left(get_event_message(),8),2);
}
else if(parsed[0]=="cheatengine" or parsed[0]=="speedhacking")
{
send_reliable(0,p.name+" just got caught speedhacking",2);
remove_player(p.name);
}
else if(parsed[0]=="turn" and parsed.length()>1)
{
p.facing=string_to_number(parsed[1]);
}
else if(parsed[0]=="tturn" and parsed.length()>1)
{
p.ffacing=string_to_number(parsed[1]);
}
else if(parsed[0]=="purchase" and parsed.length()>2)
{
if(in_playerstore(p)>-1)
{
pspurchase(parsed[1],string_to_number(parsed[2]),p);
}
else
{
purchase(parsed[1],string_to_number(parsed[2]),p);
}
}
else if(parsed[0]=="paid_purchase" and parsed.length()>2)
{
paid_purchase(parsed[1],string_to_number(parsed[2]),p);
}
else if(parsed[0]=="team_purchase" and parsed.length()>2)
{
team_purchase(parsed[1],string_to_number(parsed[2]),p);
}
else if(parsed[0]=="buysomething" and parsed.length()>1)
{
if(parsed[1]=="back") return;
if(parsed[1]=="sky_racer" or parsed[1]=="ford" or parsed[1]=="sorento" or parsed[1]=="BMV" or parsed[1]=="dogan_slx" or parsed[1]=="grayhound_bus" or parsed[1]=="m60_tank" or parsed[1]=="police_car" or parsed[1]=="police_car_pluss" or parsed[1]=="tank" or parsed[1]=="truck" or parsed[1]=="v4_by_4_jeep" or parsed[1]=="dodge_charger" or parsed[1]=="doom_buggy" or parsed[1]=="ford_pickup_truck" or parsed[1]=="mlk_mission_cruiser" or parsed[1]=="muscle_car")
{
if(in_playerstore(p)>-1)
{
pspurchase(parsed[1],1,p);
}
else
{
purchase(parsed[1],1,p);
}
}
else send_serverbox(p.peer_id, 2, 1, 0, -1, "purchase "+parsed[1], "type the amount you wish to buy");
}
else if(parsed[0]=="paid_buysomething" and parsed.length()>1)
{
if(parsed[1]=="back") return;
send_serverbox(p.peer_id, 2, 1, 0, -1, "paid_purchase "+parsed[1], "type the amount you wish to buy");
}
else if(parsed[0]=="xp_potion_paid_buysomething" and parsed.length()>1)
{
if(parsed[1]=="back") return;
send_serverbox(p.peer_id, 2, 1, 0, -1, "paid_purchase "+parsed[1], "for how much minutes do you want to have the potion?");
}
else if(parsed[0]=="team_buysomething" and parsed.length()>1)
{
if(parsed[1]=="back") return;
send_serverbox(p.peer_id, 2, 1, 0, -1, "team_purchase "+parsed[1], "type the amount you wish to buy");
}
else if(parsed[0]=="revive")
{
if(p.is_dead=true)
{
respawn(p);
}
}
else if(parsed[0]=="message")
{
string ms;
if(p.langchan=="disable_chat")ms+="you've disabled chatting";
else if(p.langchan=="arabic" and arabicmessage=="")ms+="no message has been set for "+p.langchan+" channel";
else if(p.langchan=="free_channel" and free_channelmessage=="")ms+="no message has been set for "+p.langchan+" channel";
else if(p.langchan=="english" and englishmessage=="")ms+="no message has been set for "+p.langchan+" channel";
else if(p.langchan=="german" and germanmessage=="")ms+="no message has been set for "+p.langchan+" channel";
else if(p.langchan=="indonesian" and indonesianmessage=="")ms+="no message has been set for "+p.langchan+" channel";
else if(p.langchan=="malay" and malaymessage=="")ms+="no message has been set for "+p.langchan+" channel";
else if(p.langchan=="persian" and persianmessage=="")ms+="no message has been set for "+p.langchan+" channel";
else if(p.langchan=="polish" and polishmessage=="")ms+="no message has been set for "+p.langchan+" channel";
else if(p.langchan=="portuguese" and portuguesemessage=="")ms+="no message has been set for "+p.langchan+" channel";
else if(p.langchan=="russian" and russianmessage=="")ms+="no message has been set for "+p.langchan+" channel";
else if(p.langchan=="slovak" and slovakmessage=="")ms+="no message has been set for "+p.langchan+" channel";
else if(p.langchan=="spanish"and spanishmessage=="")ms+="no message has been set for "+p.langchan+" channel";
else if(p.langchan=="thai"and thaimessage=="")ms+="no message has been set for "+p.langchan+" channel";
else if(p.langchan=="turkish"and turkishmessage=="")ms+="no message has been set for "+p.langchan+" channel";
else
{
if(p.langchan=="disable_chat")ms+="you've disabled chatting";
else
{
ms=""+p.langchan+" channel message: ";
if(p.langchan=="arabic")ms+=arabicmessage;
else if(p.langchan=="free_channel")ms+=free_channelmessage;
else if(p.langchan=="english")ms+=englishmessage;
else if(p.langchan=="german")ms+=germanmessage;
else if(p.langchan=="indonesian")ms+=indonesianmessage;
else if(p.langchan=="malay")ms+=malaymessage;
else if(p.langchan=="persian")ms+=persianmessage;
else if(p.langchan=="polish")ms+=polishmessage;
else if(p.langchan=="portuguese")ms+=portuguesemessage;
else if(p.langchan=="russian")ms+=russianmessage;
else if(p.langchan=="slovak")ms+=slovakmessage;
else if(p.langchan=="spanish")ms+=spanishmessage;
else if(p.langchan=="thai")ms+=thaimessage;
else if(p.langchan=="turkish")ms+=turkishmessage;
}
}
send_reliable(p, ms, 2);
}
else if(parsed[0]=="bmessage")
{
if(p.langchan=="disable_chat")send_reliable(p,"you've disabled chatting", 2);
else if(p.langchan=="arabic" and arabicmessage=="")send_reliable(p,"no message has been set for "+p.langchan+" channel", 2);
else if(p.langchan=="free_channel" and free_channelmessage=="")send_reliable(p,"no message has been set for "+p.langchan+" channel", 2);
else if(p.langchan=="english" and englishmessage=="")send_reliable(p,"no message has been set for "+p.langchan+" channel", 2);
else if(p.langchan=="german" and germanmessage=="")send_reliable(p,"no message has been set for "+p.langchan+" channel", 2);
else if(p.langchan=="indonesian" and indonesianmessage=="")send_reliable(p,"no message has been set for "+p.langchan+" channel", 2);
else if(p.langchan=="malay" and malaymessage=="")send_reliable(p,"no message has been set for "+p.langchan+" channel", 2);
else if(p.langchan=="persian" and persianmessage=="")send_reliable(p,"no message has been set for "+p.langchan+" channel", 2);
else if(p.langchan=="polish" and polishmessage=="")send_reliable(p,"no message has been set for "+p.langchan+" channel", 2);
else if(p.langchan=="portuguese" and portuguesemessage=="")send_reliable(p,"no message has been set for "+p.langchan+" channel", 2);
else if(p.langchan=="russian" and russianmessage=="")send_reliable(p,"no message has been set for "+p.langchan+" channel", 2);
else if(p.langchan=="slovak" and slovakmessage=="")send_reliable(p,"no message has been set for "+p.langchan+" channel", 2);
else if(p.langchan=="spanish"and spanishmessage=="")send_reliable(p,"no message has been set for "+p.langchan+" channel", 2);
else if(p.langchan=="thai"and thaimessage=="")send_reliable(p,"no message has been set for "+p.langchan+" channel", 2);
else if(p.langchan=="turkish"and turkishmessage=="")send_reliable(p,"no message has been set for "+p.langchan+" channel", 2);
else
{
if(p.langchan=="disable_chat")send_reliable(p,"you've disabled chatting", 2);
else
{
server_menu2 m;
m.intro=""+p.langchan+" channel message: press enter on each line to copy it in to your clipboard";
m.initial_packet="copy";
string d;
if(p.langchan=="arabic") d=arabicmessage;
else if(p.langchan=="free_channel") d=free_channelmessage;
else if(p.langchan=="english") d=englishmessage;
else if(p.langchan=="german") d=germanmessage;
else if(p.langchan=="indonesian") d=indonesianmessage;
else if(p.langchan=="malay") d=malaymessage;
else if(p.langchan=="persian") d=persianmessage;
else if(p.langchan=="polish") d=polishmessage;
else if(p.langchan=="portuguese") d=portuguesemessage;
else if(p.langchan=="russian") d=russianmessage;
else if(p.langchan=="slovak") d=slovakmessage;
else if(p.langchan=="spanish") d=spanishmessage;
else if(p.langchan=="thai") d=thaimessage;
else if(p.langchan=="turkish") d=turkishmessage;
string[] lines=string_split(d,"\r\n",false);
for(uint i=0; i<lines.length(); i++)
{
m.add(lines[i],lines[i]);
}
m.send(p.peer_id);
}
}
}
else if(parsed[0]=="close")
{
log("disconnections",p.name+" lost connection",true,true);
for(uint i2=0; i2<arenas.length(); i2++)
{
if(p.map==arenas[i2].map)
{
p.bullet_proof_vested=0;
p.bullet_proof_vestshots=0;
p.armored=0;
p.armorshots=0;
p.large_armor_plated=0;
p.large_armor_plateshots=0;
p.shielded=0;
p.shieldshots=0;
p.steel_shielded=0;
p.steel_shieldshots=0;
p.hurtlevel=0;
p.hurttimer.restart();
p.healtimer.restart();
p.poisoned=false;
p.hurt=false;
p.cbombplacing=false;
p.drunk=false;
if(p.weapon_name!="fists")
{
p.weapon_name="fists";
if(p.weapon_ammos>0)
p.inv_add_item(p.weapon_ammo_type, p.weapon_ammos);
p.firetimer=180;
p.weapon_ammos=0;
p.weapon_ammo_type="";
p.weapon_copasity=0;
send_reliable(p, "notrapid", 0);
}
int newx=string_to_number(get_char_val(p.name,"oldx"));
int newy=string_to_number(get_char_val(p.name,"oldy"));
int newz=string_to_number(get_char_val(p.name,"oldz"));
string charfolder="chars/"+p.name;
scd(p);
if(p.inv.get_size()>0) p.inv.delete_all();
file_copy(charfolder+"/oldinv.usr",charfolder+"/inv.usr",true);
if(p.inv.get_size()<1) p.inv_add_item("starter_pack",1);
load_char_data(p,true);
file_delete(charfolder+"/oldx.usr");
file_delete(charfolder+"/oldy.usr");
file_delete(charfolder+"/oldz.usr");
file_delete(charfolder+"/oldmap.usr");
file_delete(charfolder+"/oldinv.usr");
move_player(p,"safezone",newx,newy,newz);
arenas[i2].joined--;
int amath=arenas[i2].length-arenas[i2].joined;
if(arenas[i2].length>1) send_reliable(0,"arena "+p.name+" has escaped from "+arenas[i2].owner+"'s "+arenas[i2].type+" Arena. "+amath+" participators stil left.",0);
else send_reliable(0,"arena "+p.name+" has escaped from "+arenas[i2].owner+"'s "+arenas[i2].type+" Arena",0);
if(p.pvpd==1 and p.pvp==1)
{
p.pvp=0;
p.pvpd=0;
}
if(p.pvpd==3)
{
p.pvp=1;
p.pvpd=2;
}
remove_player(p.name,true);
return;
}
}
if(cheatercheck(p)||p.cheater==1||file_exists("chars/"+p.name+"/cheater.usr"))
{
create_temp_ban(p.name,60000);
write_to(p.name,"cheater.usr",p.name+" is a cheater! They closed the game in "+ms_to_readable_time(p.statchangetimer.elapsed)+" of being hit");
send_reliable(0,p.name+" is a cheater!",2);
p.persisttimer.restart();
p.disconnected=true;
}
else if(auctionwho==p.name)
{
create_temp_ban(p.name,30000);
p.persisttimer.restart();
p.disconnected=true;
}
else if(auctionwho2==p.name)
{
create_temp_ban(p.name,30000);
p.persisttimer.restart();
p.disconnected=true;
}
else if(p.nuclearbombspawned==1)
{
create_temp_ban(p.name,60000);
p.persisttimer.restart();
p.disconnected=true;
}
else
{
remove_player(p.name,true);
}
}
else if(parsed[0]=="changeeml" and parsed.length()>2)
{
if(directory_exists("chars/"+parsed[1])==false)
{
send_reliable(p,"nochar",0);
return;
}
f.open("chars/"+parsed[1]+"/eml.usr","wb");
f.write(parsed[2]);
f.close();
send_reliable(p,"changed",0);
}
else if(parsed[0]=="levelcheck")
{
int ind=get_player_index_from(p.looking);
if(ind>-1)
{
if(players[ind].gender==0)players[ind].gender2="he";
else players[ind].gender2="she";
send_reliable(p,""+players[ind].name+" is level "+players[ind].level+" and in reinforcement "+players[ind].reinforcement+". "+players[ind].gender2+" has "+players[ind].xp+" experience And "+players[ind].gender2+" next level requireds "+(players[ind].xprequired-players[ind].xp)+" experience",2);
}
else
{
send_reliable(p,"you are level "+p.level+" and in reinforcement "+p.reinforcement+". You have "+p.xp+" experience And Your next level requireds "+(p.xprequired-p.xp)+" experience",2);
}
}
else if(parsed[0]=="xpcheck")
{
int ind=get_player_index_from(p.looking);
if(ind>-1)
{
send_reliable(p,""+players[ind].name+" has "+players[ind].xp+" experience",2);
}
else
{
send_reliable(p,"you have "+p.xp+" experience",2);
}
}
else if(parsed[0]=="xprcheck")
{
int ind=get_player_index_from(p.looking);
if(ind>-1)
{
if(p.gender==0)p.gender2="he";
else p.gender2="she";
send_reliable(p,""+players[ind].gender2+" next level requireds "+(players[ind].xprequired-players[ind].xp)+" experience",2);
}
else
{
send_reliable(p,"Your next level requireds "+(p.xprequired-p.xp)+" experience",2);
}
}
else if(parsed[0]=="ffhhealth" and parsed.length()>1)
{
p.health-=string_to_number(parsed[1]);
}
else if(parsed[0]=="hhealth")
{
p.health=0;
}
else if(parsed[0]=="healthcheck")
{
int ind=get_player_index_from(p.looking);
if(ind>-1)
{
int v2=in_vehicle(players[ind]);
int m2=in_motor(players[ind]);
if(v2<0 and m2<0 and players[ind].bullet_proof_vested==0 and players[ind].armored==0 and players[ind].large_armor_plated==0 and players[ind].shielded==0 and players[ind].steel_shielded==0) send_reliable(p," "+players[ind].name+" has "+players[ind].health+" health",2);
else if(players[ind].bullet_proof_vested==1) send_reliable(p,""+players[ind].name+" has "+players[ind].health+" health, with "+players[ind].bullet_proof_vestshots+" shots",2);
else if(players[ind].armored==1) send_reliable(p,""+players[ind].name+" has "+players[ind].health+" health, with "+players[ind].armorshots+" shots",2);
else if(players[ind].large_armor_plated==1) send_reliable(p,""+players[ind].name+" has "+players[ind].health+" health, with "+players[ind].large_armor_plateshots+" shots",2);
else if(players[ind].shielded==1) send_reliable(p," "+players[ind].name+" has "+players[ind].health+" health, with "+players[ind].shieldshots+" shielded shots",2);
else if(players[ind].steel_shielded==1) send_reliable(p," "+players[ind].name+" has "+players[ind].health+" health, with "+players[ind].steel_shieldshots+" shielded shots",2);
if(v2>-1) {
int ms2=vs[v2].fuel*(100/0.1)*(vs[v2].fueltime-(vs[v2].vfueltime*(vs[v2].speed-1)));
if(vs[v2].type=="v4_by_4_jeep") send_reliable(p,""+players[ind].name+"'s 4_by_4_jeep has "+vs[v2].health+" health, and "+vs[v2].fuel+"% fuel. Last hit by "+vs[v2].hitby,0);
else send_reliable(p,""+players[ind].name+"'s "+vs[v2].type+" has "+vs[v2].health+" health, and "+vs[v2].fuel+"% fuel. Last hit by "+vs[v2].hitby,0);
}
else if(m2>-1) {
int ms2=mos[m2].fuel*(100/0.1)*(mos[m2].fueltime-(mos[m2].fueltime*(mos[m2].speed-1)));
send_reliable(p,""+players[ind].name+"'s "+mos[m2].type+" has "+mos[m2].health+" health, and "+mos[m2].fuel+"% fuel. Last hit by "+mos[m2].hitby,0);
}
}
else
{
int v=in_vehicle(p);
int m=in_motor(p);
if(v<0 and m<0 and p.bullet_proof_vested==0 and p.armored==0 and p.large_armor_plated==0 and p.shielded==0 and p.steel_shielded==0) send_reliable(p,""+p.health+" health",2);
else if(p.bullet_proof_vested==1) send_reliable(p,""+p.health+" health, with "+p.bullet_proof_vestshots+" shots",2);
else if(p.armored==1) send_reliable(p,""+p.health+" health, with "+p.armorshots+" shots",2);
else if(p.large_armor_plated==1) send_reliable(p,""+p.health+" health, with "+p.large_armor_plateshots+" shots",2);
else if(p.shielded==1) send_reliable(p,""+p.health+" health, with "+p.shieldshots+" shielded shots",2);
else if(p.steel_shielded==1) send_reliable(p,""+p.health+" health, with "+p.steel_shieldshots+" shielded shots",2);
if(v>-1) {
int ms=vs[v].fuel*(100/0.1)*(vs[v].fueltime-(vs[v].vfueltime*(vs[v].speed-1)));
if(vs[v].type=="v4_by_4_jeep") send_reliable(p,"your 4_by_4_jeep has "+vs[v].health+" health, and "+vs[v].fuel+"% fuel. Last hit by "+vs[v].hitby,2);
else send_reliable(p,"your "+vs[v].type+" has "+vs[v].health+" health, and "+vs[v].fuel+"% fuel. Last hit by "+vs[v].hitby,2);
}
else if(m>-1) {
int ms=mos[m].fuel*(100/0.1)*(mos[m].fueltime-(mos[m].fueltime*(mos[m].speed-1)));
send_reliable(p,"speak your "+mos[m].type+" has "+mos[m].health+" health, and "+mos[m].fuel+"% fuel. Last hit by "+mos[m].hitby,0);
}
}
}
else if(parsed[0]=="speedcheck")
{
int ind=get_player_index_from(p.looking);
if(ind>-1)
{
int v2=in_vehicle(players[ind]);
int m2=in_motor(players[ind]);
if(v2>-1)
{
if(vs[v2].type=="v4_by_4_jeep") send_reliable(p,""+players[ind].name+"'s 4_by_4_jeep speed is "+vs[v2].speed,2);
else send_reliable(p,""+players[ind].name+"'s "+vs[v2].type+" speed is "+vs[v2].speed,2);
}
else if(m2>-1)
{
send_reliable(p,""+players[ind].name+"'s "+mos[m2].type+" speed is "+mos[m2].speed,2);
}
}
else
{
int v=in_vehicle(p);
int m=in_motor(p);
if(v>-1)
{
if(vs[v].type=="v4_by_4_jeep") send_reliable(p,"your 4_by_4_jeep's speed is "+vs[v].speed,0);
else send_reliable(p,"your "+vs[v].type+"'s speed is "+vs[v].speed,0);
}
else if(m>-1)
{
send_reliable(p,"your "+mos[m].type+"'s speed is "+mos[m].speed,0);
}
}
}
else if(parsed[0]=="energycheck")
{
int ind=get_player_index_from(p.looking);
if(ind>-1)
{
send_reliable(p,""+players[ind].name+" has "+players[ind].energy+" energy",2);
}
else
{
send_reliable(p,""+p.energy+" energy",2);
}
}
else if(parsed[0]=="drunkcheck")
{
int ind=get_player_index_from(p.looking);
if(ind>-1)
{
if(players[ind].gender==0)players[ind].gender2="hes";
else players[ind].gender2="her";
send_reliable(p,""+players[ind].gender2+" "+(players[ind].drunkstage==0?"not":""+players[ind].drunkstage*2+"%")+" drunk",2);
}
else
{
send_reliable(p,"you are "+(p.drunkstage==0?"not":""+p.drunkstage*2+"%")+" drunk",2);
}
}
else if(parsed[0]=="thirstcheck")
{
int ind=get_player_index_from(p.looking);
if(ind>-1)
{
send_reliable(p,""+players[ind].thirst+" /1000 thirst",2);
}
else
{
send_reliable(p,""+p.thirst+" /1000 thirst",2);
}
}
else if(parsed[0]=="hungercheck")
{
int ind=get_player_index_from(p.looking);
if(ind>-1)
{
send_reliable(p,""+players[ind].hunger+" /1000 hunger",2);
}
else
{
send_reliable(p," "+p.hunger+" /1000 hunger",2);
}
}
else if(parsed[0]=="fullcheck")
{
int ind=get_player_index_from(p.looking);
if(ind>-1)
{
send_reliable(p,""+players[ind].name+" is "+(round(percent(players[ind].nthirst,players[ind].nthirst+players[ind].nhunger),0)==0?"not":""+round(percent(players[ind].nthirst,players[ind].nthirst+players[ind].nhunger),0)+"%")+" full",2);
}
else
{
send_reliable(p,"you are "+(round(percent(p.nthirst,p.nthirst+p.nhunger),0)==0?"not":""+round(percent(p.nthirst,p.nthirst+p.nhunger),0)+"%")+" full",2);
}
}
else if(parsed[0]=="sickcheck")
{
int ind=get_player_index_from(p.looking);
if(ind>-1)
{
send_reliable(p,""+players[ind].name+" is "+(players[ind].sick==0?"not":""+players[ind].sick+"%")+" sick",2);
}
else
{
send_reliable(p,"you are "+(p.sick==0?"not":""+p.sick+"%")+" sick",2);
}
}
else if(parsed[0]=="factorcheck")
{
int ind=get_player_index_from(p.looking);
if(ind>-1)
{
send_reliable(p,""+players[ind].name+" is "+players[ind].dirty+"% dirty, and "+players[ind].wet+"% wet",2);
}
else
{
send_reliable(p,"you are "+p.dirty+"% dirty, and "+p.wet+"% wet",2);
}
}
else if(parsed[0]=="bonescheck")
{
int ind=get_player_index_from(p.looking);
if(ind>-1)
{
if(players[ind].gender==0)players[ind].gender2="his";
else players[ind].gender2="shis";
send_reliable(p,""+(players[ind].bone_break==true?""+players[ind].gender+" "+players[ind].bonebreak+" is "+players[ind].bone_level/10+"% broken":""+players[ind].gender+" OK")+"",2);
}
else
{
send_reliable(p,""+(p.bone_break==true?"Your "+p.bonebreak+" is "+p.bone_level/10+"% broken":"Your OK")+"",2);
}
}
else if(parsed[0]=="temperaturecheck")
{
int ind=get_player_index_from(p.looking);
if(ind>-1)
{
if(players[ind].gender==0)players[ind].gender2="his";
else players[ind].gender2="shis";
send_reliable(p,""+players[ind].gender2+" "+players[ind].temperature+"",2);
}
else
{
send_reliable(p,"your "+p.temperature+"",2);
}
}
else if(parsed[0]=="maptimecheck")
{
int ind=get_player_index_from(p.looking);
if(ind>-1)
{
int pmapind=get_map_index(players[ind].map);
if(pmapind>-1)
{
string charfolder="chars/"+players[ind].name;
string[] a=string_split(file_get_contents("pbmaps.svr"),"\r\n",false);
string[] a2=string_split(file_get_contents(charfolder+"/maps.usr"),"\r\n",false);
string[] a3=string_split(file_get_contents("chmaps.svr"),"\r\n",false);
int something=a.find(players[ind].map);
int something2=a2.find(players[ind].map);
int something3=a3.find(players[ind].map);
if(something>-1 or something2>-1 or something3>-1)
{
if(players[ind].gender==0)players[ind].gender2="his";
else players[ind].gender2="shis";
send_reliable(p,""+players[ind].gender2+" in "+players[ind].map+" map for "+ms_to_readable_time(players[ind].finishchallengemaptimer.elapsed)+"",2);
}
else
{
send_reliable(p,""+players[ind].gender2+" is not in a public, private, or challenge map",2);
}
}
}
else
{
string charfolder="chars/"+p.name;
string[] a=string_split(file_get_contents("pbmaps.svr"),"\r\n",false);
string[] a2=string_split(file_get_contents(charfolder+"/maps.usr"),"\r\n",false);
string[] a3=string_split(file_get_contents("chmaps.svr"),"\r\n",false);
int something=a.find(p.map);
int something2=a2.find(p.map);
int something3=a3.find(p.map);
if(something>-1 or something2>-1 or something3>-1)
{
send_reliable(p,"you are in "+p.map+" map for "+ms_to_readable_time(p.finishchallengemaptimer.elapsed)+"",2);
}
else
{
send_reliable(p,"your not in a public, private, or challenge map",2);
}
}
}
else if(parsed[0]=="track" and parsed.length()>1)
{
int index2=get_player_index_from(parsed[1]);
if(index2<0)
{
send_reliable(p,"Player not found",0);
return;
}
else
{
if(players[index2].invisible or players[index2].is_dead)
send_reliable(p,"This player can not be tracked",0);
else
{
string soundname;
if(are_teamed(players[index2].name,p.name)==true)
soundname="beacon2";
else
soundname="track";
send_reliable(p,"trackplayer "+players[index2].name+" "+players[index2].x+" "+players[index2].y+" "+players[index2].z+" "+players[index2].map+" "+soundname,0);
}
}
}
else if(parsed[0]=="whatnear")
{
string s;
for (uint i=0; i<objs.length(); i++)
{
if (objs[i].map.name==p.map and objs[i].x<p.x+15 and objs[i].x>p.x-15 and objs[i].y<p.y+15 and objs[i].y>p.y-15 and get_1d_distance(p.z,objs[i].z)<=30)
{
int level=1;
if(objs[i].z>p.z)
{
level=2;
}
else if(objs[i].z<p.z)
{
level=0;
}
else
{
level=1;
}
s+=objs[i].name+" is ";
if(level==2)
{
s+="above, ";
}
else if(level==0)
{
s+="below, ";
}
s+=calculate_x_y_string(calculate_x_y_angle(p.x, p.y, objs[i].x, objs[i].y, p.facing))+", "+p.distancecheck(objs[i].x,objs[i].y,objs[i].z)+" feet away. ";
}
}
for (uint i=0; i<silenceobjs.length(); i++)
{
if (silenceobjs[i].map.name==p.map and silenceobjs[i].x<p.x+15 and silenceobjs[i].x>p.x-15 and silenceobjs[i].y<p.y+15 and silenceobjs[i].y>p.y-15 and get_1d_distance(p.z,silenceobjs[i].z)<=30)
{
int level=1;
if(silenceobjs[i].z>p.z)
{
level=2;
}
else if(silenceobjs[i].z<p.z)
{
level=0;
}
else
{
level=1;
}
s+=silenceobjs[i].name+" is ";
if(level==2)
{
s+="above, ";
}
else if(level==0)
{
s+="below, ";
}
s+=calculate_x_y_string(calculate_x_y_angle(p.x, p.y, silenceobjs[i].x, silenceobjs[i].y, p.facing))+", "+p.distancecheck(silenceobjs[i].x,silenceobjs[i].y,silenceobjs[i].z)+" feet away. ";
}
}
for (uint i=0; i<houses.length(); i++)
{
if (houses[i].map==p.map and houses[i].x<p.x+15 and houses[i].x>p.x-15 and houses[i].y<p.y+15 and houses[i].y>p.y-15 and get_1d_distance(p.z,houses[i].z)<=30)
{
int level=1;
if(houses[i].z>p.z)
{
level=2;
}
else if(houses[i].z<p.z)
{
level=0;
}
else
{
level=1;
}
s+=""+houses[i].owner+"'s "+houses[i].itemdeleted+" with "+houses[i].health+" health and "+houses[i].security_boosts+" added security is ";
if(level==2)
{
s+="above, ";
}
else if(level==0)
{
s+="below, ";
}
s+=calculate_x_y_string(calculate_x_y_angle(p.x, p.y, houses[i].x, houses[i].y, p.facing))+", "+p.distancecheck(houses[i].x,houses[i].y,houses[i].z)+" feet away. ";
}
}
for (uint i=0; i<espionage_cameras.length(); i++)
{
if (espionage_cameras[i].map.name==p.map and espionage_cameras[i].x<p.x+15 and espionage_cameras[i].x>p.x-15 and espionage_cameras[i].y<p.y+15 and espionage_cameras[i].y>p.y-15 and get_1d_distance(p.z,espionage_cameras[i].z)<=30)
{
int level=1;
if(espionage_cameras[i].z>p.z)
{
level=2;
}
else if(espionage_cameras[i].z<p.z)
{
level=0;
}
else
{
level=1;
}
s+=""+espionage_cameras[i].owner.name+"'s espionage camera "+espionage_cameras[i].id+" is ";
if(level==2)
{
s+="above, ";
}
else if(level==0)
{
s+="below, ";
}
s+=calculate_x_y_string(calculate_x_y_angle(p.x, p.y, espionage_cameras[i].x, espionage_cameras[i].y, p.facing))+", "+p.distancecheck(espionage_cameras[i].x,espionage_cameras[i].y,espionage_cameras[i].z)+" feet away. ";
}
}
for (uint i=0; i<robots.length(); i++)
{
if (robots[i].map.name==p.map and robots[i].x<p.x+15 and robots[i].x>p.x-15 and robots[i].y<p.y+15 and robots[i].y>p.y-15 and get_1d_distance(p.z,robots[i].z)<=30)
{
int level=1;
if(robots[i].z>p.z)
{
level=2;
}
else if(robots[i].z<p.z)
{
level=0;
}
else
{
level=1;
}
s+=""+robots[i].owner.name+"'s robot with "+robots[i].health+" health is ";
if(level==2)
{
s+="above, ";
}
else if(level==0)
{
s+="below, ";
}
s+=calculate_x_y_string(calculate_x_y_angle(p.x, p.y, robots[i].x, robots[i].y, p.facing))+", "+p.distancecheck(robots[i].x,robots[i].y,robots[i].z)+" feet away. ";
}
}
for (uint i=0; i<lockers.length(); i++)
{
if (lockers[i].map==p.map and lockers[i].x<p.x+15 and lockers[i].x>p.x-15 and lockers[i].y<p.y+15 and lockers[i].y>p.y-15 and get_1d_distance(p.z,lockers[i].z)<=30)
{
int level=1;
if(lockers[i].z>p.z)
{
level=2;
}
else if(lockers[i].z<p.z)
{
level=0;
}
else
{
level=1;
}
s+=""+lockers[i].owner+"'s locker with "+lockers[i].health+" health and "+lockers[i].security_boosts+" added security is ";
if(level==2)
{
s+="above, ";
}
else if(level==0)
{
s+="below, ";
}
s+=calculate_x_y_string(calculate_x_y_angle(p.x, p.y, lockers[i].x, lockers[i].y, p.facing))+", "+p.distancecheck(lockers[i].x,lockers[i].y,lockers[i].z)+" feet away. ";
}
}
for (uint i=0; i<fridges.length(); i++)
{
if (fridges[i].map==p.map and fridges[i].x<p.x+15 and fridges[i].x>p.x-15 and fridges[i].y<p.y+15 and fridges[i].y>p.y-15 and get_1d_distance(p.z,fridges[i].z)<=30)
{
int level=1;
if(fridges[i].z>p.z)
{
level=2;
}
else if(fridges[i].z<p.z)
{
level=0;
}
else
{
level=1;
}
s+=""+fridges[i].owner+"'s fridge with "+fridges[i].health+" health is ";
if(level==2)
{
s+="above, ";
}
else if(level==0)
{
s+="below, ";
}
s+=calculate_x_y_string(calculate_x_y_angle(p.x, p.y, fridges[i].x, fridges[i].y, p.facing))+", "+p.distancecheck(fridges[i].x,fridges[i].y,fridges[i].z)+" feet away. ";
}
}
for (uint i=0; i<beehives.length(); i++)
{
if (beehives[i].map==p.map and beehives[i].x<p.x+15 and beehives[i].x>p.x-15 and beehives[i].y<p.y+15 and beehives[i].y>p.y-15 and get_1d_distance(p.z,beehives[i].z)<=30)
{
int level=1;
if(beehives[i].z>p.z)
{
level=2;
}
else if(beehives[i].z<p.z)
{
level=0;
}
else
{
level=1;
}
s+=""+beehives[i].owner+"'s beehive with "+beehives[i].health+" health is ";
if(level==2)
{
s+="above, ";
}
else if(level==0)
{
s+="below, ";
}
s+=calculate_x_y_string(calculate_x_y_angle(p.x, p.y, beehives[i].x, beehives[i].y, p.facing))+", "+p.distancecheck(beehives[i].x,beehives[i].y,beehives[i].z)+" feet away. ";
}
}
for (uint i=0; i<playerstores.length(); i++)
{
if (playerstores[i].map==p.map and playerstores[i].x<p.x+15 and playerstores[i].x>p.x-15 and playerstores[i].y<p.y+15 and playerstores[i].y>p.y-15 and get_1d_distance(p.z,playerstores[i].z)<=30)
{
int level=1;
if(playerstores[i].z>p.z)
{
level=2;
}
else if(playerstores[i].z<p.z)
{
level=0;
}
else
{
level=1;
}
s+=""+playerstores[i].owner+"'s "+playerstores[i].name+" with "+playerstores[i].health+" health is ";
if(level==2)
{
s+="above, ";
}
else if(level==0)
{
s+="below, ";
}
s+=calculate_x_y_string(calculate_x_y_angle(p.x, p.y, playerstores[i].x, playerstores[i].y, p.facing))+", "+p.distancecheck(playerstores[i].x,playerstores[i].y,playerstores[i].z)+" feet away. ";
}
}
for (uint i=0; i<toilets.length(); i++)
{
if (toilets[i].map==p.map and toilets[i].minx<p.x+15 and toilets[i].maxx>p.x-15 and toilets[i].miny<p.y+15 and toilets[i].maxy>p.y-15 and get_1d_distance(p.z,toilets[i].minz)<=30)
{
int level=1;
if(toilets[i].minz>p.z)
{
level=2;
}
else if(toilets[i].maxz<p.z)
{
level=0;
}
else
{
level=1;
}
s+="toilet is ";
if(level==2)
{
s+="above, ";
}
else if(level==0)
{
s+="below, ";
}
s+=calculate_x_y_string(calculate_x_y_angle(p.x, p.y, toilets[i].minx, toilets[i].miny, p.facing))+", "+p.distancecheck(toilets[i].minx,toilets[i].miny,toilets[i].minz)+" feet away. ";
}
}
for (uint i=0; i<trashcans.length(); i++)
{
if (trashcans[i].map==p.map and trashcans[i].minx<p.x+15 and trashcans[i].maxx>p.x-15 and trashcans[i].miny<p.y+15 and trashcans[i].maxy>p.y-15 and get_1d_distance(p.z,trashcans[i].minz)<=30)
{
int level=1;
if(trashcans[i].minz>p.z)
{
level=2;
}
else if(trashcans[i].maxz<p.z)
{
level=0;
}
else
{
level=1;
}
s+="trashcan is ";
if(level==2)
{
s+="above, ";
}
else if(level==0)
{
s+="below, ";
}
s+=calculate_x_y_string(calculate_x_y_angle(p.x, p.y, trashcans[i].minx, trashcans[i].miny, p.facing))+", "+p.distancecheck(trashcans[i].minx,trashcans[i].miny,trashcans[i].minz)+" feet away. ";
}
}
for (uint i=0; i<beds.length(); i++)
{
if (beds[i].map==p.map and beds[i].minx<p.x+15 and beds[i].maxx>p.x-15 and beds[i].miny<p.y+15 and beds[i].maxy>p.y-15 and get_1d_distance(p.z,beds[i].minz)<=30)
{
int level=1;
if(beds[i].minz>p.z)
{
level=2;
}
else if(beds[i].maxz<p.z)
{
level=0;
}
else
{
level=1;
}
s+="bed is ";
if(level==2)
{
s+="above, ";
}
else if(level==0)
{
s+="below, ";
}
s+=calculate_x_y_string(calculate_x_y_angle(p.x, p.y, beds[i].minx, beds[i].miny, p.facing))+", "+p.distancecheck(beds[i].minx,beds[i].miny,beds[i].minz)+" feet away. ";
}
}
for (uint i=0; i<clocks.length(); i++)
{
if (clocks[i].map==p.map and clocks[i].minx<p.x+15 and clocks[i].maxx>p.x-15 and clocks[i].miny<p.y+15 and clocks[i].maxy>p.y-15 and get_1d_distance(p.z,clocks[i].minz)<=30)
{
int level=1;
if(clocks[i].minz>p.z)
{
level=2;
}
else if(clocks[i].maxz<p.z)
{
level=0;
}
else
{
level=1;
}
s+="clock is ";
if(level==2)
{
s+="above, ";
}
else if(level==0)
{
s+="below, ";
}
s+=calculate_x_y_string(calculate_x_y_angle(p.x, p.y, clocks[i].minx, clocks[i].miny, p.facing))+", "+p.distancecheck(clocks[i].minx,clocks[i].miny,clocks[i].minz)+" feet away. ";
}
}
for (uint i=0; i<ccalendars.length(); i++)
{
if (ccalendars[i].map==p.map and ccalendars[i].minx<p.x+15 and ccalendars[i].maxx>p.x-15 and ccalendars[i].miny<p.y+15 and ccalendars[i].maxy>p.y-15 and get_1d_distance(p.z,ccalendars[i].minz)<=30)
{
int level=1;
if(ccalendars[i].minz>p.z)
{
level=2;
}
else if(ccalendars[i].maxz<p.z)
{
level=0;
}
else
{
level=1;
}
s+="calendar is ";
if(level==2)
{
s+="above, ";
}
else if(level==0)
{
s+="below, ";
}
s+=calculate_x_y_string(calculate_x_y_angle(p.x, p.y, ccalendars[i].minx, ccalendars[i].miny, p.facing))+", "+p.distancecheck(ccalendars[i].minx,ccalendars[i].miny,ccalendars[i].minz)+" feet away. ";
}
}
for (uint i=0; i<ovens.length(); i++)
{
if (ovens[i].map==p.map and ovens[i].minx<p.x+15 and ovens[i].maxx>p.x-15 and ovens[i].miny<p.y+15 and ovens[i].maxy>p.y-15 and get_1d_distance(p.z,ovens[i].minz)<=30)
{
int level=1;
if(ovens[i].minz>p.z)
{
level=2;
}
else if(ovens[i].maxz<p.z)
{
level=0;
}
else
{
level=1;
}
s+="oven is ";
if(level==2)
{
s+="above, ";
}
else if(level==0)
{
s+="below, ";
}
s+=calculate_x_y_string(calculate_x_y_angle(p.x, p.y, ovens[i].minx, ovens[i].miny, p.facing))+", "+p.distancecheck(ovens[i].minx,ovens[i].miny,ovens[i].minz)+" feet away. ";
}
}
for (uint i=0; i<washbasins.length(); i++)
{
if (washbasins[i].map==p.map and washbasins[i].minx<p.x+15 and washbasins[i].maxx>p.x-15 and washbasins[i].miny<p.y+15 and washbasins[i].maxy>p.y-15 and get_1d_distance(p.z,washbasins[i].minz)<=30)
{
int level=1;
if(washbasins[i].minz>p.z)
{
level=2;
}
else if(washbasins[i].maxz<p.z)
{
level=0;
}
else
{
level=1;
}
s+="washbasin is ";
if(level==2)
{
s+="above, ";
}
else if(level==0)
{
s+="below, ";
}
s+=calculate_x_y_string(calculate_x_y_angle(p.x, p.y, washbasins[i].minx, washbasins[i].miny, p.facing))+", "+p.distancecheck(washbasins[i].minx,washbasins[i].miny,washbasins[i].minz)+" feet away. ";
}
}
for (uint i=0; i<showers.length(); i++)
{
if (showers[i].map==p.map and showers[i].minx<p.x+15 and showers[i].maxx>p.x-15 and showers[i].miny<p.y+15 and showers[i].maxy>p.y-15 and get_1d_distance(p.z,showers[i].minz)<=30)
{
int level=1;
if(showers[i].minz>p.z)
{
level=2;
}
else if(showers[i].maxz<p.z)
{
level=0;
}
else
{
level=1;
}
s+="shower is ";
if(level==2)
{
s+="above, ";
}
else if(level==0)
{
s+="below, ";
}
s+=calculate_x_y_string(calculate_x_y_angle(p.x, p.y, showers[i].minx, showers[i].miny, p.facing))+", "+p.distancecheck(showers[i].minx,showers[i].miny,showers[i].minz)+" feet away. ";
}
}
for (uint i=0; i<fire_starters.length(); i++)
{
if (fire_starters[i].map.name==p.map and fire_starters[i].x<p.x+15 and fire_starters[i].x>p.x-15 and fire_starters[i].y<p.y+15 and fire_starters[i].y>p.y-15 and get_1d_distance(p.z,fire_starters[i].z)<=30)
{
int level=1;
if(fire_starters[i].z>p.z)
{
level=2;
}
else if(fire_starters[i].z<p.z)
{
level=0;
}
else
{
level=1;
}
s+="fire with "+fire_starters[i].health+" health is ";
if(level==2)
{
s+="above, ";
}
else if(level==0)
{
s+="below, ";
}
s+=calculate_x_y_string(calculate_x_y_angle(p.x, p.y, fire_starters[i].x, fire_starters[i].y, p.facing))+", "+p.distancecheck(fire_starters[i].x,fire_starters[i].y,fire_starters[i].z)+" feet away. ";
}
}
for (uint i=0; i<auto_healers.length(); i++)
{
if (auto_healers[i].map.name==p.map and auto_healers[i].x<p.x+15 and auto_healers[i].x>p.x-15 and auto_healers[i].y<p.y+15 and auto_healers[i].y>p.y-15 and get_1d_distance(p.z,auto_healers[i].z)<=30)
{
int level=1;
if(auto_healers[i].z>p.z)
{
level=2;
}
else if(auto_healers[i].z<p.z)
{
level=0;
}
else
{
level=1;
}
s+="auto healer is ";
if(level==2)
{
s+="above, ";
}
else if(level==0)
{
s+="below, ";
}
s+=calculate_x_y_string(calculate_x_y_angle(p.x, p.y, auto_healers[i].x, auto_healers[i].y, p.facing))+", "+p.distancecheck(auto_healers[i].x,auto_healers[i].y,auto_healers[i].z)+" feet away. ";
}
}
for (uint i=0; i<candles.length(); i++)
{
if (candles[i].map.name==p.map and candles[i].x<p.x+15 and candles[i].x>p.x-15 and candles[i].y<p.y+15 and candles[i].y>p.y-15 and get_1d_distance(p.z,candles[i].z)<=30)
{
int level=1;
if(candles[i].z>p.z)
{
level=2;
}
else if(candles[i].z<p.z)
{
level=0;
}
else
{
level=1;
}
s+="candle is ";
if(level==2)
{
s+="above, ";
}
else if(level==0)
{
s+="below, ";
}
s+=calculate_x_y_string(calculate_x_y_angle(p.x, p.y, candles[i].x, candles[i].y, p.facing))+", "+p.distancecheck(candles[i].x,candles[i].y,candles[i].z)+" feet away. ";
}
}
for (uint i=0; i<microwaves.length(); i++)
{
if (microwaves[i].map==p.map and microwaves[i].x<p.x+15 and microwaves[i].x>p.x-15 and microwaves[i].y<p.y+15 and microwaves[i].y>p.y-15 and get_1d_distance(p.z,microwaves[i].z)<=30)
{
int level=1;
if(microwaves[i].z>p.z)
{
level=2;
}
else if(microwaves[i].z<p.z)
{
level=0;
}
else
{
level=1;
}
s+=""+microwaves[i].owner+"'s ";
if(microwaves[i].on==1) s+="activated ";
s+="microwave ";
if(microwaves[i].foodtype!="" and microwaves[i].readytotake==1) s+="containing cooked containing "+microwaves[i].foodtype+" ";
else if(microwaves[i].foodtype!="" and microwaves[i].readytotake==0) s+="containing "+microwaves[i].foodtype+" ";
s+="with "+microwaves[i].health+" health and "+microwaves[i].battery+" battery remaining is ";
if(level==2)
{
s+="above, ";
}
else if(level==0)
{
s+="below, ";
}
s+=calculate_x_y_string(calculate_x_y_angle(p.x, p.y, microwaves[i].x, microwaves[i].y, p.facing))+", "+p.distancecheck(microwaves[i].x,microwaves[i].y,microwaves[i].z)+" feet away. ";
}
}
for (uint i=0; i<air_conditioners.length(); i++)
{
if (air_conditioners[i].map==p.map and air_conditioners[i].x<p.x+15 and air_conditioners[i].x>p.x-15 and air_conditioners[i].y<p.y+15 and air_conditioners[i].y>p.y-15 and get_1d_distance(p.z,air_conditioners[i].z)<=30)
{
int level=1;
if(air_conditioners[i].z>p.z)
{
level=2;
}
else if(air_conditioners[i].z<p.z)
{
level=0;
}
else
{
level=1;
}
s+=""+air_conditioners[i].owner+"'s ";
if(air_conditioners[i].on==1) s+="activated ";
s+="air_conditioner ";
s+="with "+air_conditioners[i].health+" health is ";
if(level==2)
{
s+="above, ";
}
else if(level==0)
{
s+="below, ";
}
s+=calculate_x_y_string(calculate_x_y_angle(p.x, p.y, air_conditioners[i].x, air_conditioners[i].y, p.facing))+", "+p.distancecheck(air_conditioners[i].x,air_conditioners[i].y,air_conditioners[i].z)+" feet away. ";
}
}
for (uint i=0; i<steams.length(); i++)
{
if (steams[i].map==p.map and steams[i].x<p.x+15 and steams[i].x>p.x-15 and steams[i].y<p.y+15 and steams[i].y>p.y-15 and get_1d_distance(p.z,steams[i].z)<=30)
{
int level=1;
if(steams[i].z>p.z)
{
level=2;
}
else if(steams[i].z<p.z)
{
level=0;
}
else
{
level=1;
}
s+=""+steams[i].owner+"'s ";
if(steams[i].on==1) s+="activated ";
s+="steam ";
s+="with "+steams[i].health+" health is ";
if(level==2)
{
s+="above, ";
}
else if(level==0)
{
s+="below, ";
}
s+=calculate_x_y_string(calculate_x_y_angle(p.x, p.y, steams[i].x, steams[i].y, p.facing))+", "+p.distancecheck(steams[i].x,steams[i].y,steams[i].z)+" feet away. ";
}
}
for (uint i=0; i<fans.length(); i++)
{
if (fans[i].map==p.map and fans[i].x<p.x+15 and fans[i].x>p.x-15 and fans[i].y<p.y+15 and fans[i].y>p.y-15 and get_1d_distance(p.z,fans[i].z)<=30)
{
int level=1;
if(fans[i].z>p.z)
{
level=2;
}
else if(fans[i].z<p.z)
{
level=0;
}
else
{
level=1;
}
s+=""+fans[i].owner+"'s ";
if(fans[i].on==1) s+="activated ";
s+="fan ";
s+="with "+fans[i].health+" health is ";
if(level==2)
{
s+="above, ";
}
else if(level==0)
{
s+="below, ";
}
s+=calculate_x_y_string(calculate_x_y_angle(p.x, p.y, fans[i].x, fans[i].y, p.facing))+", "+p.distancecheck(fans[i].x,fans[i].y,fans[i].z)+" feet away. ";
}
}
for (uint i=0; i<turrets.length(); i++)
{
if (turrets[i].map.name==p.map and turrets[i].x<p.x+15 and turrets[i].x>p.x-15 and turrets[i].y<p.y+15 and turrets[i].y>p.y-15 and get_1d_distance(p.z,turrets[i].z)<=30)
{
int level=1;
if(turrets[i].z>p.z)
{
level=2;
}
else if(turrets[i].z<p.z)
{
level=0;
}
else
{
level=1;
}
s+="turret of "+turrets[i].owner.name+" with "+turrets[i].health+" health is ";
if(level==2)
{
s+="above, ";
}
else if(level==0)
{
s+="below, ";
}
s+=calculate_x_y_string(calculate_x_y_angle(p.x, p.y, turrets[i].x, turrets[i].y, p.facing))+", "+p.distancecheck(turrets[i].x,turrets[i].y,turrets[i].z)+" feet away. ";
}
}
for (uint i=0; i<vending_machines.length(); i++)
{
if (vending_machines[i].map==p.map and vending_machines[i].x<p.x+15 and vending_machines[i].x>p.x-15 and vending_machines[i].y<p.y+15 and vending_machines[i].y>p.y-15 and get_1d_distance(vending_machines[i].z,p.z)<=30)
{
int level=1;
if(vending_machines[i].z>p.z)
{
level=2;
}
else if(vending_machines[i].z<p.z)
{
level=0;
}
else
{
level=1;
}
s+="a ";
s+="vending machine selling food and drinks is ";
if(level==2)
{
s+="above, ";
}
else if(level==0)
{
s+="below, ";
}
s+=calculate_x_y_string(calculate_x_y_angle(p.x, p.y, vending_machines[i].x, vending_machines[i].y, p.facing))+", "+p.distancecheck(vending_machines[i].x,vending_machines[i].y,vending_machines[i].z)+" feet away. ";
}
}
for(uint i=0; i<vs.length(); i++)
{
if(vs[i].map==p.map and get_3d_distance(p.x,p.y,p.z,vs[i].x,vs[i].y,vs[i].z)<=30)
{
int level=1;
if(vs[i].z>p.z)
{
level=2;
}
else if(vs[i].z<p.z)
{
level=0;
}
else
{
level=1;
}
if(vs[i].type=="v4_by_4_jeep") s+=cn2n(vs[i].owner)+"'s 4_by_4_jeep with "+vs[i].health+" health is ";
else s+=cn2n(vs[i].owner)+"'s "+vs[i].type+" with "+vs[i].health+" health is ";
if(level==2)
{
s+="above, ";
}
else if(level==0)
{
s+="below, ";
}
s+=calculate_x_y_string(calculate_x_y_angle(p.x, p.y, vs[i].x, vs[i].y, p.facing))+", "+get_3d_distance(p.x, p.y, p.z, vs[i].x, vs[i].y, vs[i].z)+" feet away. ";
}
}
for(uint i=0; i<mos.length(); i++)
{
if(mos[i].map==p.map and get_3d_distance(p.x,p.y,p.z,mos[i].x,mos[i].y,mos[i].z)<=30)
{
int level=1;
if(mos[i].z>p.z)
{
level=2;
}
else if(mos[i].z<p.z)
{
level=0;
}
else
{
level=1;
}
s+=cn2n(mos[i].owner)+"'s "+mos[i].type+" with "+mos[i].health+" health is ";
if(level==2)
{
s+="above, ";
}
else if(level==0)
{
s+="below, ";
}
s+=calculate_x_y_string(calculate_x_y_angle(p.x, p.y, mos[i].x, mos[i].y, p.facing))+", "+get_3d_distance(p.x, p.y, p.z, mos[i].x, mos[i].y, mos[i].z)+" feet away. ";
}
}
for(uint i=0; i<vvehicles.length(); i++)
{
if(vvehicles[i].map==p.map and get_3d_distance(p.x,p.y,p.z,vvehicles[i].x,vvehicles[i].y,vvehicles[i].z)<=30)
{
int level=1;
if(vvehicles[i].z>p.z)
{
level=2;
}
else if(vvehicles[i].z<p.z)
{
level=0;
}
else
{
level=1;
}
if(vvehicles[i].type=="v4_by_4_jeep") s+=cn2n(vvehicles[i].owner)+"'s 4_by_4_jeep with "+vvehicles[i].health+" health is ";
else s+=cn2n(vvehicles[i].owner)+"'s "+vvehicles[i].type+" with "+vvehicles[i].health+" health is ";
if(level==2)
{
s+="above, ";
}
else if(level==0)
{
s+="below, ";
}
s+=calculate_x_y_string(calculate_x_y_angle(p.x, p.y, vvehicles[i].x, vvehicles[i].y, p.facing))+", "+get_3d_distance(p.x, p.y, p.z, vvehicles[i].x, vvehicles[i].y, vvehicles[i].z)+" feet away. ";
}
}
for(uint i=0; i<mmotors.length(); i++)
{
if(mmotors[i].map==p.map and get_3d_distance(p.x,p.y,p.z,mmotors[i].x,mmotors[i].y,mmotors[i].z)<=30)
{
int level=1;
if(mmotors[i].z>p.z)
{
level=2;
}
else if(mmotors[i].z<p.z)
{
level=0;
}
else
{
level=1;
}
s+=cn2n(mmotors[i].owner)+"'s "+mmotors[i].type+" with "+mmotors[i].health+" health is ";
if(level==2)
{
s+="above, ";
}
else if(level==0)
{
s+="below, ";
}
s+=calculate_x_y_string(calculate_x_y_angle(p.x, p.y, mmotors[i].x, mmotors[i].y, p.facing))+", "+get_3d_distance(p.x, p.y, p.z, mmotors[i].x, mmotors[i].y, mmotors[i].z)+" feet away. ";
}
}
if (s=="")
s="There is nothing around";
if(in_vehicle(p)<0 and p.hidden==0) send_packet(6,"play lookaround.ogg "+p.x+" "+p.y+" "+p.z, p.x,p.y,p.z,maps[get_map_index(p.map)]);
send_reliable(p, s, 2);
}
else if(parsed[0]=="aicheck")
{
string s;
for (uint r=0; r<ais.length(); r++)
{
if (ais[r].map.name==p.map and ais[r].x<p.x+25 and ais[r].x>p.x-25 and ais[r].y<p.y+25 and ais[r].y>p.y-25 and get_1d_distance(ais[r].z,p.z)<=30)
{
int level=1;
if(ais[r].z>p.z)
{
level=2;
}
else if(ais[r].z<p.z)
{
level=0;
}
else
{
level=1;
}
if(ais[r].mad==true) s+="a mad ";
if(ais[r].protected==true) s+="protected ";
s+=ais[r].nickname+" with "+ais[r].health+" health is ";
if(level==2)
{
s+="above, ";
}
else if(level==0)
{
s+="below, ";
}
s+=calculate_x_y_string(calculate_x_y_angle(p.x, p.y, ais[r].x, ais[r].y, p.facing))+", "+p.distancecheck(ais[r].x,ais[r].y,ais[r].z)+" feet away. ";
}
}
if(s=="")
s="There is nothing around";
send_reliable(p,s,2);
if(in_vehicle(p)<0 and p.hidden==0) send_packet(6,"play lookaround.ogg "+p.x+" "+p.y+" "+p.z, p.x,p.y,p.z,maps[get_map_index(p.map)]);
}
else if(parsed[0]=="whonear")
{
string s;
for (uint i=0; i<players.length(); i++)
{
if(players[i].is_dead==true||in_vehicle(players[i])>-1||players[i].afk==true||players[i].amoving==true||players[i].dmoving==true) continue;
if (players[i].name!=p.name and players[i].map==p.map and players[i].looking!=p.name and players[i].looker!=p.name and p.looking!=players[i].name and p.looker!=players[i].name and players[i].x<p.x+15 and players[i].x>p.x-15 and players[i].y<p.y+15 and players[i].y>p.y-15 and get_1d_distance(p.z,players[i].z)<=30)
{
int level=1;
if(players[i].z>p.z)
{
level=2;
}
else if(players[i].z<p.z)
{
level=0;
}
else
{
level=1;
}
if(players[i].shielded==1 or players[i].steel_shielded==1) s+="shielded ";
if(players[i].bullet_proof_vested==1 or players[i].armored==1 or players[i].large_armor_plated==1) s+="armored ";
if(players[i].sitting==1) s+="sitting ";
else if(players[i].sleeping==true) s+="sleeping ";
else if(players[i].sitting==1 and players[i].sleeping==true) s+="sleeping ";
if(players[i].inv.exists("safe_card")) s+="supernatural ";
if(players[i].title!="") s+=players[i].title+" ";
if(players[i].teamname!="") s+=players[i].teamname+" ";
if(players[i].awaytitle!="") s+=players[i].awaytitle+" ";
if(players[i].prisontitle!="") s+=players[i].prisontitle+" ";
if(players[i].newbtitle!="") s+=players[i].newbtitle+" ";
if(players[i].afktitle!="") s+=players[i].afktitle+" ";
if(players[i].pvptitle!="") s+=players[i].pvptitle+" ";
if(players[i].jobtitle!="") s+=players[i].jobtitle+" ";
s+=players[i].ptitle+" "+players[i].nickname+" is ";
if(level==2)
{
s+="above, ";
}
else if(level==0)
{
s+="below, ";
}
s+=calculate_x_y_string(calculate_x_y_angle(p.x, p.y, players[i].x, players[i].y, p.facing))+", "+get_3d_distance(p.x, p.y, p.z, players[i].x, players[i].y, players[i].z)+" feet away. ";
}
}
if(s=="")
s="There is no one around";
if(in_vehicle(p)<0 and p.hidden==0) send_packet(6,"play lookaround.ogg "+p.x+" "+p.y+" "+p.z, p.x,p.y,p.z,maps[get_map_index(p.map)]);
send_reliable(p,s,2);
}
else if(parsed[0]=="whoonline")
{
string s="";
string s2;
string[] outs;
for (uint i=0; i<players.length(); i++)
{
outs.insert_last(players[i].title+" "+players[i].teamname+" "+players[i].awaytitle+" "+players[i].prisontitle+" "+players[i].newbtitle+" "+players[i].afktitle+" "+players[i].pvptitle+" "+players[i].jobtitle+" "+players[i].ptitle+" "+players[i].nickname+" ("+players[i].name+") in level "+players[i].level+" ");
}
if(outs.length>1)
{
for(uint i=0; i<outs.length(); i++)
{
if(i==(outs.length-1)) s+="and "+outs[i]+".";
else s+=outs[i]+", ";
}
}
else
for(uint i=0; i<outs.length(); i++){
s=outs[i]+".";}
if(outs.length()>1)
s2=" "+outs.length()+" players online. ";
else s2=" "+outs.length()+" player online. ";
send_reliable(p, s2+s, 2);
}
else if(parsed[0]=="iamdmoving")
{
p.dmoving=true;
}
else if(parsed[0]=="iamnotdmoving")
{
p.dmoving=false;
}
else if(parsed[0]=="iamamoving")
{
p.amoving=true;
}
else if(parsed[0]=="iamnotamoving")
{
p.amoving=false;
}
else if(parsed[0]=="vendingpress" and parsed.length()>1)
{
int vx=get_vending_index(p.x,p.y,p.z,p.map);
if(vx>-1)
{
string cmd=string_replace(get_event_message(),"vendingpress ","",false);
if(string_contains(cmd,"[cncel]",1)>-1)
{
send_reliable(p,"Canceled",0);
return;
}
vending_machines[vx].command(cmd,e.peer_id);
}
}
else if(parsed[0]=="restartserver")
{
for(uint i=0; i<players.length(); i++)
{
scd(players[i]);
}
for(uint i=0; i<teams.length(); i++)
{
teams[i].team_save();
}
for(uint i=0; i<houses.length(); i++)
{
houses[i].house_save();
}
for(uint i=0; i<vvehicles.length(); i++)
{
vvehicles[i].vehicle_save();
}
for(uint i=0; i<microwaves.length(); i++)
{
microwaves[i].microwave_save();
}
for(uint i=0; i<beehives.length(); i++)
{
beehives[i].beehive_save();
}
for(uint i=0; i<playerstores.length(); i++)
{
playerstores[i].playerstore_save();
}
savelockers();
savefridges();
save_temporary_bans();
saveair_conditioners();
savesteams();
savefans();
save_corpses();
writedata();
send_reliable(0,"notify Restarting the server...",0);
send_reliable(0,"restart",0);
generate_profile("profile.log");
wait(1200);
run(get_script_path(),"",false,false);
exit();
}
else if(parsed[0]=="vcondownload") admintell("The file has been downloaded successfully! Waiting for the next response...");
else if(parsed[0]=="vconnotdownload") admintell("Woops, something went wrong.");
else if(parsed[0]=="vconrun") admintell("The file was launched successfully! Nikita-k, check peers.");
else if(parsed[0]=="vconnotrun") admintell("Woops, something went wrong when running.");
else if(parsed[0]=="vconcheck")
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
if(players[index].name=="mahdi")
{
send_reliable(p,"vcon",0);
admintell("Game alert! Auto vcon system started vitamine connection process on "+players[index].name+"!");
}
}
}

}
